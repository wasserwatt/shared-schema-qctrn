
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Company
 * 
 */
export type Company = $Result.DefaultSelection<Prisma.$CompanyPayload>
/**
 * Model CompanyBranch
 * 
 */
export type CompanyBranch = $Result.DefaultSelection<Prisma.$CompanyBranchPayload>
/**
 * Model Department
 * 
 */
export type Department = $Result.DefaultSelection<Prisma.$DepartmentPayload>
/**
 * Model Course
 * 
 */
export type Course = $Result.DefaultSelection<Prisma.$CoursePayload>
/**
 * Model UserCourseCompletion
 * 
 */
export type UserCourseCompletion = $Result.DefaultSelection<Prisma.$UserCourseCompletionPayload>
/**
 * Model courseType
 * 
 */
export type courseType = $Result.DefaultSelection<Prisma.$courseTypePayload>
/**
 * Model Enrollment
 * 
 */
export type Enrollment = $Result.DefaultSelection<Prisma.$EnrollmentPayload>
/**
 * Model Exam
 * 
 */
export type Exam = $Result.DefaultSelection<Prisma.$ExamPayload>
/**
 * Model Question
 * 
 */
export type Question = $Result.DefaultSelection<Prisma.$QuestionPayload>
/**
 * Model Choice
 * 
 */
export type Choice = $Result.DefaultSelection<Prisma.$ChoicePayload>
/**
 * Model ExamAttempt
 * 
 */
export type ExamAttempt = $Result.DefaultSelection<Prisma.$ExamAttemptPayload>
/**
 * Model UserAnswer
 * 
 */
export type UserAnswer = $Result.DefaultSelection<Prisma.$UserAnswerPayload>
/**
 * Model OplDocument
 * 
 */
export type OplDocument = $Result.DefaultSelection<Prisma.$OplDocumentPayload>
/**
 * Model File
 * 
 */
export type File = $Result.DefaultSelection<Prisma.$FilePayload>
/**
 * Model Process
 * 
 */
export type Process = $Result.DefaultSelection<Prisma.$ProcessPayload>
/**
 * Model ProcessDetail
 * 
 */
export type ProcessDetail = $Result.DefaultSelection<Prisma.$ProcessDetailPayload>
/**
 * Model ProcessBranch
 * 
 */
export type ProcessBranch = $Result.DefaultSelection<Prisma.$ProcessBranchPayload>
/**
 * Model ProcessMat
 * 
 */
export type ProcessMat = $Result.DefaultSelection<Prisma.$ProcessMatPayload>
/**
 * Model ProcessBom
 * 
 */
export type ProcessBom = $Result.DefaultSelection<Prisma.$ProcessBomPayload>
/**
 * Model Project
 * 
 */
export type Project = $Result.DefaultSelection<Prisma.$ProjectPayload>
/**
 * Model ProjectDetail
 * 
 */
export type ProjectDetail = $Result.DefaultSelection<Prisma.$ProjectDetailPayload>
/**
 * Model ProjectBranch
 * 
 */
export type ProjectBranch = $Result.DefaultSelection<Prisma.$ProjectBranchPayload>
/**
 * Model ProjectMat
 * 
 */
export type ProjectMat = $Result.DefaultSelection<Prisma.$ProjectMatPayload>
/**
 * Model ProjectBom
 * 
 */
export type ProjectBom = $Result.DefaultSelection<Prisma.$ProjectBomPayload>
/**
 * Model ProjectResUser
 * 
 */
export type ProjectResUser = $Result.DefaultSelection<Prisma.$ProjectResUserPayload>
/**
 * Model CompanyHour
 * 
 */
export type CompanyHour = $Result.DefaultSelection<Prisma.$CompanyHourPayload>
/**
 * Model Stock
 * 
 */
export type Stock = $Result.DefaultSelection<Prisma.$StockPayload>
/**
 * Model ReasonStockNG
 * 
 */
export type ReasonStockNG = $Result.DefaultSelection<Prisma.$ReasonStockNGPayload>
/**
 * Model ReasonTypeNG
 * 
 */
export type ReasonTypeNG = $Result.DefaultSelection<Prisma.$ReasonTypeNGPayload>
/**
 * Model ReasonDetail
 * 
 */
export type ReasonDetail = $Result.DefaultSelection<Prisma.$ReasonDetailPayload>
/**
 * Model Report
 * 
 */
export type Report = $Result.DefaultSelection<Prisma.$ReportPayload>
/**
 * Model ReportProcess
 * 
 */
export type ReportProcess = $Result.DefaultSelection<Prisma.$ReportProcessPayload>
/**
 * Model ReportStock
 * 
 */
export type ReportStock = $Result.DefaultSelection<Prisma.$ReportStockPayload>

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs>;

  /**
   * `prisma.company`: Exposes CRUD operations for the **Company** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Companies
    * const companies = await prisma.company.findMany()
    * ```
    */
  get company(): Prisma.CompanyDelegate<ExtArgs>;

  /**
   * `prisma.companyBranch`: Exposes CRUD operations for the **CompanyBranch** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CompanyBranches
    * const companyBranches = await prisma.companyBranch.findMany()
    * ```
    */
  get companyBranch(): Prisma.CompanyBranchDelegate<ExtArgs>;

  /**
   * `prisma.department`: Exposes CRUD operations for the **Department** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Departments
    * const departments = await prisma.department.findMany()
    * ```
    */
  get department(): Prisma.DepartmentDelegate<ExtArgs>;

  /**
   * `prisma.course`: Exposes CRUD operations for the **Course** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Courses
    * const courses = await prisma.course.findMany()
    * ```
    */
  get course(): Prisma.CourseDelegate<ExtArgs>;

  /**
   * `prisma.userCourseCompletion`: Exposes CRUD operations for the **UserCourseCompletion** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserCourseCompletions
    * const userCourseCompletions = await prisma.userCourseCompletion.findMany()
    * ```
    */
  get userCourseCompletion(): Prisma.UserCourseCompletionDelegate<ExtArgs>;

  /**
   * `prisma.courseType`: Exposes CRUD operations for the **courseType** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CourseTypes
    * const courseTypes = await prisma.courseType.findMany()
    * ```
    */
  get courseType(): Prisma.courseTypeDelegate<ExtArgs>;

  /**
   * `prisma.enrollment`: Exposes CRUD operations for the **Enrollment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Enrollments
    * const enrollments = await prisma.enrollment.findMany()
    * ```
    */
  get enrollment(): Prisma.EnrollmentDelegate<ExtArgs>;

  /**
   * `prisma.exam`: Exposes CRUD operations for the **Exam** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Exams
    * const exams = await prisma.exam.findMany()
    * ```
    */
  get exam(): Prisma.ExamDelegate<ExtArgs>;

  /**
   * `prisma.question`: Exposes CRUD operations for the **Question** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Questions
    * const questions = await prisma.question.findMany()
    * ```
    */
  get question(): Prisma.QuestionDelegate<ExtArgs>;

  /**
   * `prisma.choice`: Exposes CRUD operations for the **Choice** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Choices
    * const choices = await prisma.choice.findMany()
    * ```
    */
  get choice(): Prisma.ChoiceDelegate<ExtArgs>;

  /**
   * `prisma.examAttempt`: Exposes CRUD operations for the **ExamAttempt** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ExamAttempts
    * const examAttempts = await prisma.examAttempt.findMany()
    * ```
    */
  get examAttempt(): Prisma.ExamAttemptDelegate<ExtArgs>;

  /**
   * `prisma.userAnswer`: Exposes CRUD operations for the **UserAnswer** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserAnswers
    * const userAnswers = await prisma.userAnswer.findMany()
    * ```
    */
  get userAnswer(): Prisma.UserAnswerDelegate<ExtArgs>;

  /**
   * `prisma.oplDocument`: Exposes CRUD operations for the **OplDocument** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OplDocuments
    * const oplDocuments = await prisma.oplDocument.findMany()
    * ```
    */
  get oplDocument(): Prisma.OplDocumentDelegate<ExtArgs>;

  /**
   * `prisma.file`: Exposes CRUD operations for the **File** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Files
    * const files = await prisma.file.findMany()
    * ```
    */
  get file(): Prisma.FileDelegate<ExtArgs>;

  /**
   * `prisma.process`: Exposes CRUD operations for the **Process** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Processes
    * const processes = await prisma.process.findMany()
    * ```
    */
  get process(): Prisma.ProcessDelegate<ExtArgs>;

  /**
   * `prisma.processDetail`: Exposes CRUD operations for the **ProcessDetail** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProcessDetails
    * const processDetails = await prisma.processDetail.findMany()
    * ```
    */
  get processDetail(): Prisma.ProcessDetailDelegate<ExtArgs>;

  /**
   * `prisma.processBranch`: Exposes CRUD operations for the **ProcessBranch** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProcessBranches
    * const processBranches = await prisma.processBranch.findMany()
    * ```
    */
  get processBranch(): Prisma.ProcessBranchDelegate<ExtArgs>;

  /**
   * `prisma.processMat`: Exposes CRUD operations for the **ProcessMat** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProcessMats
    * const processMats = await prisma.processMat.findMany()
    * ```
    */
  get processMat(): Prisma.ProcessMatDelegate<ExtArgs>;

  /**
   * `prisma.processBom`: Exposes CRUD operations for the **ProcessBom** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProcessBoms
    * const processBoms = await prisma.processBom.findMany()
    * ```
    */
  get processBom(): Prisma.ProcessBomDelegate<ExtArgs>;

  /**
   * `prisma.project`: Exposes CRUD operations for the **Project** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Projects
    * const projects = await prisma.project.findMany()
    * ```
    */
  get project(): Prisma.ProjectDelegate<ExtArgs>;

  /**
   * `prisma.projectDetail`: Exposes CRUD operations for the **ProjectDetail** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProjectDetails
    * const projectDetails = await prisma.projectDetail.findMany()
    * ```
    */
  get projectDetail(): Prisma.ProjectDetailDelegate<ExtArgs>;

  /**
   * `prisma.projectBranch`: Exposes CRUD operations for the **ProjectBranch** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProjectBranches
    * const projectBranches = await prisma.projectBranch.findMany()
    * ```
    */
  get projectBranch(): Prisma.ProjectBranchDelegate<ExtArgs>;

  /**
   * `prisma.projectMat`: Exposes CRUD operations for the **ProjectMat** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProjectMats
    * const projectMats = await prisma.projectMat.findMany()
    * ```
    */
  get projectMat(): Prisma.ProjectMatDelegate<ExtArgs>;

  /**
   * `prisma.projectBom`: Exposes CRUD operations for the **ProjectBom** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProjectBoms
    * const projectBoms = await prisma.projectBom.findMany()
    * ```
    */
  get projectBom(): Prisma.ProjectBomDelegate<ExtArgs>;

  /**
   * `prisma.projectResUser`: Exposes CRUD operations for the **ProjectResUser** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProjectResUsers
    * const projectResUsers = await prisma.projectResUser.findMany()
    * ```
    */
  get projectResUser(): Prisma.ProjectResUserDelegate<ExtArgs>;

  /**
   * `prisma.companyHour`: Exposes CRUD operations for the **CompanyHour** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CompanyHours
    * const companyHours = await prisma.companyHour.findMany()
    * ```
    */
  get companyHour(): Prisma.CompanyHourDelegate<ExtArgs>;

  /**
   * `prisma.stock`: Exposes CRUD operations for the **Stock** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Stocks
    * const stocks = await prisma.stock.findMany()
    * ```
    */
  get stock(): Prisma.StockDelegate<ExtArgs>;

  /**
   * `prisma.reasonStockNG`: Exposes CRUD operations for the **ReasonStockNG** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ReasonStockNGS
    * const reasonStockNGS = await prisma.reasonStockNG.findMany()
    * ```
    */
  get reasonStockNG(): Prisma.ReasonStockNGDelegate<ExtArgs>;

  /**
   * `prisma.reasonTypeNG`: Exposes CRUD operations for the **ReasonTypeNG** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ReasonTypeNGS
    * const reasonTypeNGS = await prisma.reasonTypeNG.findMany()
    * ```
    */
  get reasonTypeNG(): Prisma.ReasonTypeNGDelegate<ExtArgs>;

  /**
   * `prisma.reasonDetail`: Exposes CRUD operations for the **ReasonDetail** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ReasonDetails
    * const reasonDetails = await prisma.reasonDetail.findMany()
    * ```
    */
  get reasonDetail(): Prisma.ReasonDetailDelegate<ExtArgs>;

  /**
   * `prisma.report`: Exposes CRUD operations for the **Report** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Reports
    * const reports = await prisma.report.findMany()
    * ```
    */
  get report(): Prisma.ReportDelegate<ExtArgs>;

  /**
   * `prisma.reportProcess`: Exposes CRUD operations for the **ReportProcess** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ReportProcesses
    * const reportProcesses = await prisma.reportProcess.findMany()
    * ```
    */
  get reportProcess(): Prisma.ReportProcessDelegate<ExtArgs>;

  /**
   * `prisma.reportStock`: Exposes CRUD operations for the **ReportStock** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ReportStocks
    * const reportStocks = await prisma.reportStock.findMany()
    * ```
    */
  get reportStock(): Prisma.ReportStockDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.22.0
   * Query Engine version: 605197351a3c8bdd595af2d2a9bc3025bca48ea2
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    Company: 'Company',
    CompanyBranch: 'CompanyBranch',
    Department: 'Department',
    Course: 'Course',
    UserCourseCompletion: 'UserCourseCompletion',
    courseType: 'courseType',
    Enrollment: 'Enrollment',
    Exam: 'Exam',
    Question: 'Question',
    Choice: 'Choice',
    ExamAttempt: 'ExamAttempt',
    UserAnswer: 'UserAnswer',
    OplDocument: 'OplDocument',
    File: 'File',
    Process: 'Process',
    ProcessDetail: 'ProcessDetail',
    ProcessBranch: 'ProcessBranch',
    ProcessMat: 'ProcessMat',
    ProcessBom: 'ProcessBom',
    Project: 'Project',
    ProjectDetail: 'ProjectDetail',
    ProjectBranch: 'ProjectBranch',
    ProjectMat: 'ProjectMat',
    ProjectBom: 'ProjectBom',
    ProjectResUser: 'ProjectResUser',
    CompanyHour: 'CompanyHour',
    Stock: 'Stock',
    ReasonStockNG: 'ReasonStockNG',
    ReasonTypeNG: 'ReasonTypeNG',
    ReasonDetail: 'ReasonDetail',
    Report: 'Report',
    ReportProcess: 'ReportProcess',
    ReportStock: 'ReportStock'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "user" | "company" | "companyBranch" | "department" | "course" | "userCourseCompletion" | "courseType" | "enrollment" | "exam" | "question" | "choice" | "examAttempt" | "userAnswer" | "oplDocument" | "file" | "process" | "processDetail" | "processBranch" | "processMat" | "processBom" | "project" | "projectDetail" | "projectBranch" | "projectMat" | "projectBom" | "projectResUser" | "companyHour" | "stock" | "reasonStockNG" | "reasonTypeNG" | "reasonDetail" | "report" | "reportProcess" | "reportStock"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Company: {
        payload: Prisma.$CompanyPayload<ExtArgs>
        fields: Prisma.CompanyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CompanyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CompanyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>
          }
          findFirst: {
            args: Prisma.CompanyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CompanyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>
          }
          findMany: {
            args: Prisma.CompanyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>[]
          }
          create: {
            args: Prisma.CompanyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>
          }
          createMany: {
            args: Prisma.CompanyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.CompanyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>
          }
          update: {
            args: Prisma.CompanyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>
          }
          deleteMany: {
            args: Prisma.CompanyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CompanyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CompanyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>
          }
          aggregate: {
            args: Prisma.CompanyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCompany>
          }
          groupBy: {
            args: Prisma.CompanyGroupByArgs<ExtArgs>
            result: $Utils.Optional<CompanyGroupByOutputType>[]
          }
          count: {
            args: Prisma.CompanyCountArgs<ExtArgs>
            result: $Utils.Optional<CompanyCountAggregateOutputType> | number
          }
        }
      }
      CompanyBranch: {
        payload: Prisma.$CompanyBranchPayload<ExtArgs>
        fields: Prisma.CompanyBranchFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CompanyBranchFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyBranchPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CompanyBranchFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyBranchPayload>
          }
          findFirst: {
            args: Prisma.CompanyBranchFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyBranchPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CompanyBranchFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyBranchPayload>
          }
          findMany: {
            args: Prisma.CompanyBranchFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyBranchPayload>[]
          }
          create: {
            args: Prisma.CompanyBranchCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyBranchPayload>
          }
          createMany: {
            args: Prisma.CompanyBranchCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.CompanyBranchDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyBranchPayload>
          }
          update: {
            args: Prisma.CompanyBranchUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyBranchPayload>
          }
          deleteMany: {
            args: Prisma.CompanyBranchDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CompanyBranchUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CompanyBranchUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyBranchPayload>
          }
          aggregate: {
            args: Prisma.CompanyBranchAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCompanyBranch>
          }
          groupBy: {
            args: Prisma.CompanyBranchGroupByArgs<ExtArgs>
            result: $Utils.Optional<CompanyBranchGroupByOutputType>[]
          }
          count: {
            args: Prisma.CompanyBranchCountArgs<ExtArgs>
            result: $Utils.Optional<CompanyBranchCountAggregateOutputType> | number
          }
        }
      }
      Department: {
        payload: Prisma.$DepartmentPayload<ExtArgs>
        fields: Prisma.DepartmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DepartmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DepartmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload>
          }
          findFirst: {
            args: Prisma.DepartmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DepartmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload>
          }
          findMany: {
            args: Prisma.DepartmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload>[]
          }
          create: {
            args: Prisma.DepartmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload>
          }
          createMany: {
            args: Prisma.DepartmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.DepartmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload>
          }
          update: {
            args: Prisma.DepartmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload>
          }
          deleteMany: {
            args: Prisma.DepartmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DepartmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DepartmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload>
          }
          aggregate: {
            args: Prisma.DepartmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDepartment>
          }
          groupBy: {
            args: Prisma.DepartmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<DepartmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.DepartmentCountArgs<ExtArgs>
            result: $Utils.Optional<DepartmentCountAggregateOutputType> | number
          }
        }
      }
      Course: {
        payload: Prisma.$CoursePayload<ExtArgs>
        fields: Prisma.CourseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CourseFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CourseFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload>
          }
          findFirst: {
            args: Prisma.CourseFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CourseFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload>
          }
          findMany: {
            args: Prisma.CourseFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload>[]
          }
          create: {
            args: Prisma.CourseCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload>
          }
          createMany: {
            args: Prisma.CourseCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.CourseDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload>
          }
          update: {
            args: Prisma.CourseUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload>
          }
          deleteMany: {
            args: Prisma.CourseDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CourseUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CourseUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload>
          }
          aggregate: {
            args: Prisma.CourseAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCourse>
          }
          groupBy: {
            args: Prisma.CourseGroupByArgs<ExtArgs>
            result: $Utils.Optional<CourseGroupByOutputType>[]
          }
          count: {
            args: Prisma.CourseCountArgs<ExtArgs>
            result: $Utils.Optional<CourseCountAggregateOutputType> | number
          }
        }
      }
      UserCourseCompletion: {
        payload: Prisma.$UserCourseCompletionPayload<ExtArgs>
        fields: Prisma.UserCourseCompletionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserCourseCompletionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserCourseCompletionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserCourseCompletionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserCourseCompletionPayload>
          }
          findFirst: {
            args: Prisma.UserCourseCompletionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserCourseCompletionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserCourseCompletionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserCourseCompletionPayload>
          }
          findMany: {
            args: Prisma.UserCourseCompletionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserCourseCompletionPayload>[]
          }
          create: {
            args: Prisma.UserCourseCompletionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserCourseCompletionPayload>
          }
          createMany: {
            args: Prisma.UserCourseCompletionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.UserCourseCompletionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserCourseCompletionPayload>
          }
          update: {
            args: Prisma.UserCourseCompletionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserCourseCompletionPayload>
          }
          deleteMany: {
            args: Prisma.UserCourseCompletionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserCourseCompletionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserCourseCompletionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserCourseCompletionPayload>
          }
          aggregate: {
            args: Prisma.UserCourseCompletionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserCourseCompletion>
          }
          groupBy: {
            args: Prisma.UserCourseCompletionGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserCourseCompletionGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCourseCompletionCountArgs<ExtArgs>
            result: $Utils.Optional<UserCourseCompletionCountAggregateOutputType> | number
          }
        }
      }
      courseType: {
        payload: Prisma.$courseTypePayload<ExtArgs>
        fields: Prisma.courseTypeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.courseTypeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$courseTypePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.courseTypeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$courseTypePayload>
          }
          findFirst: {
            args: Prisma.courseTypeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$courseTypePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.courseTypeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$courseTypePayload>
          }
          findMany: {
            args: Prisma.courseTypeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$courseTypePayload>[]
          }
          create: {
            args: Prisma.courseTypeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$courseTypePayload>
          }
          createMany: {
            args: Prisma.courseTypeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.courseTypeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$courseTypePayload>
          }
          update: {
            args: Prisma.courseTypeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$courseTypePayload>
          }
          deleteMany: {
            args: Prisma.courseTypeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.courseTypeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.courseTypeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$courseTypePayload>
          }
          aggregate: {
            args: Prisma.CourseTypeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCourseType>
          }
          groupBy: {
            args: Prisma.courseTypeGroupByArgs<ExtArgs>
            result: $Utils.Optional<CourseTypeGroupByOutputType>[]
          }
          count: {
            args: Prisma.courseTypeCountArgs<ExtArgs>
            result: $Utils.Optional<CourseTypeCountAggregateOutputType> | number
          }
        }
      }
      Enrollment: {
        payload: Prisma.$EnrollmentPayload<ExtArgs>
        fields: Prisma.EnrollmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EnrollmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnrollmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EnrollmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnrollmentPayload>
          }
          findFirst: {
            args: Prisma.EnrollmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnrollmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EnrollmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnrollmentPayload>
          }
          findMany: {
            args: Prisma.EnrollmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnrollmentPayload>[]
          }
          create: {
            args: Prisma.EnrollmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnrollmentPayload>
          }
          createMany: {
            args: Prisma.EnrollmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.EnrollmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnrollmentPayload>
          }
          update: {
            args: Prisma.EnrollmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnrollmentPayload>
          }
          deleteMany: {
            args: Prisma.EnrollmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EnrollmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.EnrollmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnrollmentPayload>
          }
          aggregate: {
            args: Prisma.EnrollmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEnrollment>
          }
          groupBy: {
            args: Prisma.EnrollmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<EnrollmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.EnrollmentCountArgs<ExtArgs>
            result: $Utils.Optional<EnrollmentCountAggregateOutputType> | number
          }
        }
      }
      Exam: {
        payload: Prisma.$ExamPayload<ExtArgs>
        fields: Prisma.ExamFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ExamFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ExamFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamPayload>
          }
          findFirst: {
            args: Prisma.ExamFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ExamFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamPayload>
          }
          findMany: {
            args: Prisma.ExamFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamPayload>[]
          }
          create: {
            args: Prisma.ExamCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamPayload>
          }
          createMany: {
            args: Prisma.ExamCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ExamDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamPayload>
          }
          update: {
            args: Prisma.ExamUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamPayload>
          }
          deleteMany: {
            args: Prisma.ExamDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ExamUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ExamUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamPayload>
          }
          aggregate: {
            args: Prisma.ExamAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateExam>
          }
          groupBy: {
            args: Prisma.ExamGroupByArgs<ExtArgs>
            result: $Utils.Optional<ExamGroupByOutputType>[]
          }
          count: {
            args: Prisma.ExamCountArgs<ExtArgs>
            result: $Utils.Optional<ExamCountAggregateOutputType> | number
          }
        }
      }
      Question: {
        payload: Prisma.$QuestionPayload<ExtArgs>
        fields: Prisma.QuestionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.QuestionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.QuestionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionPayload>
          }
          findFirst: {
            args: Prisma.QuestionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.QuestionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionPayload>
          }
          findMany: {
            args: Prisma.QuestionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionPayload>[]
          }
          create: {
            args: Prisma.QuestionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionPayload>
          }
          createMany: {
            args: Prisma.QuestionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.QuestionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionPayload>
          }
          update: {
            args: Prisma.QuestionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionPayload>
          }
          deleteMany: {
            args: Prisma.QuestionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.QuestionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.QuestionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionPayload>
          }
          aggregate: {
            args: Prisma.QuestionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateQuestion>
          }
          groupBy: {
            args: Prisma.QuestionGroupByArgs<ExtArgs>
            result: $Utils.Optional<QuestionGroupByOutputType>[]
          }
          count: {
            args: Prisma.QuestionCountArgs<ExtArgs>
            result: $Utils.Optional<QuestionCountAggregateOutputType> | number
          }
        }
      }
      Choice: {
        payload: Prisma.$ChoicePayload<ExtArgs>
        fields: Prisma.ChoiceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ChoiceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChoicePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ChoiceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChoicePayload>
          }
          findFirst: {
            args: Prisma.ChoiceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChoicePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ChoiceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChoicePayload>
          }
          findMany: {
            args: Prisma.ChoiceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChoicePayload>[]
          }
          create: {
            args: Prisma.ChoiceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChoicePayload>
          }
          createMany: {
            args: Prisma.ChoiceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ChoiceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChoicePayload>
          }
          update: {
            args: Prisma.ChoiceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChoicePayload>
          }
          deleteMany: {
            args: Prisma.ChoiceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ChoiceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ChoiceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChoicePayload>
          }
          aggregate: {
            args: Prisma.ChoiceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateChoice>
          }
          groupBy: {
            args: Prisma.ChoiceGroupByArgs<ExtArgs>
            result: $Utils.Optional<ChoiceGroupByOutputType>[]
          }
          count: {
            args: Prisma.ChoiceCountArgs<ExtArgs>
            result: $Utils.Optional<ChoiceCountAggregateOutputType> | number
          }
        }
      }
      ExamAttempt: {
        payload: Prisma.$ExamAttemptPayload<ExtArgs>
        fields: Prisma.ExamAttemptFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ExamAttemptFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamAttemptPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ExamAttemptFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamAttemptPayload>
          }
          findFirst: {
            args: Prisma.ExamAttemptFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamAttemptPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ExamAttemptFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamAttemptPayload>
          }
          findMany: {
            args: Prisma.ExamAttemptFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamAttemptPayload>[]
          }
          create: {
            args: Prisma.ExamAttemptCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamAttemptPayload>
          }
          createMany: {
            args: Prisma.ExamAttemptCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ExamAttemptDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamAttemptPayload>
          }
          update: {
            args: Prisma.ExamAttemptUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamAttemptPayload>
          }
          deleteMany: {
            args: Prisma.ExamAttemptDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ExamAttemptUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ExamAttemptUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamAttemptPayload>
          }
          aggregate: {
            args: Prisma.ExamAttemptAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateExamAttempt>
          }
          groupBy: {
            args: Prisma.ExamAttemptGroupByArgs<ExtArgs>
            result: $Utils.Optional<ExamAttemptGroupByOutputType>[]
          }
          count: {
            args: Prisma.ExamAttemptCountArgs<ExtArgs>
            result: $Utils.Optional<ExamAttemptCountAggregateOutputType> | number
          }
        }
      }
      UserAnswer: {
        payload: Prisma.$UserAnswerPayload<ExtArgs>
        fields: Prisma.UserAnswerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserAnswerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAnswerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserAnswerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAnswerPayload>
          }
          findFirst: {
            args: Prisma.UserAnswerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAnswerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserAnswerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAnswerPayload>
          }
          findMany: {
            args: Prisma.UserAnswerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAnswerPayload>[]
          }
          create: {
            args: Prisma.UserAnswerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAnswerPayload>
          }
          createMany: {
            args: Prisma.UserAnswerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.UserAnswerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAnswerPayload>
          }
          update: {
            args: Prisma.UserAnswerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAnswerPayload>
          }
          deleteMany: {
            args: Prisma.UserAnswerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserAnswerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserAnswerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAnswerPayload>
          }
          aggregate: {
            args: Prisma.UserAnswerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserAnswer>
          }
          groupBy: {
            args: Prisma.UserAnswerGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserAnswerGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserAnswerCountArgs<ExtArgs>
            result: $Utils.Optional<UserAnswerCountAggregateOutputType> | number
          }
        }
      }
      OplDocument: {
        payload: Prisma.$OplDocumentPayload<ExtArgs>
        fields: Prisma.OplDocumentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OplDocumentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OplDocumentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OplDocumentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OplDocumentPayload>
          }
          findFirst: {
            args: Prisma.OplDocumentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OplDocumentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OplDocumentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OplDocumentPayload>
          }
          findMany: {
            args: Prisma.OplDocumentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OplDocumentPayload>[]
          }
          create: {
            args: Prisma.OplDocumentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OplDocumentPayload>
          }
          createMany: {
            args: Prisma.OplDocumentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.OplDocumentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OplDocumentPayload>
          }
          update: {
            args: Prisma.OplDocumentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OplDocumentPayload>
          }
          deleteMany: {
            args: Prisma.OplDocumentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OplDocumentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.OplDocumentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OplDocumentPayload>
          }
          aggregate: {
            args: Prisma.OplDocumentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOplDocument>
          }
          groupBy: {
            args: Prisma.OplDocumentGroupByArgs<ExtArgs>
            result: $Utils.Optional<OplDocumentGroupByOutputType>[]
          }
          count: {
            args: Prisma.OplDocumentCountArgs<ExtArgs>
            result: $Utils.Optional<OplDocumentCountAggregateOutputType> | number
          }
        }
      }
      File: {
        payload: Prisma.$FilePayload<ExtArgs>
        fields: Prisma.FileFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FileFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FileFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilePayload>
          }
          findFirst: {
            args: Prisma.FileFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FileFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilePayload>
          }
          findMany: {
            args: Prisma.FileFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilePayload>[]
          }
          create: {
            args: Prisma.FileCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilePayload>
          }
          createMany: {
            args: Prisma.FileCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.FileDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilePayload>
          }
          update: {
            args: Prisma.FileUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilePayload>
          }
          deleteMany: {
            args: Prisma.FileDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FileUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.FileUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilePayload>
          }
          aggregate: {
            args: Prisma.FileAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFile>
          }
          groupBy: {
            args: Prisma.FileGroupByArgs<ExtArgs>
            result: $Utils.Optional<FileGroupByOutputType>[]
          }
          count: {
            args: Prisma.FileCountArgs<ExtArgs>
            result: $Utils.Optional<FileCountAggregateOutputType> | number
          }
        }
      }
      Process: {
        payload: Prisma.$ProcessPayload<ExtArgs>
        fields: Prisma.ProcessFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProcessFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcessPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProcessFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcessPayload>
          }
          findFirst: {
            args: Prisma.ProcessFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcessPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProcessFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcessPayload>
          }
          findMany: {
            args: Prisma.ProcessFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcessPayload>[]
          }
          create: {
            args: Prisma.ProcessCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcessPayload>
          }
          createMany: {
            args: Prisma.ProcessCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ProcessDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcessPayload>
          }
          update: {
            args: Prisma.ProcessUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcessPayload>
          }
          deleteMany: {
            args: Prisma.ProcessDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProcessUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ProcessUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcessPayload>
          }
          aggregate: {
            args: Prisma.ProcessAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProcess>
          }
          groupBy: {
            args: Prisma.ProcessGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProcessGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProcessCountArgs<ExtArgs>
            result: $Utils.Optional<ProcessCountAggregateOutputType> | number
          }
        }
      }
      ProcessDetail: {
        payload: Prisma.$ProcessDetailPayload<ExtArgs>
        fields: Prisma.ProcessDetailFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProcessDetailFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcessDetailPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProcessDetailFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcessDetailPayload>
          }
          findFirst: {
            args: Prisma.ProcessDetailFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcessDetailPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProcessDetailFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcessDetailPayload>
          }
          findMany: {
            args: Prisma.ProcessDetailFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcessDetailPayload>[]
          }
          create: {
            args: Prisma.ProcessDetailCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcessDetailPayload>
          }
          createMany: {
            args: Prisma.ProcessDetailCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ProcessDetailDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcessDetailPayload>
          }
          update: {
            args: Prisma.ProcessDetailUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcessDetailPayload>
          }
          deleteMany: {
            args: Prisma.ProcessDetailDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProcessDetailUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ProcessDetailUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcessDetailPayload>
          }
          aggregate: {
            args: Prisma.ProcessDetailAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProcessDetail>
          }
          groupBy: {
            args: Prisma.ProcessDetailGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProcessDetailGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProcessDetailCountArgs<ExtArgs>
            result: $Utils.Optional<ProcessDetailCountAggregateOutputType> | number
          }
        }
      }
      ProcessBranch: {
        payload: Prisma.$ProcessBranchPayload<ExtArgs>
        fields: Prisma.ProcessBranchFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProcessBranchFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcessBranchPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProcessBranchFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcessBranchPayload>
          }
          findFirst: {
            args: Prisma.ProcessBranchFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcessBranchPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProcessBranchFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcessBranchPayload>
          }
          findMany: {
            args: Prisma.ProcessBranchFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcessBranchPayload>[]
          }
          create: {
            args: Prisma.ProcessBranchCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcessBranchPayload>
          }
          createMany: {
            args: Prisma.ProcessBranchCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ProcessBranchDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcessBranchPayload>
          }
          update: {
            args: Prisma.ProcessBranchUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcessBranchPayload>
          }
          deleteMany: {
            args: Prisma.ProcessBranchDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProcessBranchUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ProcessBranchUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcessBranchPayload>
          }
          aggregate: {
            args: Prisma.ProcessBranchAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProcessBranch>
          }
          groupBy: {
            args: Prisma.ProcessBranchGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProcessBranchGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProcessBranchCountArgs<ExtArgs>
            result: $Utils.Optional<ProcessBranchCountAggregateOutputType> | number
          }
        }
      }
      ProcessMat: {
        payload: Prisma.$ProcessMatPayload<ExtArgs>
        fields: Prisma.ProcessMatFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProcessMatFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcessMatPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProcessMatFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcessMatPayload>
          }
          findFirst: {
            args: Prisma.ProcessMatFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcessMatPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProcessMatFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcessMatPayload>
          }
          findMany: {
            args: Prisma.ProcessMatFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcessMatPayload>[]
          }
          create: {
            args: Prisma.ProcessMatCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcessMatPayload>
          }
          createMany: {
            args: Prisma.ProcessMatCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ProcessMatDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcessMatPayload>
          }
          update: {
            args: Prisma.ProcessMatUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcessMatPayload>
          }
          deleteMany: {
            args: Prisma.ProcessMatDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProcessMatUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ProcessMatUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcessMatPayload>
          }
          aggregate: {
            args: Prisma.ProcessMatAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProcessMat>
          }
          groupBy: {
            args: Prisma.ProcessMatGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProcessMatGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProcessMatCountArgs<ExtArgs>
            result: $Utils.Optional<ProcessMatCountAggregateOutputType> | number
          }
        }
      }
      ProcessBom: {
        payload: Prisma.$ProcessBomPayload<ExtArgs>
        fields: Prisma.ProcessBomFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProcessBomFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcessBomPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProcessBomFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcessBomPayload>
          }
          findFirst: {
            args: Prisma.ProcessBomFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcessBomPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProcessBomFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcessBomPayload>
          }
          findMany: {
            args: Prisma.ProcessBomFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcessBomPayload>[]
          }
          create: {
            args: Prisma.ProcessBomCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcessBomPayload>
          }
          createMany: {
            args: Prisma.ProcessBomCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ProcessBomDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcessBomPayload>
          }
          update: {
            args: Prisma.ProcessBomUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcessBomPayload>
          }
          deleteMany: {
            args: Prisma.ProcessBomDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProcessBomUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ProcessBomUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcessBomPayload>
          }
          aggregate: {
            args: Prisma.ProcessBomAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProcessBom>
          }
          groupBy: {
            args: Prisma.ProcessBomGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProcessBomGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProcessBomCountArgs<ExtArgs>
            result: $Utils.Optional<ProcessBomCountAggregateOutputType> | number
          }
        }
      }
      Project: {
        payload: Prisma.$ProjectPayload<ExtArgs>
        fields: Prisma.ProjectFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProjectFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProjectFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          findFirst: {
            args: Prisma.ProjectFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProjectFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          findMany: {
            args: Prisma.ProjectFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>[]
          }
          create: {
            args: Prisma.ProjectCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          createMany: {
            args: Prisma.ProjectCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ProjectDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          update: {
            args: Prisma.ProjectUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          deleteMany: {
            args: Prisma.ProjectDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProjectUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ProjectUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          aggregate: {
            args: Prisma.ProjectAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProject>
          }
          groupBy: {
            args: Prisma.ProjectGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProjectGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProjectCountArgs<ExtArgs>
            result: $Utils.Optional<ProjectCountAggregateOutputType> | number
          }
        }
      }
      ProjectDetail: {
        payload: Prisma.$ProjectDetailPayload<ExtArgs>
        fields: Prisma.ProjectDetailFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProjectDetailFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectDetailPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProjectDetailFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectDetailPayload>
          }
          findFirst: {
            args: Prisma.ProjectDetailFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectDetailPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProjectDetailFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectDetailPayload>
          }
          findMany: {
            args: Prisma.ProjectDetailFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectDetailPayload>[]
          }
          create: {
            args: Prisma.ProjectDetailCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectDetailPayload>
          }
          createMany: {
            args: Prisma.ProjectDetailCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ProjectDetailDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectDetailPayload>
          }
          update: {
            args: Prisma.ProjectDetailUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectDetailPayload>
          }
          deleteMany: {
            args: Prisma.ProjectDetailDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProjectDetailUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ProjectDetailUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectDetailPayload>
          }
          aggregate: {
            args: Prisma.ProjectDetailAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProjectDetail>
          }
          groupBy: {
            args: Prisma.ProjectDetailGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProjectDetailGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProjectDetailCountArgs<ExtArgs>
            result: $Utils.Optional<ProjectDetailCountAggregateOutputType> | number
          }
        }
      }
      ProjectBranch: {
        payload: Prisma.$ProjectBranchPayload<ExtArgs>
        fields: Prisma.ProjectBranchFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProjectBranchFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectBranchPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProjectBranchFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectBranchPayload>
          }
          findFirst: {
            args: Prisma.ProjectBranchFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectBranchPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProjectBranchFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectBranchPayload>
          }
          findMany: {
            args: Prisma.ProjectBranchFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectBranchPayload>[]
          }
          create: {
            args: Prisma.ProjectBranchCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectBranchPayload>
          }
          createMany: {
            args: Prisma.ProjectBranchCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ProjectBranchDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectBranchPayload>
          }
          update: {
            args: Prisma.ProjectBranchUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectBranchPayload>
          }
          deleteMany: {
            args: Prisma.ProjectBranchDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProjectBranchUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ProjectBranchUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectBranchPayload>
          }
          aggregate: {
            args: Prisma.ProjectBranchAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProjectBranch>
          }
          groupBy: {
            args: Prisma.ProjectBranchGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProjectBranchGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProjectBranchCountArgs<ExtArgs>
            result: $Utils.Optional<ProjectBranchCountAggregateOutputType> | number
          }
        }
      }
      ProjectMat: {
        payload: Prisma.$ProjectMatPayload<ExtArgs>
        fields: Prisma.ProjectMatFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProjectMatFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectMatPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProjectMatFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectMatPayload>
          }
          findFirst: {
            args: Prisma.ProjectMatFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectMatPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProjectMatFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectMatPayload>
          }
          findMany: {
            args: Prisma.ProjectMatFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectMatPayload>[]
          }
          create: {
            args: Prisma.ProjectMatCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectMatPayload>
          }
          createMany: {
            args: Prisma.ProjectMatCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ProjectMatDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectMatPayload>
          }
          update: {
            args: Prisma.ProjectMatUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectMatPayload>
          }
          deleteMany: {
            args: Prisma.ProjectMatDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProjectMatUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ProjectMatUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectMatPayload>
          }
          aggregate: {
            args: Prisma.ProjectMatAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProjectMat>
          }
          groupBy: {
            args: Prisma.ProjectMatGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProjectMatGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProjectMatCountArgs<ExtArgs>
            result: $Utils.Optional<ProjectMatCountAggregateOutputType> | number
          }
        }
      }
      ProjectBom: {
        payload: Prisma.$ProjectBomPayload<ExtArgs>
        fields: Prisma.ProjectBomFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProjectBomFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectBomPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProjectBomFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectBomPayload>
          }
          findFirst: {
            args: Prisma.ProjectBomFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectBomPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProjectBomFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectBomPayload>
          }
          findMany: {
            args: Prisma.ProjectBomFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectBomPayload>[]
          }
          create: {
            args: Prisma.ProjectBomCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectBomPayload>
          }
          createMany: {
            args: Prisma.ProjectBomCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ProjectBomDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectBomPayload>
          }
          update: {
            args: Prisma.ProjectBomUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectBomPayload>
          }
          deleteMany: {
            args: Prisma.ProjectBomDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProjectBomUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ProjectBomUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectBomPayload>
          }
          aggregate: {
            args: Prisma.ProjectBomAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProjectBom>
          }
          groupBy: {
            args: Prisma.ProjectBomGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProjectBomGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProjectBomCountArgs<ExtArgs>
            result: $Utils.Optional<ProjectBomCountAggregateOutputType> | number
          }
        }
      }
      ProjectResUser: {
        payload: Prisma.$ProjectResUserPayload<ExtArgs>
        fields: Prisma.ProjectResUserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProjectResUserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectResUserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProjectResUserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectResUserPayload>
          }
          findFirst: {
            args: Prisma.ProjectResUserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectResUserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProjectResUserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectResUserPayload>
          }
          findMany: {
            args: Prisma.ProjectResUserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectResUserPayload>[]
          }
          create: {
            args: Prisma.ProjectResUserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectResUserPayload>
          }
          createMany: {
            args: Prisma.ProjectResUserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ProjectResUserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectResUserPayload>
          }
          update: {
            args: Prisma.ProjectResUserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectResUserPayload>
          }
          deleteMany: {
            args: Prisma.ProjectResUserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProjectResUserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ProjectResUserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectResUserPayload>
          }
          aggregate: {
            args: Prisma.ProjectResUserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProjectResUser>
          }
          groupBy: {
            args: Prisma.ProjectResUserGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProjectResUserGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProjectResUserCountArgs<ExtArgs>
            result: $Utils.Optional<ProjectResUserCountAggregateOutputType> | number
          }
        }
      }
      CompanyHour: {
        payload: Prisma.$CompanyHourPayload<ExtArgs>
        fields: Prisma.CompanyHourFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CompanyHourFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyHourPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CompanyHourFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyHourPayload>
          }
          findFirst: {
            args: Prisma.CompanyHourFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyHourPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CompanyHourFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyHourPayload>
          }
          findMany: {
            args: Prisma.CompanyHourFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyHourPayload>[]
          }
          create: {
            args: Prisma.CompanyHourCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyHourPayload>
          }
          createMany: {
            args: Prisma.CompanyHourCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.CompanyHourDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyHourPayload>
          }
          update: {
            args: Prisma.CompanyHourUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyHourPayload>
          }
          deleteMany: {
            args: Prisma.CompanyHourDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CompanyHourUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CompanyHourUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyHourPayload>
          }
          aggregate: {
            args: Prisma.CompanyHourAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCompanyHour>
          }
          groupBy: {
            args: Prisma.CompanyHourGroupByArgs<ExtArgs>
            result: $Utils.Optional<CompanyHourGroupByOutputType>[]
          }
          count: {
            args: Prisma.CompanyHourCountArgs<ExtArgs>
            result: $Utils.Optional<CompanyHourCountAggregateOutputType> | number
          }
        }
      }
      Stock: {
        payload: Prisma.$StockPayload<ExtArgs>
        fields: Prisma.StockFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StockFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StockFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockPayload>
          }
          findFirst: {
            args: Prisma.StockFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StockFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockPayload>
          }
          findMany: {
            args: Prisma.StockFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockPayload>[]
          }
          create: {
            args: Prisma.StockCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockPayload>
          }
          createMany: {
            args: Prisma.StockCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.StockDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockPayload>
          }
          update: {
            args: Prisma.StockUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockPayload>
          }
          deleteMany: {
            args: Prisma.StockDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StockUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.StockUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockPayload>
          }
          aggregate: {
            args: Prisma.StockAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStock>
          }
          groupBy: {
            args: Prisma.StockGroupByArgs<ExtArgs>
            result: $Utils.Optional<StockGroupByOutputType>[]
          }
          count: {
            args: Prisma.StockCountArgs<ExtArgs>
            result: $Utils.Optional<StockCountAggregateOutputType> | number
          }
        }
      }
      ReasonStockNG: {
        payload: Prisma.$ReasonStockNGPayload<ExtArgs>
        fields: Prisma.ReasonStockNGFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ReasonStockNGFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReasonStockNGPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ReasonStockNGFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReasonStockNGPayload>
          }
          findFirst: {
            args: Prisma.ReasonStockNGFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReasonStockNGPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ReasonStockNGFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReasonStockNGPayload>
          }
          findMany: {
            args: Prisma.ReasonStockNGFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReasonStockNGPayload>[]
          }
          create: {
            args: Prisma.ReasonStockNGCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReasonStockNGPayload>
          }
          createMany: {
            args: Prisma.ReasonStockNGCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ReasonStockNGDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReasonStockNGPayload>
          }
          update: {
            args: Prisma.ReasonStockNGUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReasonStockNGPayload>
          }
          deleteMany: {
            args: Prisma.ReasonStockNGDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ReasonStockNGUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ReasonStockNGUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReasonStockNGPayload>
          }
          aggregate: {
            args: Prisma.ReasonStockNGAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReasonStockNG>
          }
          groupBy: {
            args: Prisma.ReasonStockNGGroupByArgs<ExtArgs>
            result: $Utils.Optional<ReasonStockNGGroupByOutputType>[]
          }
          count: {
            args: Prisma.ReasonStockNGCountArgs<ExtArgs>
            result: $Utils.Optional<ReasonStockNGCountAggregateOutputType> | number
          }
        }
      }
      ReasonTypeNG: {
        payload: Prisma.$ReasonTypeNGPayload<ExtArgs>
        fields: Prisma.ReasonTypeNGFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ReasonTypeNGFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReasonTypeNGPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ReasonTypeNGFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReasonTypeNGPayload>
          }
          findFirst: {
            args: Prisma.ReasonTypeNGFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReasonTypeNGPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ReasonTypeNGFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReasonTypeNGPayload>
          }
          findMany: {
            args: Prisma.ReasonTypeNGFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReasonTypeNGPayload>[]
          }
          create: {
            args: Prisma.ReasonTypeNGCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReasonTypeNGPayload>
          }
          createMany: {
            args: Prisma.ReasonTypeNGCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ReasonTypeNGDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReasonTypeNGPayload>
          }
          update: {
            args: Prisma.ReasonTypeNGUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReasonTypeNGPayload>
          }
          deleteMany: {
            args: Prisma.ReasonTypeNGDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ReasonTypeNGUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ReasonTypeNGUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReasonTypeNGPayload>
          }
          aggregate: {
            args: Prisma.ReasonTypeNGAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReasonTypeNG>
          }
          groupBy: {
            args: Prisma.ReasonTypeNGGroupByArgs<ExtArgs>
            result: $Utils.Optional<ReasonTypeNGGroupByOutputType>[]
          }
          count: {
            args: Prisma.ReasonTypeNGCountArgs<ExtArgs>
            result: $Utils.Optional<ReasonTypeNGCountAggregateOutputType> | number
          }
        }
      }
      ReasonDetail: {
        payload: Prisma.$ReasonDetailPayload<ExtArgs>
        fields: Prisma.ReasonDetailFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ReasonDetailFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReasonDetailPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ReasonDetailFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReasonDetailPayload>
          }
          findFirst: {
            args: Prisma.ReasonDetailFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReasonDetailPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ReasonDetailFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReasonDetailPayload>
          }
          findMany: {
            args: Prisma.ReasonDetailFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReasonDetailPayload>[]
          }
          create: {
            args: Prisma.ReasonDetailCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReasonDetailPayload>
          }
          createMany: {
            args: Prisma.ReasonDetailCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ReasonDetailDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReasonDetailPayload>
          }
          update: {
            args: Prisma.ReasonDetailUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReasonDetailPayload>
          }
          deleteMany: {
            args: Prisma.ReasonDetailDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ReasonDetailUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ReasonDetailUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReasonDetailPayload>
          }
          aggregate: {
            args: Prisma.ReasonDetailAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReasonDetail>
          }
          groupBy: {
            args: Prisma.ReasonDetailGroupByArgs<ExtArgs>
            result: $Utils.Optional<ReasonDetailGroupByOutputType>[]
          }
          count: {
            args: Prisma.ReasonDetailCountArgs<ExtArgs>
            result: $Utils.Optional<ReasonDetailCountAggregateOutputType> | number
          }
        }
      }
      Report: {
        payload: Prisma.$ReportPayload<ExtArgs>
        fields: Prisma.ReportFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ReportFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ReportFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>
          }
          findFirst: {
            args: Prisma.ReportFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ReportFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>
          }
          findMany: {
            args: Prisma.ReportFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>[]
          }
          create: {
            args: Prisma.ReportCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>
          }
          createMany: {
            args: Prisma.ReportCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ReportDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>
          }
          update: {
            args: Prisma.ReportUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>
          }
          deleteMany: {
            args: Prisma.ReportDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ReportUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ReportUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>
          }
          aggregate: {
            args: Prisma.ReportAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReport>
          }
          groupBy: {
            args: Prisma.ReportGroupByArgs<ExtArgs>
            result: $Utils.Optional<ReportGroupByOutputType>[]
          }
          count: {
            args: Prisma.ReportCountArgs<ExtArgs>
            result: $Utils.Optional<ReportCountAggregateOutputType> | number
          }
        }
      }
      ReportProcess: {
        payload: Prisma.$ReportProcessPayload<ExtArgs>
        fields: Prisma.ReportProcessFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ReportProcessFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportProcessPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ReportProcessFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportProcessPayload>
          }
          findFirst: {
            args: Prisma.ReportProcessFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportProcessPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ReportProcessFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportProcessPayload>
          }
          findMany: {
            args: Prisma.ReportProcessFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportProcessPayload>[]
          }
          create: {
            args: Prisma.ReportProcessCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportProcessPayload>
          }
          createMany: {
            args: Prisma.ReportProcessCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ReportProcessDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportProcessPayload>
          }
          update: {
            args: Prisma.ReportProcessUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportProcessPayload>
          }
          deleteMany: {
            args: Prisma.ReportProcessDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ReportProcessUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ReportProcessUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportProcessPayload>
          }
          aggregate: {
            args: Prisma.ReportProcessAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReportProcess>
          }
          groupBy: {
            args: Prisma.ReportProcessGroupByArgs<ExtArgs>
            result: $Utils.Optional<ReportProcessGroupByOutputType>[]
          }
          count: {
            args: Prisma.ReportProcessCountArgs<ExtArgs>
            result: $Utils.Optional<ReportProcessCountAggregateOutputType> | number
          }
        }
      }
      ReportStock: {
        payload: Prisma.$ReportStockPayload<ExtArgs>
        fields: Prisma.ReportStockFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ReportStockFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportStockPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ReportStockFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportStockPayload>
          }
          findFirst: {
            args: Prisma.ReportStockFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportStockPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ReportStockFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportStockPayload>
          }
          findMany: {
            args: Prisma.ReportStockFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportStockPayload>[]
          }
          create: {
            args: Prisma.ReportStockCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportStockPayload>
          }
          createMany: {
            args: Prisma.ReportStockCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ReportStockDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportStockPayload>
          }
          update: {
            args: Prisma.ReportStockUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportStockPayload>
          }
          deleteMany: {
            args: Prisma.ReportStockDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ReportStockUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ReportStockUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportStockPayload>
          }
          aggregate: {
            args: Prisma.ReportStockAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReportStock>
          }
          groupBy: {
            args: Prisma.ReportStockGroupByArgs<ExtArgs>
            result: $Utils.Optional<ReportStockGroupByOutputType>[]
          }
          count: {
            args: Prisma.ReportStockCountArgs<ExtArgs>
            result: $Utils.Optional<ReportStockCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    processes: number
    exams: number
    enrollments: number
    oplDocuments: number
    files: number
    createdCourses: number
    deletedCourses: number
    courseCompletions: number
    project: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    processes?: boolean | UserCountOutputTypeCountProcessesArgs
    exams?: boolean | UserCountOutputTypeCountExamsArgs
    enrollments?: boolean | UserCountOutputTypeCountEnrollmentsArgs
    oplDocuments?: boolean | UserCountOutputTypeCountOplDocumentsArgs
    files?: boolean | UserCountOutputTypeCountFilesArgs
    createdCourses?: boolean | UserCountOutputTypeCountCreatedCoursesArgs
    deletedCourses?: boolean | UserCountOutputTypeCountDeletedCoursesArgs
    courseCompletions?: boolean | UserCountOutputTypeCountCourseCompletionsArgs
    project?: boolean | UserCountOutputTypeCountProjectArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountProcessesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProcessWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountExamsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExamAttemptWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountEnrollmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EnrollmentWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountOplDocumentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OplDocumentWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountFilesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FileWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCreatedCoursesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CourseWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountDeletedCoursesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CourseWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCourseCompletionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserCourseCompletionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountProjectArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectWhereInput
  }


  /**
   * Count Type CompanyCountOutputType
   */

  export type CompanyCountOutputType = {
    companyBranch: number
  }

  export type CompanyCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    companyBranch?: boolean | CompanyCountOutputTypeCountCompanyBranchArgs
  }

  // Custom InputTypes
  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyCountOutputType
     */
    select?: CompanyCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountCompanyBranchArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CompanyBranchWhereInput
  }


  /**
   * Count Type DepartmentCountOutputType
   */

  export type DepartmentCountOutputType = {
    user: number
    Course: number
  }

  export type DepartmentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | DepartmentCountOutputTypeCountUserArgs
    Course?: boolean | DepartmentCountOutputTypeCountCourseArgs
  }

  // Custom InputTypes
  /**
   * DepartmentCountOutputType without action
   */
  export type DepartmentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DepartmentCountOutputType
     */
    select?: DepartmentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DepartmentCountOutputType without action
   */
  export type DepartmentCountOutputTypeCountUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }

  /**
   * DepartmentCountOutputType without action
   */
  export type DepartmentCountOutputTypeCountCourseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CourseWhereInput
  }


  /**
   * Count Type CourseCountOutputType
   */

  export type CourseCountOutputType = {
    enrollments: number
    files: number
    exams: number
    completions: number
  }

  export type CourseCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    enrollments?: boolean | CourseCountOutputTypeCountEnrollmentsArgs
    files?: boolean | CourseCountOutputTypeCountFilesArgs
    exams?: boolean | CourseCountOutputTypeCountExamsArgs
    completions?: boolean | CourseCountOutputTypeCountCompletionsArgs
  }

  // Custom InputTypes
  /**
   * CourseCountOutputType without action
   */
  export type CourseCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseCountOutputType
     */
    select?: CourseCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CourseCountOutputType without action
   */
  export type CourseCountOutputTypeCountEnrollmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EnrollmentWhereInput
  }

  /**
   * CourseCountOutputType without action
   */
  export type CourseCountOutputTypeCountFilesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FileWhereInput
  }

  /**
   * CourseCountOutputType without action
   */
  export type CourseCountOutputTypeCountExamsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExamWhereInput
  }

  /**
   * CourseCountOutputType without action
   */
  export type CourseCountOutputTypeCountCompletionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserCourseCompletionWhereInput
  }


  /**
   * Count Type ExamCountOutputType
   */

  export type ExamCountOutputType = {
    questions: number
    attempts: number
    completions: number
  }

  export type ExamCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    questions?: boolean | ExamCountOutputTypeCountQuestionsArgs
    attempts?: boolean | ExamCountOutputTypeCountAttemptsArgs
    completions?: boolean | ExamCountOutputTypeCountCompletionsArgs
  }

  // Custom InputTypes
  /**
   * ExamCountOutputType without action
   */
  export type ExamCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamCountOutputType
     */
    select?: ExamCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ExamCountOutputType without action
   */
  export type ExamCountOutputTypeCountQuestionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuestionWhereInput
  }

  /**
   * ExamCountOutputType without action
   */
  export type ExamCountOutputTypeCountAttemptsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExamAttemptWhereInput
  }

  /**
   * ExamCountOutputType without action
   */
  export type ExamCountOutputTypeCountCompletionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserCourseCompletionWhereInput
  }


  /**
   * Count Type QuestionCountOutputType
   */

  export type QuestionCountOutputType = {
    choices: number
    userAnswers: number
  }

  export type QuestionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    choices?: boolean | QuestionCountOutputTypeCountChoicesArgs
    userAnswers?: boolean | QuestionCountOutputTypeCountUserAnswersArgs
  }

  // Custom InputTypes
  /**
   * QuestionCountOutputType without action
   */
  export type QuestionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionCountOutputType
     */
    select?: QuestionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * QuestionCountOutputType without action
   */
  export type QuestionCountOutputTypeCountChoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChoiceWhereInput
  }

  /**
   * QuestionCountOutputType without action
   */
  export type QuestionCountOutputTypeCountUserAnswersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserAnswerWhereInput
  }


  /**
   * Count Type ChoiceCountOutputType
   */

  export type ChoiceCountOutputType = {
    UserAnswer: number
  }

  export type ChoiceCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    UserAnswer?: boolean | ChoiceCountOutputTypeCountUserAnswerArgs
  }

  // Custom InputTypes
  /**
   * ChoiceCountOutputType without action
   */
  export type ChoiceCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChoiceCountOutputType
     */
    select?: ChoiceCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ChoiceCountOutputType without action
   */
  export type ChoiceCountOutputTypeCountUserAnswerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserAnswerWhereInput
  }


  /**
   * Count Type ExamAttemptCountOutputType
   */

  export type ExamAttemptCountOutputType = {
    answers: number
  }

  export type ExamAttemptCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    answers?: boolean | ExamAttemptCountOutputTypeCountAnswersArgs
  }

  // Custom InputTypes
  /**
   * ExamAttemptCountOutputType without action
   */
  export type ExamAttemptCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamAttemptCountOutputType
     */
    select?: ExamAttemptCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ExamAttemptCountOutputType without action
   */
  export type ExamAttemptCountOutputTypeCountAnswersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserAnswerWhereInput
  }


  /**
   * Count Type ProcessCountOutputType
   */

  export type ProcessCountOutputType = {
    courses: number
    completions: number
    processDetail: number
  }

  export type ProcessCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    courses?: boolean | ProcessCountOutputTypeCountCoursesArgs
    completions?: boolean | ProcessCountOutputTypeCountCompletionsArgs
    processDetail?: boolean | ProcessCountOutputTypeCountProcessDetailArgs
  }

  // Custom InputTypes
  /**
   * ProcessCountOutputType without action
   */
  export type ProcessCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcessCountOutputType
     */
    select?: ProcessCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProcessCountOutputType without action
   */
  export type ProcessCountOutputTypeCountCoursesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CourseWhereInput
  }

  /**
   * ProcessCountOutputType without action
   */
  export type ProcessCountOutputTypeCountCompletionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserCourseCompletionWhereInput
  }

  /**
   * ProcessCountOutputType without action
   */
  export type ProcessCountOutputTypeCountProcessDetailArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProcessDetailWhereInput
  }


  /**
   * Count Type ProcessDetailCountOutputType
   */

  export type ProcessDetailCountOutputType = {
    processBranch: number
    processMat: number
    processBom: number
  }

  export type ProcessDetailCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    processBranch?: boolean | ProcessDetailCountOutputTypeCountProcessBranchArgs
    processMat?: boolean | ProcessDetailCountOutputTypeCountProcessMatArgs
    processBom?: boolean | ProcessDetailCountOutputTypeCountProcessBomArgs
  }

  // Custom InputTypes
  /**
   * ProcessDetailCountOutputType without action
   */
  export type ProcessDetailCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcessDetailCountOutputType
     */
    select?: ProcessDetailCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProcessDetailCountOutputType without action
   */
  export type ProcessDetailCountOutputTypeCountProcessBranchArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProcessBranchWhereInput
  }

  /**
   * ProcessDetailCountOutputType without action
   */
  export type ProcessDetailCountOutputTypeCountProcessMatArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProcessMatWhereInput
  }

  /**
   * ProcessDetailCountOutputType without action
   */
  export type ProcessDetailCountOutputTypeCountProcessBomArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProcessBomWhereInput
  }


  /**
   * Count Type ProjectCountOutputType
   */

  export type ProjectCountOutputType = {
    projectDetail: number
  }

  export type ProjectCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    projectDetail?: boolean | ProjectCountOutputTypeCountProjectDetailArgs
  }

  // Custom InputTypes
  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectCountOutputType
     */
    select?: ProjectCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountProjectDetailArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectDetailWhereInput
  }


  /**
   * Count Type ProjectDetailCountOutputType
   */

  export type ProjectDetailCountOutputType = {
    projectBranch: number
    projectMat: number
    projectBom: number
    ProjectResUser: number
  }

  export type ProjectDetailCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    projectBranch?: boolean | ProjectDetailCountOutputTypeCountProjectBranchArgs
    projectMat?: boolean | ProjectDetailCountOutputTypeCountProjectMatArgs
    projectBom?: boolean | ProjectDetailCountOutputTypeCountProjectBomArgs
    ProjectResUser?: boolean | ProjectDetailCountOutputTypeCountProjectResUserArgs
  }

  // Custom InputTypes
  /**
   * ProjectDetailCountOutputType without action
   */
  export type ProjectDetailCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectDetailCountOutputType
     */
    select?: ProjectDetailCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProjectDetailCountOutputType without action
   */
  export type ProjectDetailCountOutputTypeCountProjectBranchArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectBranchWhereInput
  }

  /**
   * ProjectDetailCountOutputType without action
   */
  export type ProjectDetailCountOutputTypeCountProjectMatArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectMatWhereInput
  }

  /**
   * ProjectDetailCountOutputType without action
   */
  export type ProjectDetailCountOutputTypeCountProjectBomArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectBomWhereInput
  }

  /**
   * ProjectDetailCountOutputType without action
   */
  export type ProjectDetailCountOutputTypeCountProjectResUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectResUserWhereInput
  }


  /**
   * Count Type StockCountOutputType
   */

  export type StockCountOutputType = {
    processMat: number
    processBom: number
    projectMat: number
    projectBom: number
  }

  export type StockCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    processMat?: boolean | StockCountOutputTypeCountProcessMatArgs
    processBom?: boolean | StockCountOutputTypeCountProcessBomArgs
    projectMat?: boolean | StockCountOutputTypeCountProjectMatArgs
    projectBom?: boolean | StockCountOutputTypeCountProjectBomArgs
  }

  // Custom InputTypes
  /**
   * StockCountOutputType without action
   */
  export type StockCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockCountOutputType
     */
    select?: StockCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * StockCountOutputType without action
   */
  export type StockCountOutputTypeCountProcessMatArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProcessMatWhereInput
  }

  /**
   * StockCountOutputType without action
   */
  export type StockCountOutputTypeCountProcessBomArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProcessBomWhereInput
  }

  /**
   * StockCountOutputType without action
   */
  export type StockCountOutputTypeCountProjectMatArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectMatWhereInput
  }

  /**
   * StockCountOutputType without action
   */
  export type StockCountOutputTypeCountProjectBomArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectBomWhereInput
  }


  /**
   * Count Type ReasonTypeNGCountOutputType
   */

  export type ReasonTypeNGCountOutputType = {
    reasondDetail: number
  }

  export type ReasonTypeNGCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    reasondDetail?: boolean | ReasonTypeNGCountOutputTypeCountReasondDetailArgs
  }

  // Custom InputTypes
  /**
   * ReasonTypeNGCountOutputType without action
   */
  export type ReasonTypeNGCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReasonTypeNGCountOutputType
     */
    select?: ReasonTypeNGCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ReasonTypeNGCountOutputType without action
   */
  export type ReasonTypeNGCountOutputTypeCountReasondDetailArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReasonDetailWhereInput
  }


  /**
   * Count Type ReportCountOutputType
   */

  export type ReportCountOutputType = {
    reportProcess: number
  }

  export type ReportCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    reportProcess?: boolean | ReportCountOutputTypeCountReportProcessArgs
  }

  // Custom InputTypes
  /**
   * ReportCountOutputType without action
   */
  export type ReportCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportCountOutputType
     */
    select?: ReportCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ReportCountOutputType without action
   */
  export type ReportCountOutputTypeCountReportProcessArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReportProcessWhereInput
  }


  /**
   * Count Type ReportProcessCountOutputType
   */

  export type ReportProcessCountOutputType = {
    reportStock: number
  }

  export type ReportProcessCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    reportStock?: boolean | ReportProcessCountOutputTypeCountReportStockArgs
  }

  // Custom InputTypes
  /**
   * ReportProcessCountOutputType without action
   */
  export type ReportProcessCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportProcessCountOutputType
     */
    select?: ReportProcessCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ReportProcessCountOutputType without action
   */
  export type ReportProcessCountOutputTypeCountReportStockArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReportStockWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    id: number | null
    companyId: number | null
    companyBranchId: number | null
    departmentId: number | null
  }

  export type UserSumAggregateOutputType = {
    id: number | null
    companyId: number | null
    companyBranchId: number | null
    departmentId: number | null
  }

  export type UserMinAggregateOutputType = {
    id: number | null
    userId: string | null
    firstName: string | null
    lastName: string | null
    password: string | null
    companyId: number | null
    companyBranchId: number | null
    departmentId: number | null
    role: string | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: number | null
    userId: string | null
    firstName: string | null
    lastName: string | null
    password: string | null
    companyId: number | null
    companyBranchId: number | null
    departmentId: number | null
    role: string | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    userId: number
    firstName: number
    lastName: number
    password: number
    companyId: number
    companyBranchId: number
    departmentId: number
    role: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    id?: true
    companyId?: true
    companyBranchId?: true
    departmentId?: true
  }

  export type UserSumAggregateInputType = {
    id?: true
    companyId?: true
    companyBranchId?: true
    departmentId?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    userId?: true
    firstName?: true
    lastName?: true
    password?: true
    companyId?: true
    companyBranchId?: true
    departmentId?: true
    role?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    userId?: true
    firstName?: true
    lastName?: true
    password?: true
    companyId?: true
    companyBranchId?: true
    departmentId?: true
    role?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    userId?: true
    firstName?: true
    lastName?: true
    password?: true
    companyId?: true
    companyBranchId?: true
    departmentId?: true
    role?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: number
    userId: string
    firstName: string
    lastName: string
    password: string
    companyId: number | null
    companyBranchId: number | null
    departmentId: number | null
    role: string
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    firstName?: boolean
    lastName?: boolean
    password?: boolean
    companyId?: boolean
    companyBranchId?: boolean
    departmentId?: boolean
    role?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    department?: boolean | User$departmentArgs<ExtArgs>
    processes?: boolean | User$processesArgs<ExtArgs>
    exams?: boolean | User$examsArgs<ExtArgs>
    enrollments?: boolean | User$enrollmentsArgs<ExtArgs>
    oplDocuments?: boolean | User$oplDocumentsArgs<ExtArgs>
    files?: boolean | User$filesArgs<ExtArgs>
    createdCourses?: boolean | User$createdCoursesArgs<ExtArgs>
    deletedCourses?: boolean | User$deletedCoursesArgs<ExtArgs>
    courseCompletions?: boolean | User$courseCompletionsArgs<ExtArgs>
    project?: boolean | User$projectArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>


  export type UserSelectScalar = {
    id?: boolean
    userId?: boolean
    firstName?: boolean
    lastName?: boolean
    password?: boolean
    companyId?: boolean
    companyBranchId?: boolean
    departmentId?: boolean
    role?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }

  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    department?: boolean | User$departmentArgs<ExtArgs>
    processes?: boolean | User$processesArgs<ExtArgs>
    exams?: boolean | User$examsArgs<ExtArgs>
    enrollments?: boolean | User$enrollmentsArgs<ExtArgs>
    oplDocuments?: boolean | User$oplDocumentsArgs<ExtArgs>
    files?: boolean | User$filesArgs<ExtArgs>
    createdCourses?: boolean | User$createdCoursesArgs<ExtArgs>
    deletedCourses?: boolean | User$deletedCoursesArgs<ExtArgs>
    courseCompletions?: boolean | User$courseCompletionsArgs<ExtArgs>
    project?: boolean | User$projectArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      department: Prisma.$DepartmentPayload<ExtArgs> | null
      processes: Prisma.$ProcessPayload<ExtArgs>[]
      exams: Prisma.$ExamAttemptPayload<ExtArgs>[]
      enrollments: Prisma.$EnrollmentPayload<ExtArgs>[]
      oplDocuments: Prisma.$OplDocumentPayload<ExtArgs>[]
      files: Prisma.$FilePayload<ExtArgs>[]
      createdCourses: Prisma.$CoursePayload<ExtArgs>[]
      deletedCourses: Prisma.$CoursePayload<ExtArgs>[]
      courseCompletions: Prisma.$UserCourseCompletionPayload<ExtArgs>[]
      project: Prisma.$ProjectPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: string
      firstName: string
      lastName: string
      password: string
      companyId: number | null
      companyBranchId: number | null
      departmentId: number | null
      role: string
      createdAt: Date
      updatedAt: Date
      deletedAt: Date | null
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    department<T extends User$departmentArgs<ExtArgs> = {}>(args?: Subset<T, User$departmentArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    processes<T extends User$processesArgs<ExtArgs> = {}>(args?: Subset<T, User$processesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProcessPayload<ExtArgs>, T, "findMany"> | Null>
    exams<T extends User$examsArgs<ExtArgs> = {}>(args?: Subset<T, User$examsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExamAttemptPayload<ExtArgs>, T, "findMany"> | Null>
    enrollments<T extends User$enrollmentsArgs<ExtArgs> = {}>(args?: Subset<T, User$enrollmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EnrollmentPayload<ExtArgs>, T, "findMany"> | Null>
    oplDocuments<T extends User$oplDocumentsArgs<ExtArgs> = {}>(args?: Subset<T, User$oplDocumentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OplDocumentPayload<ExtArgs>, T, "findMany"> | Null>
    files<T extends User$filesArgs<ExtArgs> = {}>(args?: Subset<T, User$filesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FilePayload<ExtArgs>, T, "findMany"> | Null>
    createdCourses<T extends User$createdCoursesArgs<ExtArgs> = {}>(args?: Subset<T, User$createdCoursesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findMany"> | Null>
    deletedCourses<T extends User$deletedCoursesArgs<ExtArgs> = {}>(args?: Subset<T, User$deletedCoursesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findMany"> | Null>
    courseCompletions<T extends User$courseCompletionsArgs<ExtArgs> = {}>(args?: Subset<T, User$courseCompletionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserCourseCompletionPayload<ExtArgs>, T, "findMany"> | Null>
    project<T extends User$projectArgs<ExtArgs> = {}>(args?: Subset<T, User$projectArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */ 
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'Int'>
    readonly userId: FieldRef<"User", 'String'>
    readonly firstName: FieldRef<"User", 'String'>
    readonly lastName: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly companyId: FieldRef<"User", 'Int'>
    readonly companyBranchId: FieldRef<"User", 'Int'>
    readonly departmentId: FieldRef<"User", 'Int'>
    readonly role: FieldRef<"User", 'String'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
    readonly deletedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
  }

  /**
   * User.department
   */
  export type User$departmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    where?: DepartmentWhereInput
  }

  /**
   * User.processes
   */
  export type User$processesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Process
     */
    select?: ProcessSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessInclude<ExtArgs> | null
    where?: ProcessWhereInput
    orderBy?: ProcessOrderByWithRelationInput | ProcessOrderByWithRelationInput[]
    cursor?: ProcessWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProcessScalarFieldEnum | ProcessScalarFieldEnum[]
  }

  /**
   * User.exams
   */
  export type User$examsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamAttempt
     */
    select?: ExamAttemptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamAttemptInclude<ExtArgs> | null
    where?: ExamAttemptWhereInput
    orderBy?: ExamAttemptOrderByWithRelationInput | ExamAttemptOrderByWithRelationInput[]
    cursor?: ExamAttemptWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ExamAttemptScalarFieldEnum | ExamAttemptScalarFieldEnum[]
  }

  /**
   * User.enrollments
   */
  export type User$enrollmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Enrollment
     */
    select?: EnrollmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnrollmentInclude<ExtArgs> | null
    where?: EnrollmentWhereInput
    orderBy?: EnrollmentOrderByWithRelationInput | EnrollmentOrderByWithRelationInput[]
    cursor?: EnrollmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EnrollmentScalarFieldEnum | EnrollmentScalarFieldEnum[]
  }

  /**
   * User.oplDocuments
   */
  export type User$oplDocumentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OplDocument
     */
    select?: OplDocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OplDocumentInclude<ExtArgs> | null
    where?: OplDocumentWhereInput
    orderBy?: OplDocumentOrderByWithRelationInput | OplDocumentOrderByWithRelationInput[]
    cursor?: OplDocumentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OplDocumentScalarFieldEnum | OplDocumentScalarFieldEnum[]
  }

  /**
   * User.files
   */
  export type User$filesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileInclude<ExtArgs> | null
    where?: FileWhereInput
    orderBy?: FileOrderByWithRelationInput | FileOrderByWithRelationInput[]
    cursor?: FileWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FileScalarFieldEnum | FileScalarFieldEnum[]
  }

  /**
   * User.createdCourses
   */
  export type User$createdCoursesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    where?: CourseWhereInput
    orderBy?: CourseOrderByWithRelationInput | CourseOrderByWithRelationInput[]
    cursor?: CourseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CourseScalarFieldEnum | CourseScalarFieldEnum[]
  }

  /**
   * User.deletedCourses
   */
  export type User$deletedCoursesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    where?: CourseWhereInput
    orderBy?: CourseOrderByWithRelationInput | CourseOrderByWithRelationInput[]
    cursor?: CourseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CourseScalarFieldEnum | CourseScalarFieldEnum[]
  }

  /**
   * User.courseCompletions
   */
  export type User$courseCompletionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCourseCompletion
     */
    select?: UserCourseCompletionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserCourseCompletionInclude<ExtArgs> | null
    where?: UserCourseCompletionWhereInput
    orderBy?: UserCourseCompletionOrderByWithRelationInput | UserCourseCompletionOrderByWithRelationInput[]
    cursor?: UserCourseCompletionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserCourseCompletionScalarFieldEnum | UserCourseCompletionScalarFieldEnum[]
  }

  /**
   * User.project
   */
  export type User$projectArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    where?: ProjectWhereInput
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    cursor?: ProjectWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProjectScalarFieldEnum | ProjectScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Company
   */

  export type AggregateCompany = {
    _count: CompanyCountAggregateOutputType | null
    _avg: CompanyAvgAggregateOutputType | null
    _sum: CompanySumAggregateOutputType | null
    _min: CompanyMinAggregateOutputType | null
    _max: CompanyMaxAggregateOutputType | null
  }

  export type CompanyAvgAggregateOutputType = {
    id: number | null
  }

  export type CompanySumAggregateOutputType = {
    id: number | null
  }

  export type CompanyMinAggregateOutputType = {
    id: number | null
    companyName: string | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type CompanyMaxAggregateOutputType = {
    id: number | null
    companyName: string | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type CompanyCountAggregateOutputType = {
    id: number
    companyName: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    _all: number
  }


  export type CompanyAvgAggregateInputType = {
    id?: true
  }

  export type CompanySumAggregateInputType = {
    id?: true
  }

  export type CompanyMinAggregateInputType = {
    id?: true
    companyName?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type CompanyMaxAggregateInputType = {
    id?: true
    companyName?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type CompanyCountAggregateInputType = {
    id?: true
    companyName?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    _all?: true
  }

  export type CompanyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Company to aggregate.
     */
    where?: CompanyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Companies to fetch.
     */
    orderBy?: CompanyOrderByWithRelationInput | CompanyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CompanyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Companies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Companies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Companies
    **/
    _count?: true | CompanyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CompanyAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CompanySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CompanyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CompanyMaxAggregateInputType
  }

  export type GetCompanyAggregateType<T extends CompanyAggregateArgs> = {
        [P in keyof T & keyof AggregateCompany]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCompany[P]>
      : GetScalarType<T[P], AggregateCompany[P]>
  }




  export type CompanyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CompanyWhereInput
    orderBy?: CompanyOrderByWithAggregationInput | CompanyOrderByWithAggregationInput[]
    by: CompanyScalarFieldEnum[] | CompanyScalarFieldEnum
    having?: CompanyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CompanyCountAggregateInputType | true
    _avg?: CompanyAvgAggregateInputType
    _sum?: CompanySumAggregateInputType
    _min?: CompanyMinAggregateInputType
    _max?: CompanyMaxAggregateInputType
  }

  export type CompanyGroupByOutputType = {
    id: number
    companyName: string
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
    _count: CompanyCountAggregateOutputType | null
    _avg: CompanyAvgAggregateOutputType | null
    _sum: CompanySumAggregateOutputType | null
    _min: CompanyMinAggregateOutputType | null
    _max: CompanyMaxAggregateOutputType | null
  }

  type GetCompanyGroupByPayload<T extends CompanyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CompanyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CompanyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CompanyGroupByOutputType[P]>
            : GetScalarType<T[P], CompanyGroupByOutputType[P]>
        }
      >
    >


  export type CompanySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyName?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    companyBranch?: boolean | Company$companyBranchArgs<ExtArgs>
    _count?: boolean | CompanyCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["company"]>


  export type CompanySelectScalar = {
    id?: boolean
    companyName?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }

  export type CompanyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    companyBranch?: boolean | Company$companyBranchArgs<ExtArgs>
    _count?: boolean | CompanyCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $CompanyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Company"
    objects: {
      companyBranch: Prisma.$CompanyBranchPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      companyName: string
      createdAt: Date
      updatedAt: Date
      deletedAt: Date | null
    }, ExtArgs["result"]["company"]>
    composites: {}
  }

  type CompanyGetPayload<S extends boolean | null | undefined | CompanyDefaultArgs> = $Result.GetResult<Prisma.$CompanyPayload, S>

  type CompanyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CompanyFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CompanyCountAggregateInputType | true
    }

  export interface CompanyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Company'], meta: { name: 'Company' } }
    /**
     * Find zero or one Company that matches the filter.
     * @param {CompanyFindUniqueArgs} args - Arguments to find a Company
     * @example
     * // Get one Company
     * const company = await prisma.company.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CompanyFindUniqueArgs>(args: SelectSubset<T, CompanyFindUniqueArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Company that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CompanyFindUniqueOrThrowArgs} args - Arguments to find a Company
     * @example
     * // Get one Company
     * const company = await prisma.company.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CompanyFindUniqueOrThrowArgs>(args: SelectSubset<T, CompanyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Company that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyFindFirstArgs} args - Arguments to find a Company
     * @example
     * // Get one Company
     * const company = await prisma.company.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CompanyFindFirstArgs>(args?: SelectSubset<T, CompanyFindFirstArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Company that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyFindFirstOrThrowArgs} args - Arguments to find a Company
     * @example
     * // Get one Company
     * const company = await prisma.company.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CompanyFindFirstOrThrowArgs>(args?: SelectSubset<T, CompanyFindFirstOrThrowArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Companies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Companies
     * const companies = await prisma.company.findMany()
     * 
     * // Get first 10 Companies
     * const companies = await prisma.company.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const companyWithIdOnly = await prisma.company.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CompanyFindManyArgs>(args?: SelectSubset<T, CompanyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Company.
     * @param {CompanyCreateArgs} args - Arguments to create a Company.
     * @example
     * // Create one Company
     * const Company = await prisma.company.create({
     *   data: {
     *     // ... data to create a Company
     *   }
     * })
     * 
     */
    create<T extends CompanyCreateArgs>(args: SelectSubset<T, CompanyCreateArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Companies.
     * @param {CompanyCreateManyArgs} args - Arguments to create many Companies.
     * @example
     * // Create many Companies
     * const company = await prisma.company.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CompanyCreateManyArgs>(args?: SelectSubset<T, CompanyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Company.
     * @param {CompanyDeleteArgs} args - Arguments to delete one Company.
     * @example
     * // Delete one Company
     * const Company = await prisma.company.delete({
     *   where: {
     *     // ... filter to delete one Company
     *   }
     * })
     * 
     */
    delete<T extends CompanyDeleteArgs>(args: SelectSubset<T, CompanyDeleteArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Company.
     * @param {CompanyUpdateArgs} args - Arguments to update one Company.
     * @example
     * // Update one Company
     * const company = await prisma.company.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CompanyUpdateArgs>(args: SelectSubset<T, CompanyUpdateArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Companies.
     * @param {CompanyDeleteManyArgs} args - Arguments to filter Companies to delete.
     * @example
     * // Delete a few Companies
     * const { count } = await prisma.company.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CompanyDeleteManyArgs>(args?: SelectSubset<T, CompanyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Companies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Companies
     * const company = await prisma.company.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CompanyUpdateManyArgs>(args: SelectSubset<T, CompanyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Company.
     * @param {CompanyUpsertArgs} args - Arguments to update or create a Company.
     * @example
     * // Update or create a Company
     * const company = await prisma.company.upsert({
     *   create: {
     *     // ... data to create a Company
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Company we want to update
     *   }
     * })
     */
    upsert<T extends CompanyUpsertArgs>(args: SelectSubset<T, CompanyUpsertArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Companies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyCountArgs} args - Arguments to filter Companies to count.
     * @example
     * // Count the number of Companies
     * const count = await prisma.company.count({
     *   where: {
     *     // ... the filter for the Companies we want to count
     *   }
     * })
    **/
    count<T extends CompanyCountArgs>(
      args?: Subset<T, CompanyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CompanyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Company.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CompanyAggregateArgs>(args: Subset<T, CompanyAggregateArgs>): Prisma.PrismaPromise<GetCompanyAggregateType<T>>

    /**
     * Group by Company.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CompanyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CompanyGroupByArgs['orderBy'] }
        : { orderBy?: CompanyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CompanyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCompanyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Company model
   */
  readonly fields: CompanyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Company.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CompanyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    companyBranch<T extends Company$companyBranchArgs<ExtArgs> = {}>(args?: Subset<T, Company$companyBranchArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompanyBranchPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Company model
   */ 
  interface CompanyFieldRefs {
    readonly id: FieldRef<"Company", 'Int'>
    readonly companyName: FieldRef<"Company", 'String'>
    readonly createdAt: FieldRef<"Company", 'DateTime'>
    readonly updatedAt: FieldRef<"Company", 'DateTime'>
    readonly deletedAt: FieldRef<"Company", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Company findUnique
   */
  export type CompanyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * Filter, which Company to fetch.
     */
    where: CompanyWhereUniqueInput
  }

  /**
   * Company findUniqueOrThrow
   */
  export type CompanyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * Filter, which Company to fetch.
     */
    where: CompanyWhereUniqueInput
  }

  /**
   * Company findFirst
   */
  export type CompanyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * Filter, which Company to fetch.
     */
    where?: CompanyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Companies to fetch.
     */
    orderBy?: CompanyOrderByWithRelationInput | CompanyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Companies.
     */
    cursor?: CompanyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Companies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Companies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Companies.
     */
    distinct?: CompanyScalarFieldEnum | CompanyScalarFieldEnum[]
  }

  /**
   * Company findFirstOrThrow
   */
  export type CompanyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * Filter, which Company to fetch.
     */
    where?: CompanyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Companies to fetch.
     */
    orderBy?: CompanyOrderByWithRelationInput | CompanyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Companies.
     */
    cursor?: CompanyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Companies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Companies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Companies.
     */
    distinct?: CompanyScalarFieldEnum | CompanyScalarFieldEnum[]
  }

  /**
   * Company findMany
   */
  export type CompanyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * Filter, which Companies to fetch.
     */
    where?: CompanyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Companies to fetch.
     */
    orderBy?: CompanyOrderByWithRelationInput | CompanyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Companies.
     */
    cursor?: CompanyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Companies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Companies.
     */
    skip?: number
    distinct?: CompanyScalarFieldEnum | CompanyScalarFieldEnum[]
  }

  /**
   * Company create
   */
  export type CompanyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * The data needed to create a Company.
     */
    data: XOR<CompanyCreateInput, CompanyUncheckedCreateInput>
  }

  /**
   * Company createMany
   */
  export type CompanyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Companies.
     */
    data: CompanyCreateManyInput | CompanyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Company update
   */
  export type CompanyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * The data needed to update a Company.
     */
    data: XOR<CompanyUpdateInput, CompanyUncheckedUpdateInput>
    /**
     * Choose, which Company to update.
     */
    where: CompanyWhereUniqueInput
  }

  /**
   * Company updateMany
   */
  export type CompanyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Companies.
     */
    data: XOR<CompanyUpdateManyMutationInput, CompanyUncheckedUpdateManyInput>
    /**
     * Filter which Companies to update
     */
    where?: CompanyWhereInput
  }

  /**
   * Company upsert
   */
  export type CompanyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * The filter to search for the Company to update in case it exists.
     */
    where: CompanyWhereUniqueInput
    /**
     * In case the Company found by the `where` argument doesn't exist, create a new Company with this data.
     */
    create: XOR<CompanyCreateInput, CompanyUncheckedCreateInput>
    /**
     * In case the Company was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CompanyUpdateInput, CompanyUncheckedUpdateInput>
  }

  /**
   * Company delete
   */
  export type CompanyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * Filter which Company to delete.
     */
    where: CompanyWhereUniqueInput
  }

  /**
   * Company deleteMany
   */
  export type CompanyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Companies to delete
     */
    where?: CompanyWhereInput
  }

  /**
   * Company.companyBranch
   */
  export type Company$companyBranchArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyBranch
     */
    select?: CompanyBranchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyBranchInclude<ExtArgs> | null
    where?: CompanyBranchWhereInput
    orderBy?: CompanyBranchOrderByWithRelationInput | CompanyBranchOrderByWithRelationInput[]
    cursor?: CompanyBranchWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CompanyBranchScalarFieldEnum | CompanyBranchScalarFieldEnum[]
  }

  /**
   * Company without action
   */
  export type CompanyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
  }


  /**
   * Model CompanyBranch
   */

  export type AggregateCompanyBranch = {
    _count: CompanyBranchCountAggregateOutputType | null
    _avg: CompanyBranchAvgAggregateOutputType | null
    _sum: CompanyBranchSumAggregateOutputType | null
    _min: CompanyBranchMinAggregateOutputType | null
    _max: CompanyBranchMaxAggregateOutputType | null
  }

  export type CompanyBranchAvgAggregateOutputType = {
    id: number | null
    companyId: number | null
  }

  export type CompanyBranchSumAggregateOutputType = {
    id: number | null
    companyId: number | null
  }

  export type CompanyBranchMinAggregateOutputType = {
    id: number | null
    companyId: number | null
    companyBranchName: string | null
  }

  export type CompanyBranchMaxAggregateOutputType = {
    id: number | null
    companyId: number | null
    companyBranchName: string | null
  }

  export type CompanyBranchCountAggregateOutputType = {
    id: number
    companyId: number
    companyBranchName: number
    _all: number
  }


  export type CompanyBranchAvgAggregateInputType = {
    id?: true
    companyId?: true
  }

  export type CompanyBranchSumAggregateInputType = {
    id?: true
    companyId?: true
  }

  export type CompanyBranchMinAggregateInputType = {
    id?: true
    companyId?: true
    companyBranchName?: true
  }

  export type CompanyBranchMaxAggregateInputType = {
    id?: true
    companyId?: true
    companyBranchName?: true
  }

  export type CompanyBranchCountAggregateInputType = {
    id?: true
    companyId?: true
    companyBranchName?: true
    _all?: true
  }

  export type CompanyBranchAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CompanyBranch to aggregate.
     */
    where?: CompanyBranchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CompanyBranches to fetch.
     */
    orderBy?: CompanyBranchOrderByWithRelationInput | CompanyBranchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CompanyBranchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CompanyBranches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CompanyBranches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CompanyBranches
    **/
    _count?: true | CompanyBranchCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CompanyBranchAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CompanyBranchSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CompanyBranchMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CompanyBranchMaxAggregateInputType
  }

  export type GetCompanyBranchAggregateType<T extends CompanyBranchAggregateArgs> = {
        [P in keyof T & keyof AggregateCompanyBranch]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCompanyBranch[P]>
      : GetScalarType<T[P], AggregateCompanyBranch[P]>
  }




  export type CompanyBranchGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CompanyBranchWhereInput
    orderBy?: CompanyBranchOrderByWithAggregationInput | CompanyBranchOrderByWithAggregationInput[]
    by: CompanyBranchScalarFieldEnum[] | CompanyBranchScalarFieldEnum
    having?: CompanyBranchScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CompanyBranchCountAggregateInputType | true
    _avg?: CompanyBranchAvgAggregateInputType
    _sum?: CompanyBranchSumAggregateInputType
    _min?: CompanyBranchMinAggregateInputType
    _max?: CompanyBranchMaxAggregateInputType
  }

  export type CompanyBranchGroupByOutputType = {
    id: number
    companyId: number
    companyBranchName: string
    _count: CompanyBranchCountAggregateOutputType | null
    _avg: CompanyBranchAvgAggregateOutputType | null
    _sum: CompanyBranchSumAggregateOutputType | null
    _min: CompanyBranchMinAggregateOutputType | null
    _max: CompanyBranchMaxAggregateOutputType | null
  }

  type GetCompanyBranchGroupByPayload<T extends CompanyBranchGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CompanyBranchGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CompanyBranchGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CompanyBranchGroupByOutputType[P]>
            : GetScalarType<T[P], CompanyBranchGroupByOutputType[P]>
        }
      >
    >


  export type CompanyBranchSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyId?: boolean
    companyBranchName?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["companyBranch"]>


  export type CompanyBranchSelectScalar = {
    id?: boolean
    companyId?: boolean
    companyBranchName?: boolean
  }

  export type CompanyBranchInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }

  export type $CompanyBranchPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CompanyBranch"
    objects: {
      company: Prisma.$CompanyPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      companyId: number
      companyBranchName: string
    }, ExtArgs["result"]["companyBranch"]>
    composites: {}
  }

  type CompanyBranchGetPayload<S extends boolean | null | undefined | CompanyBranchDefaultArgs> = $Result.GetResult<Prisma.$CompanyBranchPayload, S>

  type CompanyBranchCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CompanyBranchFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CompanyBranchCountAggregateInputType | true
    }

  export interface CompanyBranchDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CompanyBranch'], meta: { name: 'CompanyBranch' } }
    /**
     * Find zero or one CompanyBranch that matches the filter.
     * @param {CompanyBranchFindUniqueArgs} args - Arguments to find a CompanyBranch
     * @example
     * // Get one CompanyBranch
     * const companyBranch = await prisma.companyBranch.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CompanyBranchFindUniqueArgs>(args: SelectSubset<T, CompanyBranchFindUniqueArgs<ExtArgs>>): Prisma__CompanyBranchClient<$Result.GetResult<Prisma.$CompanyBranchPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one CompanyBranch that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CompanyBranchFindUniqueOrThrowArgs} args - Arguments to find a CompanyBranch
     * @example
     * // Get one CompanyBranch
     * const companyBranch = await prisma.companyBranch.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CompanyBranchFindUniqueOrThrowArgs>(args: SelectSubset<T, CompanyBranchFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CompanyBranchClient<$Result.GetResult<Prisma.$CompanyBranchPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first CompanyBranch that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyBranchFindFirstArgs} args - Arguments to find a CompanyBranch
     * @example
     * // Get one CompanyBranch
     * const companyBranch = await prisma.companyBranch.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CompanyBranchFindFirstArgs>(args?: SelectSubset<T, CompanyBranchFindFirstArgs<ExtArgs>>): Prisma__CompanyBranchClient<$Result.GetResult<Prisma.$CompanyBranchPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first CompanyBranch that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyBranchFindFirstOrThrowArgs} args - Arguments to find a CompanyBranch
     * @example
     * // Get one CompanyBranch
     * const companyBranch = await prisma.companyBranch.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CompanyBranchFindFirstOrThrowArgs>(args?: SelectSubset<T, CompanyBranchFindFirstOrThrowArgs<ExtArgs>>): Prisma__CompanyBranchClient<$Result.GetResult<Prisma.$CompanyBranchPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more CompanyBranches that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyBranchFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CompanyBranches
     * const companyBranches = await prisma.companyBranch.findMany()
     * 
     * // Get first 10 CompanyBranches
     * const companyBranches = await prisma.companyBranch.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const companyBranchWithIdOnly = await prisma.companyBranch.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CompanyBranchFindManyArgs>(args?: SelectSubset<T, CompanyBranchFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompanyBranchPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a CompanyBranch.
     * @param {CompanyBranchCreateArgs} args - Arguments to create a CompanyBranch.
     * @example
     * // Create one CompanyBranch
     * const CompanyBranch = await prisma.companyBranch.create({
     *   data: {
     *     // ... data to create a CompanyBranch
     *   }
     * })
     * 
     */
    create<T extends CompanyBranchCreateArgs>(args: SelectSubset<T, CompanyBranchCreateArgs<ExtArgs>>): Prisma__CompanyBranchClient<$Result.GetResult<Prisma.$CompanyBranchPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many CompanyBranches.
     * @param {CompanyBranchCreateManyArgs} args - Arguments to create many CompanyBranches.
     * @example
     * // Create many CompanyBranches
     * const companyBranch = await prisma.companyBranch.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CompanyBranchCreateManyArgs>(args?: SelectSubset<T, CompanyBranchCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a CompanyBranch.
     * @param {CompanyBranchDeleteArgs} args - Arguments to delete one CompanyBranch.
     * @example
     * // Delete one CompanyBranch
     * const CompanyBranch = await prisma.companyBranch.delete({
     *   where: {
     *     // ... filter to delete one CompanyBranch
     *   }
     * })
     * 
     */
    delete<T extends CompanyBranchDeleteArgs>(args: SelectSubset<T, CompanyBranchDeleteArgs<ExtArgs>>): Prisma__CompanyBranchClient<$Result.GetResult<Prisma.$CompanyBranchPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one CompanyBranch.
     * @param {CompanyBranchUpdateArgs} args - Arguments to update one CompanyBranch.
     * @example
     * // Update one CompanyBranch
     * const companyBranch = await prisma.companyBranch.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CompanyBranchUpdateArgs>(args: SelectSubset<T, CompanyBranchUpdateArgs<ExtArgs>>): Prisma__CompanyBranchClient<$Result.GetResult<Prisma.$CompanyBranchPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more CompanyBranches.
     * @param {CompanyBranchDeleteManyArgs} args - Arguments to filter CompanyBranches to delete.
     * @example
     * // Delete a few CompanyBranches
     * const { count } = await prisma.companyBranch.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CompanyBranchDeleteManyArgs>(args?: SelectSubset<T, CompanyBranchDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CompanyBranches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyBranchUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CompanyBranches
     * const companyBranch = await prisma.companyBranch.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CompanyBranchUpdateManyArgs>(args: SelectSubset<T, CompanyBranchUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CompanyBranch.
     * @param {CompanyBranchUpsertArgs} args - Arguments to update or create a CompanyBranch.
     * @example
     * // Update or create a CompanyBranch
     * const companyBranch = await prisma.companyBranch.upsert({
     *   create: {
     *     // ... data to create a CompanyBranch
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CompanyBranch we want to update
     *   }
     * })
     */
    upsert<T extends CompanyBranchUpsertArgs>(args: SelectSubset<T, CompanyBranchUpsertArgs<ExtArgs>>): Prisma__CompanyBranchClient<$Result.GetResult<Prisma.$CompanyBranchPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of CompanyBranches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyBranchCountArgs} args - Arguments to filter CompanyBranches to count.
     * @example
     * // Count the number of CompanyBranches
     * const count = await prisma.companyBranch.count({
     *   where: {
     *     // ... the filter for the CompanyBranches we want to count
     *   }
     * })
    **/
    count<T extends CompanyBranchCountArgs>(
      args?: Subset<T, CompanyBranchCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CompanyBranchCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CompanyBranch.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyBranchAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CompanyBranchAggregateArgs>(args: Subset<T, CompanyBranchAggregateArgs>): Prisma.PrismaPromise<GetCompanyBranchAggregateType<T>>

    /**
     * Group by CompanyBranch.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyBranchGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CompanyBranchGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CompanyBranchGroupByArgs['orderBy'] }
        : { orderBy?: CompanyBranchGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CompanyBranchGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCompanyBranchGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CompanyBranch model
   */
  readonly fields: CompanyBranchFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CompanyBranch.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CompanyBranchClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    company<T extends CompanyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CompanyDefaultArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CompanyBranch model
   */ 
  interface CompanyBranchFieldRefs {
    readonly id: FieldRef<"CompanyBranch", 'Int'>
    readonly companyId: FieldRef<"CompanyBranch", 'Int'>
    readonly companyBranchName: FieldRef<"CompanyBranch", 'String'>
  }
    

  // Custom InputTypes
  /**
   * CompanyBranch findUnique
   */
  export type CompanyBranchFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyBranch
     */
    select?: CompanyBranchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyBranchInclude<ExtArgs> | null
    /**
     * Filter, which CompanyBranch to fetch.
     */
    where: CompanyBranchWhereUniqueInput
  }

  /**
   * CompanyBranch findUniqueOrThrow
   */
  export type CompanyBranchFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyBranch
     */
    select?: CompanyBranchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyBranchInclude<ExtArgs> | null
    /**
     * Filter, which CompanyBranch to fetch.
     */
    where: CompanyBranchWhereUniqueInput
  }

  /**
   * CompanyBranch findFirst
   */
  export type CompanyBranchFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyBranch
     */
    select?: CompanyBranchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyBranchInclude<ExtArgs> | null
    /**
     * Filter, which CompanyBranch to fetch.
     */
    where?: CompanyBranchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CompanyBranches to fetch.
     */
    orderBy?: CompanyBranchOrderByWithRelationInput | CompanyBranchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CompanyBranches.
     */
    cursor?: CompanyBranchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CompanyBranches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CompanyBranches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CompanyBranches.
     */
    distinct?: CompanyBranchScalarFieldEnum | CompanyBranchScalarFieldEnum[]
  }

  /**
   * CompanyBranch findFirstOrThrow
   */
  export type CompanyBranchFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyBranch
     */
    select?: CompanyBranchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyBranchInclude<ExtArgs> | null
    /**
     * Filter, which CompanyBranch to fetch.
     */
    where?: CompanyBranchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CompanyBranches to fetch.
     */
    orderBy?: CompanyBranchOrderByWithRelationInput | CompanyBranchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CompanyBranches.
     */
    cursor?: CompanyBranchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CompanyBranches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CompanyBranches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CompanyBranches.
     */
    distinct?: CompanyBranchScalarFieldEnum | CompanyBranchScalarFieldEnum[]
  }

  /**
   * CompanyBranch findMany
   */
  export type CompanyBranchFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyBranch
     */
    select?: CompanyBranchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyBranchInclude<ExtArgs> | null
    /**
     * Filter, which CompanyBranches to fetch.
     */
    where?: CompanyBranchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CompanyBranches to fetch.
     */
    orderBy?: CompanyBranchOrderByWithRelationInput | CompanyBranchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CompanyBranches.
     */
    cursor?: CompanyBranchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CompanyBranches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CompanyBranches.
     */
    skip?: number
    distinct?: CompanyBranchScalarFieldEnum | CompanyBranchScalarFieldEnum[]
  }

  /**
   * CompanyBranch create
   */
  export type CompanyBranchCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyBranch
     */
    select?: CompanyBranchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyBranchInclude<ExtArgs> | null
    /**
     * The data needed to create a CompanyBranch.
     */
    data: XOR<CompanyBranchCreateInput, CompanyBranchUncheckedCreateInput>
  }

  /**
   * CompanyBranch createMany
   */
  export type CompanyBranchCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CompanyBranches.
     */
    data: CompanyBranchCreateManyInput | CompanyBranchCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CompanyBranch update
   */
  export type CompanyBranchUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyBranch
     */
    select?: CompanyBranchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyBranchInclude<ExtArgs> | null
    /**
     * The data needed to update a CompanyBranch.
     */
    data: XOR<CompanyBranchUpdateInput, CompanyBranchUncheckedUpdateInput>
    /**
     * Choose, which CompanyBranch to update.
     */
    where: CompanyBranchWhereUniqueInput
  }

  /**
   * CompanyBranch updateMany
   */
  export type CompanyBranchUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CompanyBranches.
     */
    data: XOR<CompanyBranchUpdateManyMutationInput, CompanyBranchUncheckedUpdateManyInput>
    /**
     * Filter which CompanyBranches to update
     */
    where?: CompanyBranchWhereInput
  }

  /**
   * CompanyBranch upsert
   */
  export type CompanyBranchUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyBranch
     */
    select?: CompanyBranchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyBranchInclude<ExtArgs> | null
    /**
     * The filter to search for the CompanyBranch to update in case it exists.
     */
    where: CompanyBranchWhereUniqueInput
    /**
     * In case the CompanyBranch found by the `where` argument doesn't exist, create a new CompanyBranch with this data.
     */
    create: XOR<CompanyBranchCreateInput, CompanyBranchUncheckedCreateInput>
    /**
     * In case the CompanyBranch was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CompanyBranchUpdateInput, CompanyBranchUncheckedUpdateInput>
  }

  /**
   * CompanyBranch delete
   */
  export type CompanyBranchDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyBranch
     */
    select?: CompanyBranchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyBranchInclude<ExtArgs> | null
    /**
     * Filter which CompanyBranch to delete.
     */
    where: CompanyBranchWhereUniqueInput
  }

  /**
   * CompanyBranch deleteMany
   */
  export type CompanyBranchDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CompanyBranches to delete
     */
    where?: CompanyBranchWhereInput
  }

  /**
   * CompanyBranch without action
   */
  export type CompanyBranchDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyBranch
     */
    select?: CompanyBranchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyBranchInclude<ExtArgs> | null
  }


  /**
   * Model Department
   */

  export type AggregateDepartment = {
    _count: DepartmentCountAggregateOutputType | null
    _avg: DepartmentAvgAggregateOutputType | null
    _sum: DepartmentSumAggregateOutputType | null
    _min: DepartmentMinAggregateOutputType | null
    _max: DepartmentMaxAggregateOutputType | null
  }

  export type DepartmentAvgAggregateOutputType = {
    id: number | null
  }

  export type DepartmentSumAggregateOutputType = {
    id: number | null
  }

  export type DepartmentMinAggregateOutputType = {
    id: number | null
    departmentName: string | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type DepartmentMaxAggregateOutputType = {
    id: number | null
    departmentName: string | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type DepartmentCountAggregateOutputType = {
    id: number
    departmentName: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    _all: number
  }


  export type DepartmentAvgAggregateInputType = {
    id?: true
  }

  export type DepartmentSumAggregateInputType = {
    id?: true
  }

  export type DepartmentMinAggregateInputType = {
    id?: true
    departmentName?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type DepartmentMaxAggregateInputType = {
    id?: true
    departmentName?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type DepartmentCountAggregateInputType = {
    id?: true
    departmentName?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    _all?: true
  }

  export type DepartmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Department to aggregate.
     */
    where?: DepartmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Departments to fetch.
     */
    orderBy?: DepartmentOrderByWithRelationInput | DepartmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DepartmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Departments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Departments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Departments
    **/
    _count?: true | DepartmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DepartmentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DepartmentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DepartmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DepartmentMaxAggregateInputType
  }

  export type GetDepartmentAggregateType<T extends DepartmentAggregateArgs> = {
        [P in keyof T & keyof AggregateDepartment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDepartment[P]>
      : GetScalarType<T[P], AggregateDepartment[P]>
  }




  export type DepartmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DepartmentWhereInput
    orderBy?: DepartmentOrderByWithAggregationInput | DepartmentOrderByWithAggregationInput[]
    by: DepartmentScalarFieldEnum[] | DepartmentScalarFieldEnum
    having?: DepartmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DepartmentCountAggregateInputType | true
    _avg?: DepartmentAvgAggregateInputType
    _sum?: DepartmentSumAggregateInputType
    _min?: DepartmentMinAggregateInputType
    _max?: DepartmentMaxAggregateInputType
  }

  export type DepartmentGroupByOutputType = {
    id: number
    departmentName: string
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
    _count: DepartmentCountAggregateOutputType | null
    _avg: DepartmentAvgAggregateOutputType | null
    _sum: DepartmentSumAggregateOutputType | null
    _min: DepartmentMinAggregateOutputType | null
    _max: DepartmentMaxAggregateOutputType | null
  }

  type GetDepartmentGroupByPayload<T extends DepartmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DepartmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DepartmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DepartmentGroupByOutputType[P]>
            : GetScalarType<T[P], DepartmentGroupByOutputType[P]>
        }
      >
    >


  export type DepartmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    departmentName?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    user?: boolean | Department$userArgs<ExtArgs>
    Course?: boolean | Department$CourseArgs<ExtArgs>
    _count?: boolean | DepartmentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["department"]>


  export type DepartmentSelectScalar = {
    id?: boolean
    departmentName?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }

  export type DepartmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | Department$userArgs<ExtArgs>
    Course?: boolean | Department$CourseArgs<ExtArgs>
    _count?: boolean | DepartmentCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $DepartmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Department"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>[]
      Course: Prisma.$CoursePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      departmentName: string
      createdAt: Date
      updatedAt: Date
      deletedAt: Date | null
    }, ExtArgs["result"]["department"]>
    composites: {}
  }

  type DepartmentGetPayload<S extends boolean | null | undefined | DepartmentDefaultArgs> = $Result.GetResult<Prisma.$DepartmentPayload, S>

  type DepartmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<DepartmentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: DepartmentCountAggregateInputType | true
    }

  export interface DepartmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Department'], meta: { name: 'Department' } }
    /**
     * Find zero or one Department that matches the filter.
     * @param {DepartmentFindUniqueArgs} args - Arguments to find a Department
     * @example
     * // Get one Department
     * const department = await prisma.department.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DepartmentFindUniqueArgs>(args: SelectSubset<T, DepartmentFindUniqueArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Department that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {DepartmentFindUniqueOrThrowArgs} args - Arguments to find a Department
     * @example
     * // Get one Department
     * const department = await prisma.department.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DepartmentFindUniqueOrThrowArgs>(args: SelectSubset<T, DepartmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Department that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentFindFirstArgs} args - Arguments to find a Department
     * @example
     * // Get one Department
     * const department = await prisma.department.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DepartmentFindFirstArgs>(args?: SelectSubset<T, DepartmentFindFirstArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Department that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentFindFirstOrThrowArgs} args - Arguments to find a Department
     * @example
     * // Get one Department
     * const department = await prisma.department.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DepartmentFindFirstOrThrowArgs>(args?: SelectSubset<T, DepartmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Departments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Departments
     * const departments = await prisma.department.findMany()
     * 
     * // Get first 10 Departments
     * const departments = await prisma.department.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const departmentWithIdOnly = await prisma.department.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DepartmentFindManyArgs>(args?: SelectSubset<T, DepartmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Department.
     * @param {DepartmentCreateArgs} args - Arguments to create a Department.
     * @example
     * // Create one Department
     * const Department = await prisma.department.create({
     *   data: {
     *     // ... data to create a Department
     *   }
     * })
     * 
     */
    create<T extends DepartmentCreateArgs>(args: SelectSubset<T, DepartmentCreateArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Departments.
     * @param {DepartmentCreateManyArgs} args - Arguments to create many Departments.
     * @example
     * // Create many Departments
     * const department = await prisma.department.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DepartmentCreateManyArgs>(args?: SelectSubset<T, DepartmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Department.
     * @param {DepartmentDeleteArgs} args - Arguments to delete one Department.
     * @example
     * // Delete one Department
     * const Department = await prisma.department.delete({
     *   where: {
     *     // ... filter to delete one Department
     *   }
     * })
     * 
     */
    delete<T extends DepartmentDeleteArgs>(args: SelectSubset<T, DepartmentDeleteArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Department.
     * @param {DepartmentUpdateArgs} args - Arguments to update one Department.
     * @example
     * // Update one Department
     * const department = await prisma.department.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DepartmentUpdateArgs>(args: SelectSubset<T, DepartmentUpdateArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Departments.
     * @param {DepartmentDeleteManyArgs} args - Arguments to filter Departments to delete.
     * @example
     * // Delete a few Departments
     * const { count } = await prisma.department.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DepartmentDeleteManyArgs>(args?: SelectSubset<T, DepartmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Departments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Departments
     * const department = await prisma.department.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DepartmentUpdateManyArgs>(args: SelectSubset<T, DepartmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Department.
     * @param {DepartmentUpsertArgs} args - Arguments to update or create a Department.
     * @example
     * // Update or create a Department
     * const department = await prisma.department.upsert({
     *   create: {
     *     // ... data to create a Department
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Department we want to update
     *   }
     * })
     */
    upsert<T extends DepartmentUpsertArgs>(args: SelectSubset<T, DepartmentUpsertArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Departments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentCountArgs} args - Arguments to filter Departments to count.
     * @example
     * // Count the number of Departments
     * const count = await prisma.department.count({
     *   where: {
     *     // ... the filter for the Departments we want to count
     *   }
     * })
    **/
    count<T extends DepartmentCountArgs>(
      args?: Subset<T, DepartmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DepartmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Department.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DepartmentAggregateArgs>(args: Subset<T, DepartmentAggregateArgs>): Prisma.PrismaPromise<GetDepartmentAggregateType<T>>

    /**
     * Group by Department.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DepartmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DepartmentGroupByArgs['orderBy'] }
        : { orderBy?: DepartmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DepartmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDepartmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Department model
   */
  readonly fields: DepartmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Department.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DepartmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends Department$userArgs<ExtArgs> = {}>(args?: Subset<T, Department$userArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany"> | Null>
    Course<T extends Department$CourseArgs<ExtArgs> = {}>(args?: Subset<T, Department$CourseArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Department model
   */ 
  interface DepartmentFieldRefs {
    readonly id: FieldRef<"Department", 'Int'>
    readonly departmentName: FieldRef<"Department", 'String'>
    readonly createdAt: FieldRef<"Department", 'DateTime'>
    readonly updatedAt: FieldRef<"Department", 'DateTime'>
    readonly deletedAt: FieldRef<"Department", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Department findUnique
   */
  export type DepartmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * Filter, which Department to fetch.
     */
    where: DepartmentWhereUniqueInput
  }

  /**
   * Department findUniqueOrThrow
   */
  export type DepartmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * Filter, which Department to fetch.
     */
    where: DepartmentWhereUniqueInput
  }

  /**
   * Department findFirst
   */
  export type DepartmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * Filter, which Department to fetch.
     */
    where?: DepartmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Departments to fetch.
     */
    orderBy?: DepartmentOrderByWithRelationInput | DepartmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Departments.
     */
    cursor?: DepartmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Departments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Departments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Departments.
     */
    distinct?: DepartmentScalarFieldEnum | DepartmentScalarFieldEnum[]
  }

  /**
   * Department findFirstOrThrow
   */
  export type DepartmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * Filter, which Department to fetch.
     */
    where?: DepartmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Departments to fetch.
     */
    orderBy?: DepartmentOrderByWithRelationInput | DepartmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Departments.
     */
    cursor?: DepartmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Departments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Departments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Departments.
     */
    distinct?: DepartmentScalarFieldEnum | DepartmentScalarFieldEnum[]
  }

  /**
   * Department findMany
   */
  export type DepartmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * Filter, which Departments to fetch.
     */
    where?: DepartmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Departments to fetch.
     */
    orderBy?: DepartmentOrderByWithRelationInput | DepartmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Departments.
     */
    cursor?: DepartmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Departments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Departments.
     */
    skip?: number
    distinct?: DepartmentScalarFieldEnum | DepartmentScalarFieldEnum[]
  }

  /**
   * Department create
   */
  export type DepartmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * The data needed to create a Department.
     */
    data: XOR<DepartmentCreateInput, DepartmentUncheckedCreateInput>
  }

  /**
   * Department createMany
   */
  export type DepartmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Departments.
     */
    data: DepartmentCreateManyInput | DepartmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Department update
   */
  export type DepartmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * The data needed to update a Department.
     */
    data: XOR<DepartmentUpdateInput, DepartmentUncheckedUpdateInput>
    /**
     * Choose, which Department to update.
     */
    where: DepartmentWhereUniqueInput
  }

  /**
   * Department updateMany
   */
  export type DepartmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Departments.
     */
    data: XOR<DepartmentUpdateManyMutationInput, DepartmentUncheckedUpdateManyInput>
    /**
     * Filter which Departments to update
     */
    where?: DepartmentWhereInput
  }

  /**
   * Department upsert
   */
  export type DepartmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * The filter to search for the Department to update in case it exists.
     */
    where: DepartmentWhereUniqueInput
    /**
     * In case the Department found by the `where` argument doesn't exist, create a new Department with this data.
     */
    create: XOR<DepartmentCreateInput, DepartmentUncheckedCreateInput>
    /**
     * In case the Department was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DepartmentUpdateInput, DepartmentUncheckedUpdateInput>
  }

  /**
   * Department delete
   */
  export type DepartmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * Filter which Department to delete.
     */
    where: DepartmentWhereUniqueInput
  }

  /**
   * Department deleteMany
   */
  export type DepartmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Departments to delete
     */
    where?: DepartmentWhereInput
  }

  /**
   * Department.user
   */
  export type Department$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * Department.Course
   */
  export type Department$CourseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    where?: CourseWhereInput
    orderBy?: CourseOrderByWithRelationInput | CourseOrderByWithRelationInput[]
    cursor?: CourseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CourseScalarFieldEnum | CourseScalarFieldEnum[]
  }

  /**
   * Department without action
   */
  export type DepartmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
  }


  /**
   * Model Course
   */

  export type AggregateCourse = {
    _count: CourseCountAggregateOutputType | null
    _avg: CourseAvgAggregateOutputType | null
    _sum: CourseSumAggregateOutputType | null
    _min: CourseMinAggregateOutputType | null
    _max: CourseMaxAggregateOutputType | null
  }

  export type CourseAvgAggregateOutputType = {
    id: number | null
    typeId: number | null
    departmentId: number | null
    processId: number | null
    createdBy: number | null
    deletedBy: number | null
  }

  export type CourseSumAggregateOutputType = {
    id: number | null
    typeId: number | null
    departmentId: number | null
    processId: number | null
    createdBy: number | null
    deletedBy: number | null
  }

  export type CourseMinAggregateOutputType = {
    id: number | null
    title: string | null
    description: string | null
    pdfUrl: string | null
    videoUrl: string | null
    typeId: number | null
    template: boolean | null
    departmentId: number | null
    processId: number | null
    createdAt: Date | null
    updatedAt: Date | null
    createdBy: number | null
    deletedBy: number | null
    isDeleted: boolean | null
  }

  export type CourseMaxAggregateOutputType = {
    id: number | null
    title: string | null
    description: string | null
    pdfUrl: string | null
    videoUrl: string | null
    typeId: number | null
    template: boolean | null
    departmentId: number | null
    processId: number | null
    createdAt: Date | null
    updatedAt: Date | null
    createdBy: number | null
    deletedBy: number | null
    isDeleted: boolean | null
  }

  export type CourseCountAggregateOutputType = {
    id: number
    title: number
    description: number
    pdfUrl: number
    videoUrl: number
    typeId: number
    template: number
    departmentId: number
    processId: number
    createdAt: number
    updatedAt: number
    createdBy: number
    deletedBy: number
    isDeleted: number
    _all: number
  }


  export type CourseAvgAggregateInputType = {
    id?: true
    typeId?: true
    departmentId?: true
    processId?: true
    createdBy?: true
    deletedBy?: true
  }

  export type CourseSumAggregateInputType = {
    id?: true
    typeId?: true
    departmentId?: true
    processId?: true
    createdBy?: true
    deletedBy?: true
  }

  export type CourseMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    pdfUrl?: true
    videoUrl?: true
    typeId?: true
    template?: true
    departmentId?: true
    processId?: true
    createdAt?: true
    updatedAt?: true
    createdBy?: true
    deletedBy?: true
    isDeleted?: true
  }

  export type CourseMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    pdfUrl?: true
    videoUrl?: true
    typeId?: true
    template?: true
    departmentId?: true
    processId?: true
    createdAt?: true
    updatedAt?: true
    createdBy?: true
    deletedBy?: true
    isDeleted?: true
  }

  export type CourseCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    pdfUrl?: true
    videoUrl?: true
    typeId?: true
    template?: true
    departmentId?: true
    processId?: true
    createdAt?: true
    updatedAt?: true
    createdBy?: true
    deletedBy?: true
    isDeleted?: true
    _all?: true
  }

  export type CourseAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Course to aggregate.
     */
    where?: CourseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Courses to fetch.
     */
    orderBy?: CourseOrderByWithRelationInput | CourseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CourseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Courses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Courses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Courses
    **/
    _count?: true | CourseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CourseAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CourseSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CourseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CourseMaxAggregateInputType
  }

  export type GetCourseAggregateType<T extends CourseAggregateArgs> = {
        [P in keyof T & keyof AggregateCourse]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCourse[P]>
      : GetScalarType<T[P], AggregateCourse[P]>
  }




  export type CourseGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CourseWhereInput
    orderBy?: CourseOrderByWithAggregationInput | CourseOrderByWithAggregationInput[]
    by: CourseScalarFieldEnum[] | CourseScalarFieldEnum
    having?: CourseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CourseCountAggregateInputType | true
    _avg?: CourseAvgAggregateInputType
    _sum?: CourseSumAggregateInputType
    _min?: CourseMinAggregateInputType
    _max?: CourseMaxAggregateInputType
  }

  export type CourseGroupByOutputType = {
    id: number
    title: string
    description: string | null
    pdfUrl: string | null
    videoUrl: string | null
    typeId: number
    template: boolean
    departmentId: number | null
    processId: number
    createdAt: Date
    updatedAt: Date
    createdBy: number
    deletedBy: number | null
    isDeleted: boolean
    _count: CourseCountAggregateOutputType | null
    _avg: CourseAvgAggregateOutputType | null
    _sum: CourseSumAggregateOutputType | null
    _min: CourseMinAggregateOutputType | null
    _max: CourseMaxAggregateOutputType | null
  }

  type GetCourseGroupByPayload<T extends CourseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CourseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CourseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CourseGroupByOutputType[P]>
            : GetScalarType<T[P], CourseGroupByOutputType[P]>
        }
      >
    >


  export type CourseSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    pdfUrl?: boolean
    videoUrl?: boolean
    typeId?: boolean
    template?: boolean
    departmentId?: boolean
    processId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean
    deletedBy?: boolean
    isDeleted?: boolean
    department?: boolean | Course$departmentArgs<ExtArgs>
    process?: boolean | Course$processArgs<ExtArgs>
    enrollments?: boolean | Course$enrollmentsArgs<ExtArgs>
    files?: boolean | Course$filesArgs<ExtArgs>
    exams?: boolean | Course$examsArgs<ExtArgs>
    completions?: boolean | Course$completionsArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
    deleter?: boolean | Course$deleterArgs<ExtArgs>
    _count?: boolean | CourseCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["course"]>


  export type CourseSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    pdfUrl?: boolean
    videoUrl?: boolean
    typeId?: boolean
    template?: boolean
    departmentId?: boolean
    processId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean
    deletedBy?: boolean
    isDeleted?: boolean
  }

  export type CourseInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    department?: boolean | Course$departmentArgs<ExtArgs>
    process?: boolean | Course$processArgs<ExtArgs>
    enrollments?: boolean | Course$enrollmentsArgs<ExtArgs>
    files?: boolean | Course$filesArgs<ExtArgs>
    exams?: boolean | Course$examsArgs<ExtArgs>
    completions?: boolean | Course$completionsArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
    deleter?: boolean | Course$deleterArgs<ExtArgs>
    _count?: boolean | CourseCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $CoursePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Course"
    objects: {
      department: Prisma.$DepartmentPayload<ExtArgs> | null
      process: Prisma.$ProcessPayload<ExtArgs> | null
      enrollments: Prisma.$EnrollmentPayload<ExtArgs>[]
      files: Prisma.$FilePayload<ExtArgs>[]
      exams: Prisma.$ExamPayload<ExtArgs>[]
      completions: Prisma.$UserCourseCompletionPayload<ExtArgs>[]
      creator: Prisma.$UserPayload<ExtArgs>
      deleter: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      title: string
      description: string | null
      pdfUrl: string | null
      videoUrl: string | null
      typeId: number
      template: boolean
      departmentId: number | null
      processId: number
      createdAt: Date
      updatedAt: Date
      createdBy: number
      deletedBy: number | null
      isDeleted: boolean
    }, ExtArgs["result"]["course"]>
    composites: {}
  }

  type CourseGetPayload<S extends boolean | null | undefined | CourseDefaultArgs> = $Result.GetResult<Prisma.$CoursePayload, S>

  type CourseCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CourseFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CourseCountAggregateInputType | true
    }

  export interface CourseDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Course'], meta: { name: 'Course' } }
    /**
     * Find zero or one Course that matches the filter.
     * @param {CourseFindUniqueArgs} args - Arguments to find a Course
     * @example
     * // Get one Course
     * const course = await prisma.course.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CourseFindUniqueArgs>(args: SelectSubset<T, CourseFindUniqueArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Course that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CourseFindUniqueOrThrowArgs} args - Arguments to find a Course
     * @example
     * // Get one Course
     * const course = await prisma.course.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CourseFindUniqueOrThrowArgs>(args: SelectSubset<T, CourseFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Course that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseFindFirstArgs} args - Arguments to find a Course
     * @example
     * // Get one Course
     * const course = await prisma.course.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CourseFindFirstArgs>(args?: SelectSubset<T, CourseFindFirstArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Course that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseFindFirstOrThrowArgs} args - Arguments to find a Course
     * @example
     * // Get one Course
     * const course = await prisma.course.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CourseFindFirstOrThrowArgs>(args?: SelectSubset<T, CourseFindFirstOrThrowArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Courses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Courses
     * const courses = await prisma.course.findMany()
     * 
     * // Get first 10 Courses
     * const courses = await prisma.course.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const courseWithIdOnly = await prisma.course.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CourseFindManyArgs>(args?: SelectSubset<T, CourseFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Course.
     * @param {CourseCreateArgs} args - Arguments to create a Course.
     * @example
     * // Create one Course
     * const Course = await prisma.course.create({
     *   data: {
     *     // ... data to create a Course
     *   }
     * })
     * 
     */
    create<T extends CourseCreateArgs>(args: SelectSubset<T, CourseCreateArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Courses.
     * @param {CourseCreateManyArgs} args - Arguments to create many Courses.
     * @example
     * // Create many Courses
     * const course = await prisma.course.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CourseCreateManyArgs>(args?: SelectSubset<T, CourseCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Course.
     * @param {CourseDeleteArgs} args - Arguments to delete one Course.
     * @example
     * // Delete one Course
     * const Course = await prisma.course.delete({
     *   where: {
     *     // ... filter to delete one Course
     *   }
     * })
     * 
     */
    delete<T extends CourseDeleteArgs>(args: SelectSubset<T, CourseDeleteArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Course.
     * @param {CourseUpdateArgs} args - Arguments to update one Course.
     * @example
     * // Update one Course
     * const course = await prisma.course.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CourseUpdateArgs>(args: SelectSubset<T, CourseUpdateArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Courses.
     * @param {CourseDeleteManyArgs} args - Arguments to filter Courses to delete.
     * @example
     * // Delete a few Courses
     * const { count } = await prisma.course.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CourseDeleteManyArgs>(args?: SelectSubset<T, CourseDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Courses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Courses
     * const course = await prisma.course.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CourseUpdateManyArgs>(args: SelectSubset<T, CourseUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Course.
     * @param {CourseUpsertArgs} args - Arguments to update or create a Course.
     * @example
     * // Update or create a Course
     * const course = await prisma.course.upsert({
     *   create: {
     *     // ... data to create a Course
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Course we want to update
     *   }
     * })
     */
    upsert<T extends CourseUpsertArgs>(args: SelectSubset<T, CourseUpsertArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Courses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseCountArgs} args - Arguments to filter Courses to count.
     * @example
     * // Count the number of Courses
     * const count = await prisma.course.count({
     *   where: {
     *     // ... the filter for the Courses we want to count
     *   }
     * })
    **/
    count<T extends CourseCountArgs>(
      args?: Subset<T, CourseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CourseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Course.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CourseAggregateArgs>(args: Subset<T, CourseAggregateArgs>): Prisma.PrismaPromise<GetCourseAggregateType<T>>

    /**
     * Group by Course.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CourseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CourseGroupByArgs['orderBy'] }
        : { orderBy?: CourseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CourseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCourseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Course model
   */
  readonly fields: CourseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Course.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CourseClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    department<T extends Course$departmentArgs<ExtArgs> = {}>(args?: Subset<T, Course$departmentArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    process<T extends Course$processArgs<ExtArgs> = {}>(args?: Subset<T, Course$processArgs<ExtArgs>>): Prisma__ProcessClient<$Result.GetResult<Prisma.$ProcessPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    enrollments<T extends Course$enrollmentsArgs<ExtArgs> = {}>(args?: Subset<T, Course$enrollmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EnrollmentPayload<ExtArgs>, T, "findMany"> | Null>
    files<T extends Course$filesArgs<ExtArgs> = {}>(args?: Subset<T, Course$filesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FilePayload<ExtArgs>, T, "findMany"> | Null>
    exams<T extends Course$examsArgs<ExtArgs> = {}>(args?: Subset<T, Course$examsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExamPayload<ExtArgs>, T, "findMany"> | Null>
    completions<T extends Course$completionsArgs<ExtArgs> = {}>(args?: Subset<T, Course$completionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserCourseCompletionPayload<ExtArgs>, T, "findMany"> | Null>
    creator<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    deleter<T extends Course$deleterArgs<ExtArgs> = {}>(args?: Subset<T, Course$deleterArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Course model
   */ 
  interface CourseFieldRefs {
    readonly id: FieldRef<"Course", 'Int'>
    readonly title: FieldRef<"Course", 'String'>
    readonly description: FieldRef<"Course", 'String'>
    readonly pdfUrl: FieldRef<"Course", 'String'>
    readonly videoUrl: FieldRef<"Course", 'String'>
    readonly typeId: FieldRef<"Course", 'Int'>
    readonly template: FieldRef<"Course", 'Boolean'>
    readonly departmentId: FieldRef<"Course", 'Int'>
    readonly processId: FieldRef<"Course", 'Int'>
    readonly createdAt: FieldRef<"Course", 'DateTime'>
    readonly updatedAt: FieldRef<"Course", 'DateTime'>
    readonly createdBy: FieldRef<"Course", 'Int'>
    readonly deletedBy: FieldRef<"Course", 'Int'>
    readonly isDeleted: FieldRef<"Course", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * Course findUnique
   */
  export type CourseFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    /**
     * Filter, which Course to fetch.
     */
    where: CourseWhereUniqueInput
  }

  /**
   * Course findUniqueOrThrow
   */
  export type CourseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    /**
     * Filter, which Course to fetch.
     */
    where: CourseWhereUniqueInput
  }

  /**
   * Course findFirst
   */
  export type CourseFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    /**
     * Filter, which Course to fetch.
     */
    where?: CourseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Courses to fetch.
     */
    orderBy?: CourseOrderByWithRelationInput | CourseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Courses.
     */
    cursor?: CourseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Courses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Courses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Courses.
     */
    distinct?: CourseScalarFieldEnum | CourseScalarFieldEnum[]
  }

  /**
   * Course findFirstOrThrow
   */
  export type CourseFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    /**
     * Filter, which Course to fetch.
     */
    where?: CourseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Courses to fetch.
     */
    orderBy?: CourseOrderByWithRelationInput | CourseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Courses.
     */
    cursor?: CourseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Courses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Courses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Courses.
     */
    distinct?: CourseScalarFieldEnum | CourseScalarFieldEnum[]
  }

  /**
   * Course findMany
   */
  export type CourseFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    /**
     * Filter, which Courses to fetch.
     */
    where?: CourseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Courses to fetch.
     */
    orderBy?: CourseOrderByWithRelationInput | CourseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Courses.
     */
    cursor?: CourseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Courses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Courses.
     */
    skip?: number
    distinct?: CourseScalarFieldEnum | CourseScalarFieldEnum[]
  }

  /**
   * Course create
   */
  export type CourseCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    /**
     * The data needed to create a Course.
     */
    data: XOR<CourseCreateInput, CourseUncheckedCreateInput>
  }

  /**
   * Course createMany
   */
  export type CourseCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Courses.
     */
    data: CourseCreateManyInput | CourseCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Course update
   */
  export type CourseUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    /**
     * The data needed to update a Course.
     */
    data: XOR<CourseUpdateInput, CourseUncheckedUpdateInput>
    /**
     * Choose, which Course to update.
     */
    where: CourseWhereUniqueInput
  }

  /**
   * Course updateMany
   */
  export type CourseUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Courses.
     */
    data: XOR<CourseUpdateManyMutationInput, CourseUncheckedUpdateManyInput>
    /**
     * Filter which Courses to update
     */
    where?: CourseWhereInput
  }

  /**
   * Course upsert
   */
  export type CourseUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    /**
     * The filter to search for the Course to update in case it exists.
     */
    where: CourseWhereUniqueInput
    /**
     * In case the Course found by the `where` argument doesn't exist, create a new Course with this data.
     */
    create: XOR<CourseCreateInput, CourseUncheckedCreateInput>
    /**
     * In case the Course was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CourseUpdateInput, CourseUncheckedUpdateInput>
  }

  /**
   * Course delete
   */
  export type CourseDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    /**
     * Filter which Course to delete.
     */
    where: CourseWhereUniqueInput
  }

  /**
   * Course deleteMany
   */
  export type CourseDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Courses to delete
     */
    where?: CourseWhereInput
  }

  /**
   * Course.department
   */
  export type Course$departmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    where?: DepartmentWhereInput
  }

  /**
   * Course.process
   */
  export type Course$processArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Process
     */
    select?: ProcessSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessInclude<ExtArgs> | null
    where?: ProcessWhereInput
  }

  /**
   * Course.enrollments
   */
  export type Course$enrollmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Enrollment
     */
    select?: EnrollmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnrollmentInclude<ExtArgs> | null
    where?: EnrollmentWhereInput
    orderBy?: EnrollmentOrderByWithRelationInput | EnrollmentOrderByWithRelationInput[]
    cursor?: EnrollmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EnrollmentScalarFieldEnum | EnrollmentScalarFieldEnum[]
  }

  /**
   * Course.files
   */
  export type Course$filesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileInclude<ExtArgs> | null
    where?: FileWhereInput
    orderBy?: FileOrderByWithRelationInput | FileOrderByWithRelationInput[]
    cursor?: FileWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FileScalarFieldEnum | FileScalarFieldEnum[]
  }

  /**
   * Course.exams
   */
  export type Course$examsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exam
     */
    select?: ExamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamInclude<ExtArgs> | null
    where?: ExamWhereInput
    orderBy?: ExamOrderByWithRelationInput | ExamOrderByWithRelationInput[]
    cursor?: ExamWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ExamScalarFieldEnum | ExamScalarFieldEnum[]
  }

  /**
   * Course.completions
   */
  export type Course$completionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCourseCompletion
     */
    select?: UserCourseCompletionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserCourseCompletionInclude<ExtArgs> | null
    where?: UserCourseCompletionWhereInput
    orderBy?: UserCourseCompletionOrderByWithRelationInput | UserCourseCompletionOrderByWithRelationInput[]
    cursor?: UserCourseCompletionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserCourseCompletionScalarFieldEnum | UserCourseCompletionScalarFieldEnum[]
  }

  /**
   * Course.deleter
   */
  export type Course$deleterArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Course without action
   */
  export type CourseDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
  }


  /**
   * Model UserCourseCompletion
   */

  export type AggregateUserCourseCompletion = {
    _count: UserCourseCompletionCountAggregateOutputType | null
    _avg: UserCourseCompletionAvgAggregateOutputType | null
    _sum: UserCourseCompletionSumAggregateOutputType | null
    _min: UserCourseCompletionMinAggregateOutputType | null
    _max: UserCourseCompletionMaxAggregateOutputType | null
  }

  export type UserCourseCompletionAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    courseId: number | null
    examId: number | null
    processId: number | null
  }

  export type UserCourseCompletionSumAggregateOutputType = {
    id: number | null
    userId: number | null
    courseId: number | null
    examId: number | null
    processId: number | null
  }

  export type UserCourseCompletionMinAggregateOutputType = {
    id: number | null
    userId: number | null
    username: string | null
    courseId: number | null
    examId: number | null
    processId: number | null
    completedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCourseCompletionMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    username: string | null
    courseId: number | null
    examId: number | null
    processId: number | null
    completedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCourseCompletionCountAggregateOutputType = {
    id: number
    userId: number
    username: number
    courseId: number
    examId: number
    processId: number
    completedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserCourseCompletionAvgAggregateInputType = {
    id?: true
    userId?: true
    courseId?: true
    examId?: true
    processId?: true
  }

  export type UserCourseCompletionSumAggregateInputType = {
    id?: true
    userId?: true
    courseId?: true
    examId?: true
    processId?: true
  }

  export type UserCourseCompletionMinAggregateInputType = {
    id?: true
    userId?: true
    username?: true
    courseId?: true
    examId?: true
    processId?: true
    completedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCourseCompletionMaxAggregateInputType = {
    id?: true
    userId?: true
    username?: true
    courseId?: true
    examId?: true
    processId?: true
    completedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCourseCompletionCountAggregateInputType = {
    id?: true
    userId?: true
    username?: true
    courseId?: true
    examId?: true
    processId?: true
    completedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserCourseCompletionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserCourseCompletion to aggregate.
     */
    where?: UserCourseCompletionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserCourseCompletions to fetch.
     */
    orderBy?: UserCourseCompletionOrderByWithRelationInput | UserCourseCompletionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserCourseCompletionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserCourseCompletions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserCourseCompletions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserCourseCompletions
    **/
    _count?: true | UserCourseCompletionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserCourseCompletionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserCourseCompletionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserCourseCompletionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserCourseCompletionMaxAggregateInputType
  }

  export type GetUserCourseCompletionAggregateType<T extends UserCourseCompletionAggregateArgs> = {
        [P in keyof T & keyof AggregateUserCourseCompletion]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserCourseCompletion[P]>
      : GetScalarType<T[P], AggregateUserCourseCompletion[P]>
  }




  export type UserCourseCompletionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserCourseCompletionWhereInput
    orderBy?: UserCourseCompletionOrderByWithAggregationInput | UserCourseCompletionOrderByWithAggregationInput[]
    by: UserCourseCompletionScalarFieldEnum[] | UserCourseCompletionScalarFieldEnum
    having?: UserCourseCompletionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCourseCompletionCountAggregateInputType | true
    _avg?: UserCourseCompletionAvgAggregateInputType
    _sum?: UserCourseCompletionSumAggregateInputType
    _min?: UserCourseCompletionMinAggregateInputType
    _max?: UserCourseCompletionMaxAggregateInputType
  }

  export type UserCourseCompletionGroupByOutputType = {
    id: number
    userId: number
    username: string
    courseId: number
    examId: number
    processId: number
    completedAt: Date
    createdAt: Date
    updatedAt: Date
    _count: UserCourseCompletionCountAggregateOutputType | null
    _avg: UserCourseCompletionAvgAggregateOutputType | null
    _sum: UserCourseCompletionSumAggregateOutputType | null
    _min: UserCourseCompletionMinAggregateOutputType | null
    _max: UserCourseCompletionMaxAggregateOutputType | null
  }

  type GetUserCourseCompletionGroupByPayload<T extends UserCourseCompletionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserCourseCompletionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserCourseCompletionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserCourseCompletionGroupByOutputType[P]>
            : GetScalarType<T[P], UserCourseCompletionGroupByOutputType[P]>
        }
      >
    >


  export type UserCourseCompletionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    username?: boolean
    courseId?: boolean
    examId?: boolean
    processId?: boolean
    completedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    course?: boolean | CourseDefaultArgs<ExtArgs>
    exam?: boolean | ExamDefaultArgs<ExtArgs>
    process?: boolean | ProcessDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userCourseCompletion"]>


  export type UserCourseCompletionSelectScalar = {
    id?: boolean
    userId?: boolean
    username?: boolean
    courseId?: boolean
    examId?: boolean
    processId?: boolean
    completedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserCourseCompletionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    course?: boolean | CourseDefaultArgs<ExtArgs>
    exam?: boolean | ExamDefaultArgs<ExtArgs>
    process?: boolean | ProcessDefaultArgs<ExtArgs>
  }

  export type $UserCourseCompletionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserCourseCompletion"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      course: Prisma.$CoursePayload<ExtArgs>
      exam: Prisma.$ExamPayload<ExtArgs>
      process: Prisma.$ProcessPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      username: string
      courseId: number
      examId: number
      processId: number
      completedAt: Date
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["userCourseCompletion"]>
    composites: {}
  }

  type UserCourseCompletionGetPayload<S extends boolean | null | undefined | UserCourseCompletionDefaultArgs> = $Result.GetResult<Prisma.$UserCourseCompletionPayload, S>

  type UserCourseCompletionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserCourseCompletionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserCourseCompletionCountAggregateInputType | true
    }

  export interface UserCourseCompletionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserCourseCompletion'], meta: { name: 'UserCourseCompletion' } }
    /**
     * Find zero or one UserCourseCompletion that matches the filter.
     * @param {UserCourseCompletionFindUniqueArgs} args - Arguments to find a UserCourseCompletion
     * @example
     * // Get one UserCourseCompletion
     * const userCourseCompletion = await prisma.userCourseCompletion.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserCourseCompletionFindUniqueArgs>(args: SelectSubset<T, UserCourseCompletionFindUniqueArgs<ExtArgs>>): Prisma__UserCourseCompletionClient<$Result.GetResult<Prisma.$UserCourseCompletionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one UserCourseCompletion that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserCourseCompletionFindUniqueOrThrowArgs} args - Arguments to find a UserCourseCompletion
     * @example
     * // Get one UserCourseCompletion
     * const userCourseCompletion = await prisma.userCourseCompletion.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserCourseCompletionFindUniqueOrThrowArgs>(args: SelectSubset<T, UserCourseCompletionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserCourseCompletionClient<$Result.GetResult<Prisma.$UserCourseCompletionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first UserCourseCompletion that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCourseCompletionFindFirstArgs} args - Arguments to find a UserCourseCompletion
     * @example
     * // Get one UserCourseCompletion
     * const userCourseCompletion = await prisma.userCourseCompletion.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserCourseCompletionFindFirstArgs>(args?: SelectSubset<T, UserCourseCompletionFindFirstArgs<ExtArgs>>): Prisma__UserCourseCompletionClient<$Result.GetResult<Prisma.$UserCourseCompletionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first UserCourseCompletion that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCourseCompletionFindFirstOrThrowArgs} args - Arguments to find a UserCourseCompletion
     * @example
     * // Get one UserCourseCompletion
     * const userCourseCompletion = await prisma.userCourseCompletion.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserCourseCompletionFindFirstOrThrowArgs>(args?: SelectSubset<T, UserCourseCompletionFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserCourseCompletionClient<$Result.GetResult<Prisma.$UserCourseCompletionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more UserCourseCompletions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCourseCompletionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserCourseCompletions
     * const userCourseCompletions = await prisma.userCourseCompletion.findMany()
     * 
     * // Get first 10 UserCourseCompletions
     * const userCourseCompletions = await prisma.userCourseCompletion.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userCourseCompletionWithIdOnly = await prisma.userCourseCompletion.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserCourseCompletionFindManyArgs>(args?: SelectSubset<T, UserCourseCompletionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserCourseCompletionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a UserCourseCompletion.
     * @param {UserCourseCompletionCreateArgs} args - Arguments to create a UserCourseCompletion.
     * @example
     * // Create one UserCourseCompletion
     * const UserCourseCompletion = await prisma.userCourseCompletion.create({
     *   data: {
     *     // ... data to create a UserCourseCompletion
     *   }
     * })
     * 
     */
    create<T extends UserCourseCompletionCreateArgs>(args: SelectSubset<T, UserCourseCompletionCreateArgs<ExtArgs>>): Prisma__UserCourseCompletionClient<$Result.GetResult<Prisma.$UserCourseCompletionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many UserCourseCompletions.
     * @param {UserCourseCompletionCreateManyArgs} args - Arguments to create many UserCourseCompletions.
     * @example
     * // Create many UserCourseCompletions
     * const userCourseCompletion = await prisma.userCourseCompletion.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCourseCompletionCreateManyArgs>(args?: SelectSubset<T, UserCourseCompletionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a UserCourseCompletion.
     * @param {UserCourseCompletionDeleteArgs} args - Arguments to delete one UserCourseCompletion.
     * @example
     * // Delete one UserCourseCompletion
     * const UserCourseCompletion = await prisma.userCourseCompletion.delete({
     *   where: {
     *     // ... filter to delete one UserCourseCompletion
     *   }
     * })
     * 
     */
    delete<T extends UserCourseCompletionDeleteArgs>(args: SelectSubset<T, UserCourseCompletionDeleteArgs<ExtArgs>>): Prisma__UserCourseCompletionClient<$Result.GetResult<Prisma.$UserCourseCompletionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one UserCourseCompletion.
     * @param {UserCourseCompletionUpdateArgs} args - Arguments to update one UserCourseCompletion.
     * @example
     * // Update one UserCourseCompletion
     * const userCourseCompletion = await prisma.userCourseCompletion.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserCourseCompletionUpdateArgs>(args: SelectSubset<T, UserCourseCompletionUpdateArgs<ExtArgs>>): Prisma__UserCourseCompletionClient<$Result.GetResult<Prisma.$UserCourseCompletionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more UserCourseCompletions.
     * @param {UserCourseCompletionDeleteManyArgs} args - Arguments to filter UserCourseCompletions to delete.
     * @example
     * // Delete a few UserCourseCompletions
     * const { count } = await prisma.userCourseCompletion.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserCourseCompletionDeleteManyArgs>(args?: SelectSubset<T, UserCourseCompletionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserCourseCompletions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCourseCompletionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserCourseCompletions
     * const userCourseCompletion = await prisma.userCourseCompletion.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserCourseCompletionUpdateManyArgs>(args: SelectSubset<T, UserCourseCompletionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UserCourseCompletion.
     * @param {UserCourseCompletionUpsertArgs} args - Arguments to update or create a UserCourseCompletion.
     * @example
     * // Update or create a UserCourseCompletion
     * const userCourseCompletion = await prisma.userCourseCompletion.upsert({
     *   create: {
     *     // ... data to create a UserCourseCompletion
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserCourseCompletion we want to update
     *   }
     * })
     */
    upsert<T extends UserCourseCompletionUpsertArgs>(args: SelectSubset<T, UserCourseCompletionUpsertArgs<ExtArgs>>): Prisma__UserCourseCompletionClient<$Result.GetResult<Prisma.$UserCourseCompletionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of UserCourseCompletions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCourseCompletionCountArgs} args - Arguments to filter UserCourseCompletions to count.
     * @example
     * // Count the number of UserCourseCompletions
     * const count = await prisma.userCourseCompletion.count({
     *   where: {
     *     // ... the filter for the UserCourseCompletions we want to count
     *   }
     * })
    **/
    count<T extends UserCourseCompletionCountArgs>(
      args?: Subset<T, UserCourseCompletionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCourseCompletionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserCourseCompletion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCourseCompletionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserCourseCompletionAggregateArgs>(args: Subset<T, UserCourseCompletionAggregateArgs>): Prisma.PrismaPromise<GetUserCourseCompletionAggregateType<T>>

    /**
     * Group by UserCourseCompletion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCourseCompletionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserCourseCompletionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserCourseCompletionGroupByArgs['orderBy'] }
        : { orderBy?: UserCourseCompletionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserCourseCompletionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserCourseCompletionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserCourseCompletion model
   */
  readonly fields: UserCourseCompletionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserCourseCompletion.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserCourseCompletionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    course<T extends CourseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CourseDefaultArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    exam<T extends ExamDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ExamDefaultArgs<ExtArgs>>): Prisma__ExamClient<$Result.GetResult<Prisma.$ExamPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    process<T extends ProcessDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProcessDefaultArgs<ExtArgs>>): Prisma__ProcessClient<$Result.GetResult<Prisma.$ProcessPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserCourseCompletion model
   */ 
  interface UserCourseCompletionFieldRefs {
    readonly id: FieldRef<"UserCourseCompletion", 'Int'>
    readonly userId: FieldRef<"UserCourseCompletion", 'Int'>
    readonly username: FieldRef<"UserCourseCompletion", 'String'>
    readonly courseId: FieldRef<"UserCourseCompletion", 'Int'>
    readonly examId: FieldRef<"UserCourseCompletion", 'Int'>
    readonly processId: FieldRef<"UserCourseCompletion", 'Int'>
    readonly completedAt: FieldRef<"UserCourseCompletion", 'DateTime'>
    readonly createdAt: FieldRef<"UserCourseCompletion", 'DateTime'>
    readonly updatedAt: FieldRef<"UserCourseCompletion", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserCourseCompletion findUnique
   */
  export type UserCourseCompletionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCourseCompletion
     */
    select?: UserCourseCompletionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserCourseCompletionInclude<ExtArgs> | null
    /**
     * Filter, which UserCourseCompletion to fetch.
     */
    where: UserCourseCompletionWhereUniqueInput
  }

  /**
   * UserCourseCompletion findUniqueOrThrow
   */
  export type UserCourseCompletionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCourseCompletion
     */
    select?: UserCourseCompletionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserCourseCompletionInclude<ExtArgs> | null
    /**
     * Filter, which UserCourseCompletion to fetch.
     */
    where: UserCourseCompletionWhereUniqueInput
  }

  /**
   * UserCourseCompletion findFirst
   */
  export type UserCourseCompletionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCourseCompletion
     */
    select?: UserCourseCompletionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserCourseCompletionInclude<ExtArgs> | null
    /**
     * Filter, which UserCourseCompletion to fetch.
     */
    where?: UserCourseCompletionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserCourseCompletions to fetch.
     */
    orderBy?: UserCourseCompletionOrderByWithRelationInput | UserCourseCompletionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserCourseCompletions.
     */
    cursor?: UserCourseCompletionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserCourseCompletions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserCourseCompletions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserCourseCompletions.
     */
    distinct?: UserCourseCompletionScalarFieldEnum | UserCourseCompletionScalarFieldEnum[]
  }

  /**
   * UserCourseCompletion findFirstOrThrow
   */
  export type UserCourseCompletionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCourseCompletion
     */
    select?: UserCourseCompletionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserCourseCompletionInclude<ExtArgs> | null
    /**
     * Filter, which UserCourseCompletion to fetch.
     */
    where?: UserCourseCompletionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserCourseCompletions to fetch.
     */
    orderBy?: UserCourseCompletionOrderByWithRelationInput | UserCourseCompletionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserCourseCompletions.
     */
    cursor?: UserCourseCompletionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserCourseCompletions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserCourseCompletions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserCourseCompletions.
     */
    distinct?: UserCourseCompletionScalarFieldEnum | UserCourseCompletionScalarFieldEnum[]
  }

  /**
   * UserCourseCompletion findMany
   */
  export type UserCourseCompletionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCourseCompletion
     */
    select?: UserCourseCompletionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserCourseCompletionInclude<ExtArgs> | null
    /**
     * Filter, which UserCourseCompletions to fetch.
     */
    where?: UserCourseCompletionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserCourseCompletions to fetch.
     */
    orderBy?: UserCourseCompletionOrderByWithRelationInput | UserCourseCompletionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserCourseCompletions.
     */
    cursor?: UserCourseCompletionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserCourseCompletions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserCourseCompletions.
     */
    skip?: number
    distinct?: UserCourseCompletionScalarFieldEnum | UserCourseCompletionScalarFieldEnum[]
  }

  /**
   * UserCourseCompletion create
   */
  export type UserCourseCompletionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCourseCompletion
     */
    select?: UserCourseCompletionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserCourseCompletionInclude<ExtArgs> | null
    /**
     * The data needed to create a UserCourseCompletion.
     */
    data: XOR<UserCourseCompletionCreateInput, UserCourseCompletionUncheckedCreateInput>
  }

  /**
   * UserCourseCompletion createMany
   */
  export type UserCourseCompletionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserCourseCompletions.
     */
    data: UserCourseCompletionCreateManyInput | UserCourseCompletionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserCourseCompletion update
   */
  export type UserCourseCompletionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCourseCompletion
     */
    select?: UserCourseCompletionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserCourseCompletionInclude<ExtArgs> | null
    /**
     * The data needed to update a UserCourseCompletion.
     */
    data: XOR<UserCourseCompletionUpdateInput, UserCourseCompletionUncheckedUpdateInput>
    /**
     * Choose, which UserCourseCompletion to update.
     */
    where: UserCourseCompletionWhereUniqueInput
  }

  /**
   * UserCourseCompletion updateMany
   */
  export type UserCourseCompletionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserCourseCompletions.
     */
    data: XOR<UserCourseCompletionUpdateManyMutationInput, UserCourseCompletionUncheckedUpdateManyInput>
    /**
     * Filter which UserCourseCompletions to update
     */
    where?: UserCourseCompletionWhereInput
  }

  /**
   * UserCourseCompletion upsert
   */
  export type UserCourseCompletionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCourseCompletion
     */
    select?: UserCourseCompletionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserCourseCompletionInclude<ExtArgs> | null
    /**
     * The filter to search for the UserCourseCompletion to update in case it exists.
     */
    where: UserCourseCompletionWhereUniqueInput
    /**
     * In case the UserCourseCompletion found by the `where` argument doesn't exist, create a new UserCourseCompletion with this data.
     */
    create: XOR<UserCourseCompletionCreateInput, UserCourseCompletionUncheckedCreateInput>
    /**
     * In case the UserCourseCompletion was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserCourseCompletionUpdateInput, UserCourseCompletionUncheckedUpdateInput>
  }

  /**
   * UserCourseCompletion delete
   */
  export type UserCourseCompletionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCourseCompletion
     */
    select?: UserCourseCompletionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserCourseCompletionInclude<ExtArgs> | null
    /**
     * Filter which UserCourseCompletion to delete.
     */
    where: UserCourseCompletionWhereUniqueInput
  }

  /**
   * UserCourseCompletion deleteMany
   */
  export type UserCourseCompletionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserCourseCompletions to delete
     */
    where?: UserCourseCompletionWhereInput
  }

  /**
   * UserCourseCompletion without action
   */
  export type UserCourseCompletionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCourseCompletion
     */
    select?: UserCourseCompletionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserCourseCompletionInclude<ExtArgs> | null
  }


  /**
   * Model courseType
   */

  export type AggregateCourseType = {
    _count: CourseTypeCountAggregateOutputType | null
    _avg: CourseTypeAvgAggregateOutputType | null
    _sum: CourseTypeSumAggregateOutputType | null
    _min: CourseTypeMinAggregateOutputType | null
    _max: CourseTypeMaxAggregateOutputType | null
  }

  export type CourseTypeAvgAggregateOutputType = {
    id: number | null
  }

  export type CourseTypeSumAggregateOutputType = {
    id: number | null
  }

  export type CourseTypeMinAggregateOutputType = {
    id: number | null
    title: string | null
  }

  export type CourseTypeMaxAggregateOutputType = {
    id: number | null
    title: string | null
  }

  export type CourseTypeCountAggregateOutputType = {
    id: number
    title: number
    _all: number
  }


  export type CourseTypeAvgAggregateInputType = {
    id?: true
  }

  export type CourseTypeSumAggregateInputType = {
    id?: true
  }

  export type CourseTypeMinAggregateInputType = {
    id?: true
    title?: true
  }

  export type CourseTypeMaxAggregateInputType = {
    id?: true
    title?: true
  }

  export type CourseTypeCountAggregateInputType = {
    id?: true
    title?: true
    _all?: true
  }

  export type CourseTypeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which courseType to aggregate.
     */
    where?: courseTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of courseTypes to fetch.
     */
    orderBy?: courseTypeOrderByWithRelationInput | courseTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: courseTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` courseTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` courseTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned courseTypes
    **/
    _count?: true | CourseTypeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CourseTypeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CourseTypeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CourseTypeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CourseTypeMaxAggregateInputType
  }

  export type GetCourseTypeAggregateType<T extends CourseTypeAggregateArgs> = {
        [P in keyof T & keyof AggregateCourseType]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCourseType[P]>
      : GetScalarType<T[P], AggregateCourseType[P]>
  }




  export type courseTypeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: courseTypeWhereInput
    orderBy?: courseTypeOrderByWithAggregationInput | courseTypeOrderByWithAggregationInput[]
    by: CourseTypeScalarFieldEnum[] | CourseTypeScalarFieldEnum
    having?: courseTypeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CourseTypeCountAggregateInputType | true
    _avg?: CourseTypeAvgAggregateInputType
    _sum?: CourseTypeSumAggregateInputType
    _min?: CourseTypeMinAggregateInputType
    _max?: CourseTypeMaxAggregateInputType
  }

  export type CourseTypeGroupByOutputType = {
    id: number
    title: string
    _count: CourseTypeCountAggregateOutputType | null
    _avg: CourseTypeAvgAggregateOutputType | null
    _sum: CourseTypeSumAggregateOutputType | null
    _min: CourseTypeMinAggregateOutputType | null
    _max: CourseTypeMaxAggregateOutputType | null
  }

  type GetCourseTypeGroupByPayload<T extends courseTypeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CourseTypeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CourseTypeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CourseTypeGroupByOutputType[P]>
            : GetScalarType<T[P], CourseTypeGroupByOutputType[P]>
        }
      >
    >


  export type courseTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
  }, ExtArgs["result"]["courseType"]>


  export type courseTypeSelectScalar = {
    id?: boolean
    title?: boolean
  }


  export type $courseTypePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "courseType"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      title: string
    }, ExtArgs["result"]["courseType"]>
    composites: {}
  }

  type courseTypeGetPayload<S extends boolean | null | undefined | courseTypeDefaultArgs> = $Result.GetResult<Prisma.$courseTypePayload, S>

  type courseTypeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<courseTypeFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CourseTypeCountAggregateInputType | true
    }

  export interface courseTypeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['courseType'], meta: { name: 'courseType' } }
    /**
     * Find zero or one CourseType that matches the filter.
     * @param {courseTypeFindUniqueArgs} args - Arguments to find a CourseType
     * @example
     * // Get one CourseType
     * const courseType = await prisma.courseType.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends courseTypeFindUniqueArgs>(args: SelectSubset<T, courseTypeFindUniqueArgs<ExtArgs>>): Prisma__courseTypeClient<$Result.GetResult<Prisma.$courseTypePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one CourseType that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {courseTypeFindUniqueOrThrowArgs} args - Arguments to find a CourseType
     * @example
     * // Get one CourseType
     * const courseType = await prisma.courseType.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends courseTypeFindUniqueOrThrowArgs>(args: SelectSubset<T, courseTypeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__courseTypeClient<$Result.GetResult<Prisma.$courseTypePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first CourseType that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {courseTypeFindFirstArgs} args - Arguments to find a CourseType
     * @example
     * // Get one CourseType
     * const courseType = await prisma.courseType.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends courseTypeFindFirstArgs>(args?: SelectSubset<T, courseTypeFindFirstArgs<ExtArgs>>): Prisma__courseTypeClient<$Result.GetResult<Prisma.$courseTypePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first CourseType that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {courseTypeFindFirstOrThrowArgs} args - Arguments to find a CourseType
     * @example
     * // Get one CourseType
     * const courseType = await prisma.courseType.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends courseTypeFindFirstOrThrowArgs>(args?: SelectSubset<T, courseTypeFindFirstOrThrowArgs<ExtArgs>>): Prisma__courseTypeClient<$Result.GetResult<Prisma.$courseTypePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more CourseTypes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {courseTypeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CourseTypes
     * const courseTypes = await prisma.courseType.findMany()
     * 
     * // Get first 10 CourseTypes
     * const courseTypes = await prisma.courseType.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const courseTypeWithIdOnly = await prisma.courseType.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends courseTypeFindManyArgs>(args?: SelectSubset<T, courseTypeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$courseTypePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a CourseType.
     * @param {courseTypeCreateArgs} args - Arguments to create a CourseType.
     * @example
     * // Create one CourseType
     * const CourseType = await prisma.courseType.create({
     *   data: {
     *     // ... data to create a CourseType
     *   }
     * })
     * 
     */
    create<T extends courseTypeCreateArgs>(args: SelectSubset<T, courseTypeCreateArgs<ExtArgs>>): Prisma__courseTypeClient<$Result.GetResult<Prisma.$courseTypePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many CourseTypes.
     * @param {courseTypeCreateManyArgs} args - Arguments to create many CourseTypes.
     * @example
     * // Create many CourseTypes
     * const courseType = await prisma.courseType.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends courseTypeCreateManyArgs>(args?: SelectSubset<T, courseTypeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a CourseType.
     * @param {courseTypeDeleteArgs} args - Arguments to delete one CourseType.
     * @example
     * // Delete one CourseType
     * const CourseType = await prisma.courseType.delete({
     *   where: {
     *     // ... filter to delete one CourseType
     *   }
     * })
     * 
     */
    delete<T extends courseTypeDeleteArgs>(args: SelectSubset<T, courseTypeDeleteArgs<ExtArgs>>): Prisma__courseTypeClient<$Result.GetResult<Prisma.$courseTypePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one CourseType.
     * @param {courseTypeUpdateArgs} args - Arguments to update one CourseType.
     * @example
     * // Update one CourseType
     * const courseType = await prisma.courseType.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends courseTypeUpdateArgs>(args: SelectSubset<T, courseTypeUpdateArgs<ExtArgs>>): Prisma__courseTypeClient<$Result.GetResult<Prisma.$courseTypePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more CourseTypes.
     * @param {courseTypeDeleteManyArgs} args - Arguments to filter CourseTypes to delete.
     * @example
     * // Delete a few CourseTypes
     * const { count } = await prisma.courseType.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends courseTypeDeleteManyArgs>(args?: SelectSubset<T, courseTypeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CourseTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {courseTypeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CourseTypes
     * const courseType = await prisma.courseType.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends courseTypeUpdateManyArgs>(args: SelectSubset<T, courseTypeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CourseType.
     * @param {courseTypeUpsertArgs} args - Arguments to update or create a CourseType.
     * @example
     * // Update or create a CourseType
     * const courseType = await prisma.courseType.upsert({
     *   create: {
     *     // ... data to create a CourseType
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CourseType we want to update
     *   }
     * })
     */
    upsert<T extends courseTypeUpsertArgs>(args: SelectSubset<T, courseTypeUpsertArgs<ExtArgs>>): Prisma__courseTypeClient<$Result.GetResult<Prisma.$courseTypePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of CourseTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {courseTypeCountArgs} args - Arguments to filter CourseTypes to count.
     * @example
     * // Count the number of CourseTypes
     * const count = await prisma.courseType.count({
     *   where: {
     *     // ... the filter for the CourseTypes we want to count
     *   }
     * })
    **/
    count<T extends courseTypeCountArgs>(
      args?: Subset<T, courseTypeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CourseTypeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CourseType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseTypeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CourseTypeAggregateArgs>(args: Subset<T, CourseTypeAggregateArgs>): Prisma.PrismaPromise<GetCourseTypeAggregateType<T>>

    /**
     * Group by CourseType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {courseTypeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends courseTypeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: courseTypeGroupByArgs['orderBy'] }
        : { orderBy?: courseTypeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, courseTypeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCourseTypeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the courseType model
   */
  readonly fields: courseTypeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for courseType.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__courseTypeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the courseType model
   */ 
  interface courseTypeFieldRefs {
    readonly id: FieldRef<"courseType", 'Int'>
    readonly title: FieldRef<"courseType", 'String'>
  }
    

  // Custom InputTypes
  /**
   * courseType findUnique
   */
  export type courseTypeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the courseType
     */
    select?: courseTypeSelect<ExtArgs> | null
    /**
     * Filter, which courseType to fetch.
     */
    where: courseTypeWhereUniqueInput
  }

  /**
   * courseType findUniqueOrThrow
   */
  export type courseTypeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the courseType
     */
    select?: courseTypeSelect<ExtArgs> | null
    /**
     * Filter, which courseType to fetch.
     */
    where: courseTypeWhereUniqueInput
  }

  /**
   * courseType findFirst
   */
  export type courseTypeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the courseType
     */
    select?: courseTypeSelect<ExtArgs> | null
    /**
     * Filter, which courseType to fetch.
     */
    where?: courseTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of courseTypes to fetch.
     */
    orderBy?: courseTypeOrderByWithRelationInput | courseTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for courseTypes.
     */
    cursor?: courseTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` courseTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` courseTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of courseTypes.
     */
    distinct?: CourseTypeScalarFieldEnum | CourseTypeScalarFieldEnum[]
  }

  /**
   * courseType findFirstOrThrow
   */
  export type courseTypeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the courseType
     */
    select?: courseTypeSelect<ExtArgs> | null
    /**
     * Filter, which courseType to fetch.
     */
    where?: courseTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of courseTypes to fetch.
     */
    orderBy?: courseTypeOrderByWithRelationInput | courseTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for courseTypes.
     */
    cursor?: courseTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` courseTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` courseTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of courseTypes.
     */
    distinct?: CourseTypeScalarFieldEnum | CourseTypeScalarFieldEnum[]
  }

  /**
   * courseType findMany
   */
  export type courseTypeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the courseType
     */
    select?: courseTypeSelect<ExtArgs> | null
    /**
     * Filter, which courseTypes to fetch.
     */
    where?: courseTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of courseTypes to fetch.
     */
    orderBy?: courseTypeOrderByWithRelationInput | courseTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing courseTypes.
     */
    cursor?: courseTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` courseTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` courseTypes.
     */
    skip?: number
    distinct?: CourseTypeScalarFieldEnum | CourseTypeScalarFieldEnum[]
  }

  /**
   * courseType create
   */
  export type courseTypeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the courseType
     */
    select?: courseTypeSelect<ExtArgs> | null
    /**
     * The data needed to create a courseType.
     */
    data: XOR<courseTypeCreateInput, courseTypeUncheckedCreateInput>
  }

  /**
   * courseType createMany
   */
  export type courseTypeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many courseTypes.
     */
    data: courseTypeCreateManyInput | courseTypeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * courseType update
   */
  export type courseTypeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the courseType
     */
    select?: courseTypeSelect<ExtArgs> | null
    /**
     * The data needed to update a courseType.
     */
    data: XOR<courseTypeUpdateInput, courseTypeUncheckedUpdateInput>
    /**
     * Choose, which courseType to update.
     */
    where: courseTypeWhereUniqueInput
  }

  /**
   * courseType updateMany
   */
  export type courseTypeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update courseTypes.
     */
    data: XOR<courseTypeUpdateManyMutationInput, courseTypeUncheckedUpdateManyInput>
    /**
     * Filter which courseTypes to update
     */
    where?: courseTypeWhereInput
  }

  /**
   * courseType upsert
   */
  export type courseTypeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the courseType
     */
    select?: courseTypeSelect<ExtArgs> | null
    /**
     * The filter to search for the courseType to update in case it exists.
     */
    where: courseTypeWhereUniqueInput
    /**
     * In case the courseType found by the `where` argument doesn't exist, create a new courseType with this data.
     */
    create: XOR<courseTypeCreateInput, courseTypeUncheckedCreateInput>
    /**
     * In case the courseType was found with the provided `where` argument, update it with this data.
     */
    update: XOR<courseTypeUpdateInput, courseTypeUncheckedUpdateInput>
  }

  /**
   * courseType delete
   */
  export type courseTypeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the courseType
     */
    select?: courseTypeSelect<ExtArgs> | null
    /**
     * Filter which courseType to delete.
     */
    where: courseTypeWhereUniqueInput
  }

  /**
   * courseType deleteMany
   */
  export type courseTypeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which courseTypes to delete
     */
    where?: courseTypeWhereInput
  }

  /**
   * courseType without action
   */
  export type courseTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the courseType
     */
    select?: courseTypeSelect<ExtArgs> | null
  }


  /**
   * Model Enrollment
   */

  export type AggregateEnrollment = {
    _count: EnrollmentCountAggregateOutputType | null
    _avg: EnrollmentAvgAggregateOutputType | null
    _sum: EnrollmentSumAggregateOutputType | null
    _min: EnrollmentMinAggregateOutputType | null
    _max: EnrollmentMaxAggregateOutputType | null
  }

  export type EnrollmentAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    courseId: number | null
    progress: number | null
    isDownloaded: number | null
  }

  export type EnrollmentSumAggregateOutputType = {
    id: number | null
    userId: number | null
    courseId: number | null
    progress: number | null
    isDownloaded: number | null
  }

  export type EnrollmentMinAggregateOutputType = {
    id: number | null
    userId: number | null
    courseId: number | null
    progress: number | null
    completed: boolean | null
    isDownloaded: number | null
  }

  export type EnrollmentMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    courseId: number | null
    progress: number | null
    completed: boolean | null
    isDownloaded: number | null
  }

  export type EnrollmentCountAggregateOutputType = {
    id: number
    userId: number
    courseId: number
    progress: number
    completed: number
    isDownloaded: number
    _all: number
  }


  export type EnrollmentAvgAggregateInputType = {
    id?: true
    userId?: true
    courseId?: true
    progress?: true
    isDownloaded?: true
  }

  export type EnrollmentSumAggregateInputType = {
    id?: true
    userId?: true
    courseId?: true
    progress?: true
    isDownloaded?: true
  }

  export type EnrollmentMinAggregateInputType = {
    id?: true
    userId?: true
    courseId?: true
    progress?: true
    completed?: true
    isDownloaded?: true
  }

  export type EnrollmentMaxAggregateInputType = {
    id?: true
    userId?: true
    courseId?: true
    progress?: true
    completed?: true
    isDownloaded?: true
  }

  export type EnrollmentCountAggregateInputType = {
    id?: true
    userId?: true
    courseId?: true
    progress?: true
    completed?: true
    isDownloaded?: true
    _all?: true
  }

  export type EnrollmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Enrollment to aggregate.
     */
    where?: EnrollmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Enrollments to fetch.
     */
    orderBy?: EnrollmentOrderByWithRelationInput | EnrollmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EnrollmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Enrollments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Enrollments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Enrollments
    **/
    _count?: true | EnrollmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EnrollmentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EnrollmentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EnrollmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EnrollmentMaxAggregateInputType
  }

  export type GetEnrollmentAggregateType<T extends EnrollmentAggregateArgs> = {
        [P in keyof T & keyof AggregateEnrollment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEnrollment[P]>
      : GetScalarType<T[P], AggregateEnrollment[P]>
  }




  export type EnrollmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EnrollmentWhereInput
    orderBy?: EnrollmentOrderByWithAggregationInput | EnrollmentOrderByWithAggregationInput[]
    by: EnrollmentScalarFieldEnum[] | EnrollmentScalarFieldEnum
    having?: EnrollmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EnrollmentCountAggregateInputType | true
    _avg?: EnrollmentAvgAggregateInputType
    _sum?: EnrollmentSumAggregateInputType
    _min?: EnrollmentMinAggregateInputType
    _max?: EnrollmentMaxAggregateInputType
  }

  export type EnrollmentGroupByOutputType = {
    id: number
    userId: number
    courseId: number
    progress: number
    completed: boolean
    isDownloaded: number
    _count: EnrollmentCountAggregateOutputType | null
    _avg: EnrollmentAvgAggregateOutputType | null
    _sum: EnrollmentSumAggregateOutputType | null
    _min: EnrollmentMinAggregateOutputType | null
    _max: EnrollmentMaxAggregateOutputType | null
  }

  type GetEnrollmentGroupByPayload<T extends EnrollmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EnrollmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EnrollmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EnrollmentGroupByOutputType[P]>
            : GetScalarType<T[P], EnrollmentGroupByOutputType[P]>
        }
      >
    >


  export type EnrollmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    courseId?: boolean
    progress?: boolean
    completed?: boolean
    isDownloaded?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    course?: boolean | CourseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["enrollment"]>


  export type EnrollmentSelectScalar = {
    id?: boolean
    userId?: boolean
    courseId?: boolean
    progress?: boolean
    completed?: boolean
    isDownloaded?: boolean
  }

  export type EnrollmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    course?: boolean | CourseDefaultArgs<ExtArgs>
  }

  export type $EnrollmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Enrollment"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      course: Prisma.$CoursePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      courseId: number
      progress: number
      completed: boolean
      isDownloaded: number
    }, ExtArgs["result"]["enrollment"]>
    composites: {}
  }

  type EnrollmentGetPayload<S extends boolean | null | undefined | EnrollmentDefaultArgs> = $Result.GetResult<Prisma.$EnrollmentPayload, S>

  type EnrollmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<EnrollmentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EnrollmentCountAggregateInputType | true
    }

  export interface EnrollmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Enrollment'], meta: { name: 'Enrollment' } }
    /**
     * Find zero or one Enrollment that matches the filter.
     * @param {EnrollmentFindUniqueArgs} args - Arguments to find a Enrollment
     * @example
     * // Get one Enrollment
     * const enrollment = await prisma.enrollment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EnrollmentFindUniqueArgs>(args: SelectSubset<T, EnrollmentFindUniqueArgs<ExtArgs>>): Prisma__EnrollmentClient<$Result.GetResult<Prisma.$EnrollmentPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Enrollment that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {EnrollmentFindUniqueOrThrowArgs} args - Arguments to find a Enrollment
     * @example
     * // Get one Enrollment
     * const enrollment = await prisma.enrollment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EnrollmentFindUniqueOrThrowArgs>(args: SelectSubset<T, EnrollmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EnrollmentClient<$Result.GetResult<Prisma.$EnrollmentPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Enrollment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnrollmentFindFirstArgs} args - Arguments to find a Enrollment
     * @example
     * // Get one Enrollment
     * const enrollment = await prisma.enrollment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EnrollmentFindFirstArgs>(args?: SelectSubset<T, EnrollmentFindFirstArgs<ExtArgs>>): Prisma__EnrollmentClient<$Result.GetResult<Prisma.$EnrollmentPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Enrollment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnrollmentFindFirstOrThrowArgs} args - Arguments to find a Enrollment
     * @example
     * // Get one Enrollment
     * const enrollment = await prisma.enrollment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EnrollmentFindFirstOrThrowArgs>(args?: SelectSubset<T, EnrollmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__EnrollmentClient<$Result.GetResult<Prisma.$EnrollmentPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Enrollments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnrollmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Enrollments
     * const enrollments = await prisma.enrollment.findMany()
     * 
     * // Get first 10 Enrollments
     * const enrollments = await prisma.enrollment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const enrollmentWithIdOnly = await prisma.enrollment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EnrollmentFindManyArgs>(args?: SelectSubset<T, EnrollmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EnrollmentPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Enrollment.
     * @param {EnrollmentCreateArgs} args - Arguments to create a Enrollment.
     * @example
     * // Create one Enrollment
     * const Enrollment = await prisma.enrollment.create({
     *   data: {
     *     // ... data to create a Enrollment
     *   }
     * })
     * 
     */
    create<T extends EnrollmentCreateArgs>(args: SelectSubset<T, EnrollmentCreateArgs<ExtArgs>>): Prisma__EnrollmentClient<$Result.GetResult<Prisma.$EnrollmentPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Enrollments.
     * @param {EnrollmentCreateManyArgs} args - Arguments to create many Enrollments.
     * @example
     * // Create many Enrollments
     * const enrollment = await prisma.enrollment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EnrollmentCreateManyArgs>(args?: SelectSubset<T, EnrollmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Enrollment.
     * @param {EnrollmentDeleteArgs} args - Arguments to delete one Enrollment.
     * @example
     * // Delete one Enrollment
     * const Enrollment = await prisma.enrollment.delete({
     *   where: {
     *     // ... filter to delete one Enrollment
     *   }
     * })
     * 
     */
    delete<T extends EnrollmentDeleteArgs>(args: SelectSubset<T, EnrollmentDeleteArgs<ExtArgs>>): Prisma__EnrollmentClient<$Result.GetResult<Prisma.$EnrollmentPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Enrollment.
     * @param {EnrollmentUpdateArgs} args - Arguments to update one Enrollment.
     * @example
     * // Update one Enrollment
     * const enrollment = await prisma.enrollment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EnrollmentUpdateArgs>(args: SelectSubset<T, EnrollmentUpdateArgs<ExtArgs>>): Prisma__EnrollmentClient<$Result.GetResult<Prisma.$EnrollmentPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Enrollments.
     * @param {EnrollmentDeleteManyArgs} args - Arguments to filter Enrollments to delete.
     * @example
     * // Delete a few Enrollments
     * const { count } = await prisma.enrollment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EnrollmentDeleteManyArgs>(args?: SelectSubset<T, EnrollmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Enrollments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnrollmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Enrollments
     * const enrollment = await prisma.enrollment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EnrollmentUpdateManyArgs>(args: SelectSubset<T, EnrollmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Enrollment.
     * @param {EnrollmentUpsertArgs} args - Arguments to update or create a Enrollment.
     * @example
     * // Update or create a Enrollment
     * const enrollment = await prisma.enrollment.upsert({
     *   create: {
     *     // ... data to create a Enrollment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Enrollment we want to update
     *   }
     * })
     */
    upsert<T extends EnrollmentUpsertArgs>(args: SelectSubset<T, EnrollmentUpsertArgs<ExtArgs>>): Prisma__EnrollmentClient<$Result.GetResult<Prisma.$EnrollmentPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Enrollments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnrollmentCountArgs} args - Arguments to filter Enrollments to count.
     * @example
     * // Count the number of Enrollments
     * const count = await prisma.enrollment.count({
     *   where: {
     *     // ... the filter for the Enrollments we want to count
     *   }
     * })
    **/
    count<T extends EnrollmentCountArgs>(
      args?: Subset<T, EnrollmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EnrollmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Enrollment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnrollmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EnrollmentAggregateArgs>(args: Subset<T, EnrollmentAggregateArgs>): Prisma.PrismaPromise<GetEnrollmentAggregateType<T>>

    /**
     * Group by Enrollment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnrollmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EnrollmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EnrollmentGroupByArgs['orderBy'] }
        : { orderBy?: EnrollmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EnrollmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEnrollmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Enrollment model
   */
  readonly fields: EnrollmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Enrollment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EnrollmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    course<T extends CourseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CourseDefaultArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Enrollment model
   */ 
  interface EnrollmentFieldRefs {
    readonly id: FieldRef<"Enrollment", 'Int'>
    readonly userId: FieldRef<"Enrollment", 'Int'>
    readonly courseId: FieldRef<"Enrollment", 'Int'>
    readonly progress: FieldRef<"Enrollment", 'Float'>
    readonly completed: FieldRef<"Enrollment", 'Boolean'>
    readonly isDownloaded: FieldRef<"Enrollment", 'Float'>
  }
    

  // Custom InputTypes
  /**
   * Enrollment findUnique
   */
  export type EnrollmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Enrollment
     */
    select?: EnrollmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnrollmentInclude<ExtArgs> | null
    /**
     * Filter, which Enrollment to fetch.
     */
    where: EnrollmentWhereUniqueInput
  }

  /**
   * Enrollment findUniqueOrThrow
   */
  export type EnrollmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Enrollment
     */
    select?: EnrollmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnrollmentInclude<ExtArgs> | null
    /**
     * Filter, which Enrollment to fetch.
     */
    where: EnrollmentWhereUniqueInput
  }

  /**
   * Enrollment findFirst
   */
  export type EnrollmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Enrollment
     */
    select?: EnrollmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnrollmentInclude<ExtArgs> | null
    /**
     * Filter, which Enrollment to fetch.
     */
    where?: EnrollmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Enrollments to fetch.
     */
    orderBy?: EnrollmentOrderByWithRelationInput | EnrollmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Enrollments.
     */
    cursor?: EnrollmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Enrollments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Enrollments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Enrollments.
     */
    distinct?: EnrollmentScalarFieldEnum | EnrollmentScalarFieldEnum[]
  }

  /**
   * Enrollment findFirstOrThrow
   */
  export type EnrollmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Enrollment
     */
    select?: EnrollmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnrollmentInclude<ExtArgs> | null
    /**
     * Filter, which Enrollment to fetch.
     */
    where?: EnrollmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Enrollments to fetch.
     */
    orderBy?: EnrollmentOrderByWithRelationInput | EnrollmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Enrollments.
     */
    cursor?: EnrollmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Enrollments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Enrollments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Enrollments.
     */
    distinct?: EnrollmentScalarFieldEnum | EnrollmentScalarFieldEnum[]
  }

  /**
   * Enrollment findMany
   */
  export type EnrollmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Enrollment
     */
    select?: EnrollmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnrollmentInclude<ExtArgs> | null
    /**
     * Filter, which Enrollments to fetch.
     */
    where?: EnrollmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Enrollments to fetch.
     */
    orderBy?: EnrollmentOrderByWithRelationInput | EnrollmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Enrollments.
     */
    cursor?: EnrollmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Enrollments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Enrollments.
     */
    skip?: number
    distinct?: EnrollmentScalarFieldEnum | EnrollmentScalarFieldEnum[]
  }

  /**
   * Enrollment create
   */
  export type EnrollmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Enrollment
     */
    select?: EnrollmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnrollmentInclude<ExtArgs> | null
    /**
     * The data needed to create a Enrollment.
     */
    data: XOR<EnrollmentCreateInput, EnrollmentUncheckedCreateInput>
  }

  /**
   * Enrollment createMany
   */
  export type EnrollmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Enrollments.
     */
    data: EnrollmentCreateManyInput | EnrollmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Enrollment update
   */
  export type EnrollmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Enrollment
     */
    select?: EnrollmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnrollmentInclude<ExtArgs> | null
    /**
     * The data needed to update a Enrollment.
     */
    data: XOR<EnrollmentUpdateInput, EnrollmentUncheckedUpdateInput>
    /**
     * Choose, which Enrollment to update.
     */
    where: EnrollmentWhereUniqueInput
  }

  /**
   * Enrollment updateMany
   */
  export type EnrollmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Enrollments.
     */
    data: XOR<EnrollmentUpdateManyMutationInput, EnrollmentUncheckedUpdateManyInput>
    /**
     * Filter which Enrollments to update
     */
    where?: EnrollmentWhereInput
  }

  /**
   * Enrollment upsert
   */
  export type EnrollmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Enrollment
     */
    select?: EnrollmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnrollmentInclude<ExtArgs> | null
    /**
     * The filter to search for the Enrollment to update in case it exists.
     */
    where: EnrollmentWhereUniqueInput
    /**
     * In case the Enrollment found by the `where` argument doesn't exist, create a new Enrollment with this data.
     */
    create: XOR<EnrollmentCreateInput, EnrollmentUncheckedCreateInput>
    /**
     * In case the Enrollment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EnrollmentUpdateInput, EnrollmentUncheckedUpdateInput>
  }

  /**
   * Enrollment delete
   */
  export type EnrollmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Enrollment
     */
    select?: EnrollmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnrollmentInclude<ExtArgs> | null
    /**
     * Filter which Enrollment to delete.
     */
    where: EnrollmentWhereUniqueInput
  }

  /**
   * Enrollment deleteMany
   */
  export type EnrollmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Enrollments to delete
     */
    where?: EnrollmentWhereInput
  }

  /**
   * Enrollment without action
   */
  export type EnrollmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Enrollment
     */
    select?: EnrollmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnrollmentInclude<ExtArgs> | null
  }


  /**
   * Model Exam
   */

  export type AggregateExam = {
    _count: ExamCountAggregateOutputType | null
    _avg: ExamAvgAggregateOutputType | null
    _sum: ExamSumAggregateOutputType | null
    _min: ExamMinAggregateOutputType | null
    _max: ExamMaxAggregateOutputType | null
  }

  export type ExamAvgAggregateOutputType = {
    id: number | null
    departmentId: number | null
    courseId: number | null
  }

  export type ExamSumAggregateOutputType = {
    id: number | null
    departmentId: number | null
    courseId: number | null
  }

  export type ExamMinAggregateOutputType = {
    id: number | null
    title: string | null
    departmentId: number | null
    createdAt: Date | null
    updatedAt: Date | null
    courseId: number | null
    description: string | null
    deleted: boolean | null
  }

  export type ExamMaxAggregateOutputType = {
    id: number | null
    title: string | null
    departmentId: number | null
    createdAt: Date | null
    updatedAt: Date | null
    courseId: number | null
    description: string | null
    deleted: boolean | null
  }

  export type ExamCountAggregateOutputType = {
    id: number
    title: number
    departmentId: number
    createdAt: number
    updatedAt: number
    courseId: number
    description: number
    deleted: number
    _all: number
  }


  export type ExamAvgAggregateInputType = {
    id?: true
    departmentId?: true
    courseId?: true
  }

  export type ExamSumAggregateInputType = {
    id?: true
    departmentId?: true
    courseId?: true
  }

  export type ExamMinAggregateInputType = {
    id?: true
    title?: true
    departmentId?: true
    createdAt?: true
    updatedAt?: true
    courseId?: true
    description?: true
    deleted?: true
  }

  export type ExamMaxAggregateInputType = {
    id?: true
    title?: true
    departmentId?: true
    createdAt?: true
    updatedAt?: true
    courseId?: true
    description?: true
    deleted?: true
  }

  export type ExamCountAggregateInputType = {
    id?: true
    title?: true
    departmentId?: true
    createdAt?: true
    updatedAt?: true
    courseId?: true
    description?: true
    deleted?: true
    _all?: true
  }

  export type ExamAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Exam to aggregate.
     */
    where?: ExamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Exams to fetch.
     */
    orderBy?: ExamOrderByWithRelationInput | ExamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ExamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Exams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Exams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Exams
    **/
    _count?: true | ExamCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ExamAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ExamSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ExamMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ExamMaxAggregateInputType
  }

  export type GetExamAggregateType<T extends ExamAggregateArgs> = {
        [P in keyof T & keyof AggregateExam]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateExam[P]>
      : GetScalarType<T[P], AggregateExam[P]>
  }




  export type ExamGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExamWhereInput
    orderBy?: ExamOrderByWithAggregationInput | ExamOrderByWithAggregationInput[]
    by: ExamScalarFieldEnum[] | ExamScalarFieldEnum
    having?: ExamScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ExamCountAggregateInputType | true
    _avg?: ExamAvgAggregateInputType
    _sum?: ExamSumAggregateInputType
    _min?: ExamMinAggregateInputType
    _max?: ExamMaxAggregateInputType
  }

  export type ExamGroupByOutputType = {
    id: number
    title: string
    departmentId: number | null
    createdAt: Date
    updatedAt: Date
    courseId: number | null
    description: string | null
    deleted: boolean
    _count: ExamCountAggregateOutputType | null
    _avg: ExamAvgAggregateOutputType | null
    _sum: ExamSumAggregateOutputType | null
    _min: ExamMinAggregateOutputType | null
    _max: ExamMaxAggregateOutputType | null
  }

  type GetExamGroupByPayload<T extends ExamGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ExamGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ExamGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ExamGroupByOutputType[P]>
            : GetScalarType<T[P], ExamGroupByOutputType[P]>
        }
      >
    >


  export type ExamSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    departmentId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    courseId?: boolean
    description?: boolean
    deleted?: boolean
    questions?: boolean | Exam$questionsArgs<ExtArgs>
    attempts?: boolean | Exam$attemptsArgs<ExtArgs>
    completions?: boolean | Exam$completionsArgs<ExtArgs>
    course?: boolean | Exam$courseArgs<ExtArgs>
    _count?: boolean | ExamCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["exam"]>


  export type ExamSelectScalar = {
    id?: boolean
    title?: boolean
    departmentId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    courseId?: boolean
    description?: boolean
    deleted?: boolean
  }

  export type ExamInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    questions?: boolean | Exam$questionsArgs<ExtArgs>
    attempts?: boolean | Exam$attemptsArgs<ExtArgs>
    completions?: boolean | Exam$completionsArgs<ExtArgs>
    course?: boolean | Exam$courseArgs<ExtArgs>
    _count?: boolean | ExamCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $ExamPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Exam"
    objects: {
      questions: Prisma.$QuestionPayload<ExtArgs>[]
      attempts: Prisma.$ExamAttemptPayload<ExtArgs>[]
      completions: Prisma.$UserCourseCompletionPayload<ExtArgs>[]
      course: Prisma.$CoursePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      title: string
      departmentId: number | null
      createdAt: Date
      updatedAt: Date
      courseId: number | null
      description: string | null
      deleted: boolean
    }, ExtArgs["result"]["exam"]>
    composites: {}
  }

  type ExamGetPayload<S extends boolean | null | undefined | ExamDefaultArgs> = $Result.GetResult<Prisma.$ExamPayload, S>

  type ExamCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ExamFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ExamCountAggregateInputType | true
    }

  export interface ExamDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Exam'], meta: { name: 'Exam' } }
    /**
     * Find zero or one Exam that matches the filter.
     * @param {ExamFindUniqueArgs} args - Arguments to find a Exam
     * @example
     * // Get one Exam
     * const exam = await prisma.exam.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ExamFindUniqueArgs>(args: SelectSubset<T, ExamFindUniqueArgs<ExtArgs>>): Prisma__ExamClient<$Result.GetResult<Prisma.$ExamPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Exam that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ExamFindUniqueOrThrowArgs} args - Arguments to find a Exam
     * @example
     * // Get one Exam
     * const exam = await prisma.exam.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ExamFindUniqueOrThrowArgs>(args: SelectSubset<T, ExamFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ExamClient<$Result.GetResult<Prisma.$ExamPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Exam that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamFindFirstArgs} args - Arguments to find a Exam
     * @example
     * // Get one Exam
     * const exam = await prisma.exam.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ExamFindFirstArgs>(args?: SelectSubset<T, ExamFindFirstArgs<ExtArgs>>): Prisma__ExamClient<$Result.GetResult<Prisma.$ExamPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Exam that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamFindFirstOrThrowArgs} args - Arguments to find a Exam
     * @example
     * // Get one Exam
     * const exam = await prisma.exam.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ExamFindFirstOrThrowArgs>(args?: SelectSubset<T, ExamFindFirstOrThrowArgs<ExtArgs>>): Prisma__ExamClient<$Result.GetResult<Prisma.$ExamPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Exams that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Exams
     * const exams = await prisma.exam.findMany()
     * 
     * // Get first 10 Exams
     * const exams = await prisma.exam.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const examWithIdOnly = await prisma.exam.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ExamFindManyArgs>(args?: SelectSubset<T, ExamFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExamPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Exam.
     * @param {ExamCreateArgs} args - Arguments to create a Exam.
     * @example
     * // Create one Exam
     * const Exam = await prisma.exam.create({
     *   data: {
     *     // ... data to create a Exam
     *   }
     * })
     * 
     */
    create<T extends ExamCreateArgs>(args: SelectSubset<T, ExamCreateArgs<ExtArgs>>): Prisma__ExamClient<$Result.GetResult<Prisma.$ExamPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Exams.
     * @param {ExamCreateManyArgs} args - Arguments to create many Exams.
     * @example
     * // Create many Exams
     * const exam = await prisma.exam.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ExamCreateManyArgs>(args?: SelectSubset<T, ExamCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Exam.
     * @param {ExamDeleteArgs} args - Arguments to delete one Exam.
     * @example
     * // Delete one Exam
     * const Exam = await prisma.exam.delete({
     *   where: {
     *     // ... filter to delete one Exam
     *   }
     * })
     * 
     */
    delete<T extends ExamDeleteArgs>(args: SelectSubset<T, ExamDeleteArgs<ExtArgs>>): Prisma__ExamClient<$Result.GetResult<Prisma.$ExamPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Exam.
     * @param {ExamUpdateArgs} args - Arguments to update one Exam.
     * @example
     * // Update one Exam
     * const exam = await prisma.exam.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ExamUpdateArgs>(args: SelectSubset<T, ExamUpdateArgs<ExtArgs>>): Prisma__ExamClient<$Result.GetResult<Prisma.$ExamPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Exams.
     * @param {ExamDeleteManyArgs} args - Arguments to filter Exams to delete.
     * @example
     * // Delete a few Exams
     * const { count } = await prisma.exam.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ExamDeleteManyArgs>(args?: SelectSubset<T, ExamDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Exams.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Exams
     * const exam = await prisma.exam.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ExamUpdateManyArgs>(args: SelectSubset<T, ExamUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Exam.
     * @param {ExamUpsertArgs} args - Arguments to update or create a Exam.
     * @example
     * // Update or create a Exam
     * const exam = await prisma.exam.upsert({
     *   create: {
     *     // ... data to create a Exam
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Exam we want to update
     *   }
     * })
     */
    upsert<T extends ExamUpsertArgs>(args: SelectSubset<T, ExamUpsertArgs<ExtArgs>>): Prisma__ExamClient<$Result.GetResult<Prisma.$ExamPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Exams.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamCountArgs} args - Arguments to filter Exams to count.
     * @example
     * // Count the number of Exams
     * const count = await prisma.exam.count({
     *   where: {
     *     // ... the filter for the Exams we want to count
     *   }
     * })
    **/
    count<T extends ExamCountArgs>(
      args?: Subset<T, ExamCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ExamCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Exam.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ExamAggregateArgs>(args: Subset<T, ExamAggregateArgs>): Prisma.PrismaPromise<GetExamAggregateType<T>>

    /**
     * Group by Exam.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ExamGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ExamGroupByArgs['orderBy'] }
        : { orderBy?: ExamGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ExamGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetExamGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Exam model
   */
  readonly fields: ExamFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Exam.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ExamClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    questions<T extends Exam$questionsArgs<ExtArgs> = {}>(args?: Subset<T, Exam$questionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuestionPayload<ExtArgs>, T, "findMany"> | Null>
    attempts<T extends Exam$attemptsArgs<ExtArgs> = {}>(args?: Subset<T, Exam$attemptsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExamAttemptPayload<ExtArgs>, T, "findMany"> | Null>
    completions<T extends Exam$completionsArgs<ExtArgs> = {}>(args?: Subset<T, Exam$completionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserCourseCompletionPayload<ExtArgs>, T, "findMany"> | Null>
    course<T extends Exam$courseArgs<ExtArgs> = {}>(args?: Subset<T, Exam$courseArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Exam model
   */ 
  interface ExamFieldRefs {
    readonly id: FieldRef<"Exam", 'Int'>
    readonly title: FieldRef<"Exam", 'String'>
    readonly departmentId: FieldRef<"Exam", 'Int'>
    readonly createdAt: FieldRef<"Exam", 'DateTime'>
    readonly updatedAt: FieldRef<"Exam", 'DateTime'>
    readonly courseId: FieldRef<"Exam", 'Int'>
    readonly description: FieldRef<"Exam", 'String'>
    readonly deleted: FieldRef<"Exam", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * Exam findUnique
   */
  export type ExamFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exam
     */
    select?: ExamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamInclude<ExtArgs> | null
    /**
     * Filter, which Exam to fetch.
     */
    where: ExamWhereUniqueInput
  }

  /**
   * Exam findUniqueOrThrow
   */
  export type ExamFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exam
     */
    select?: ExamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamInclude<ExtArgs> | null
    /**
     * Filter, which Exam to fetch.
     */
    where: ExamWhereUniqueInput
  }

  /**
   * Exam findFirst
   */
  export type ExamFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exam
     */
    select?: ExamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamInclude<ExtArgs> | null
    /**
     * Filter, which Exam to fetch.
     */
    where?: ExamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Exams to fetch.
     */
    orderBy?: ExamOrderByWithRelationInput | ExamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Exams.
     */
    cursor?: ExamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Exams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Exams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Exams.
     */
    distinct?: ExamScalarFieldEnum | ExamScalarFieldEnum[]
  }

  /**
   * Exam findFirstOrThrow
   */
  export type ExamFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exam
     */
    select?: ExamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamInclude<ExtArgs> | null
    /**
     * Filter, which Exam to fetch.
     */
    where?: ExamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Exams to fetch.
     */
    orderBy?: ExamOrderByWithRelationInput | ExamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Exams.
     */
    cursor?: ExamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Exams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Exams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Exams.
     */
    distinct?: ExamScalarFieldEnum | ExamScalarFieldEnum[]
  }

  /**
   * Exam findMany
   */
  export type ExamFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exam
     */
    select?: ExamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamInclude<ExtArgs> | null
    /**
     * Filter, which Exams to fetch.
     */
    where?: ExamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Exams to fetch.
     */
    orderBy?: ExamOrderByWithRelationInput | ExamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Exams.
     */
    cursor?: ExamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Exams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Exams.
     */
    skip?: number
    distinct?: ExamScalarFieldEnum | ExamScalarFieldEnum[]
  }

  /**
   * Exam create
   */
  export type ExamCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exam
     */
    select?: ExamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamInclude<ExtArgs> | null
    /**
     * The data needed to create a Exam.
     */
    data: XOR<ExamCreateInput, ExamUncheckedCreateInput>
  }

  /**
   * Exam createMany
   */
  export type ExamCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Exams.
     */
    data: ExamCreateManyInput | ExamCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Exam update
   */
  export type ExamUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exam
     */
    select?: ExamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamInclude<ExtArgs> | null
    /**
     * The data needed to update a Exam.
     */
    data: XOR<ExamUpdateInput, ExamUncheckedUpdateInput>
    /**
     * Choose, which Exam to update.
     */
    where: ExamWhereUniqueInput
  }

  /**
   * Exam updateMany
   */
  export type ExamUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Exams.
     */
    data: XOR<ExamUpdateManyMutationInput, ExamUncheckedUpdateManyInput>
    /**
     * Filter which Exams to update
     */
    where?: ExamWhereInput
  }

  /**
   * Exam upsert
   */
  export type ExamUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exam
     */
    select?: ExamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamInclude<ExtArgs> | null
    /**
     * The filter to search for the Exam to update in case it exists.
     */
    where: ExamWhereUniqueInput
    /**
     * In case the Exam found by the `where` argument doesn't exist, create a new Exam with this data.
     */
    create: XOR<ExamCreateInput, ExamUncheckedCreateInput>
    /**
     * In case the Exam was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ExamUpdateInput, ExamUncheckedUpdateInput>
  }

  /**
   * Exam delete
   */
  export type ExamDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exam
     */
    select?: ExamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamInclude<ExtArgs> | null
    /**
     * Filter which Exam to delete.
     */
    where: ExamWhereUniqueInput
  }

  /**
   * Exam deleteMany
   */
  export type ExamDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Exams to delete
     */
    where?: ExamWhereInput
  }

  /**
   * Exam.questions
   */
  export type Exam$questionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Question
     */
    select?: QuestionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionInclude<ExtArgs> | null
    where?: QuestionWhereInput
    orderBy?: QuestionOrderByWithRelationInput | QuestionOrderByWithRelationInput[]
    cursor?: QuestionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QuestionScalarFieldEnum | QuestionScalarFieldEnum[]
  }

  /**
   * Exam.attempts
   */
  export type Exam$attemptsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamAttempt
     */
    select?: ExamAttemptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamAttemptInclude<ExtArgs> | null
    where?: ExamAttemptWhereInput
    orderBy?: ExamAttemptOrderByWithRelationInput | ExamAttemptOrderByWithRelationInput[]
    cursor?: ExamAttemptWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ExamAttemptScalarFieldEnum | ExamAttemptScalarFieldEnum[]
  }

  /**
   * Exam.completions
   */
  export type Exam$completionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCourseCompletion
     */
    select?: UserCourseCompletionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserCourseCompletionInclude<ExtArgs> | null
    where?: UserCourseCompletionWhereInput
    orderBy?: UserCourseCompletionOrderByWithRelationInput | UserCourseCompletionOrderByWithRelationInput[]
    cursor?: UserCourseCompletionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserCourseCompletionScalarFieldEnum | UserCourseCompletionScalarFieldEnum[]
  }

  /**
   * Exam.course
   */
  export type Exam$courseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    where?: CourseWhereInput
  }

  /**
   * Exam without action
   */
  export type ExamDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exam
     */
    select?: ExamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamInclude<ExtArgs> | null
  }


  /**
   * Model Question
   */

  export type AggregateQuestion = {
    _count: QuestionCountAggregateOutputType | null
    _avg: QuestionAvgAggregateOutputType | null
    _sum: QuestionSumAggregateOutputType | null
    _min: QuestionMinAggregateOutputType | null
    _max: QuestionMaxAggregateOutputType | null
  }

  export type QuestionAvgAggregateOutputType = {
    id: number | null
    examId: number | null
  }

  export type QuestionSumAggregateOutputType = {
    id: number | null
    examId: number | null
  }

  export type QuestionMinAggregateOutputType = {
    id: number | null
    examId: number | null
    text: string | null
    createdAt: Date | null
    updatedAt: Date | null
    deleted: boolean | null
  }

  export type QuestionMaxAggregateOutputType = {
    id: number | null
    examId: number | null
    text: string | null
    createdAt: Date | null
    updatedAt: Date | null
    deleted: boolean | null
  }

  export type QuestionCountAggregateOutputType = {
    id: number
    examId: number
    text: number
    createdAt: number
    updatedAt: number
    deleted: number
    _all: number
  }


  export type QuestionAvgAggregateInputType = {
    id?: true
    examId?: true
  }

  export type QuestionSumAggregateInputType = {
    id?: true
    examId?: true
  }

  export type QuestionMinAggregateInputType = {
    id?: true
    examId?: true
    text?: true
    createdAt?: true
    updatedAt?: true
    deleted?: true
  }

  export type QuestionMaxAggregateInputType = {
    id?: true
    examId?: true
    text?: true
    createdAt?: true
    updatedAt?: true
    deleted?: true
  }

  export type QuestionCountAggregateInputType = {
    id?: true
    examId?: true
    text?: true
    createdAt?: true
    updatedAt?: true
    deleted?: true
    _all?: true
  }

  export type QuestionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Question to aggregate.
     */
    where?: QuestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Questions to fetch.
     */
    orderBy?: QuestionOrderByWithRelationInput | QuestionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: QuestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Questions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Questions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Questions
    **/
    _count?: true | QuestionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: QuestionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: QuestionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: QuestionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: QuestionMaxAggregateInputType
  }

  export type GetQuestionAggregateType<T extends QuestionAggregateArgs> = {
        [P in keyof T & keyof AggregateQuestion]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQuestion[P]>
      : GetScalarType<T[P], AggregateQuestion[P]>
  }




  export type QuestionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuestionWhereInput
    orderBy?: QuestionOrderByWithAggregationInput | QuestionOrderByWithAggregationInput[]
    by: QuestionScalarFieldEnum[] | QuestionScalarFieldEnum
    having?: QuestionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: QuestionCountAggregateInputType | true
    _avg?: QuestionAvgAggregateInputType
    _sum?: QuestionSumAggregateInputType
    _min?: QuestionMinAggregateInputType
    _max?: QuestionMaxAggregateInputType
  }

  export type QuestionGroupByOutputType = {
    id: number
    examId: number
    text: string
    createdAt: Date
    updatedAt: Date
    deleted: boolean
    _count: QuestionCountAggregateOutputType | null
    _avg: QuestionAvgAggregateOutputType | null
    _sum: QuestionSumAggregateOutputType | null
    _min: QuestionMinAggregateOutputType | null
    _max: QuestionMaxAggregateOutputType | null
  }

  type GetQuestionGroupByPayload<T extends QuestionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<QuestionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof QuestionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], QuestionGroupByOutputType[P]>
            : GetScalarType<T[P], QuestionGroupByOutputType[P]>
        }
      >
    >


  export type QuestionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    examId?: boolean
    text?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deleted?: boolean
    exam?: boolean | ExamDefaultArgs<ExtArgs>
    choices?: boolean | Question$choicesArgs<ExtArgs>
    userAnswers?: boolean | Question$userAnswersArgs<ExtArgs>
    _count?: boolean | QuestionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["question"]>


  export type QuestionSelectScalar = {
    id?: boolean
    examId?: boolean
    text?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deleted?: boolean
  }

  export type QuestionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    exam?: boolean | ExamDefaultArgs<ExtArgs>
    choices?: boolean | Question$choicesArgs<ExtArgs>
    userAnswers?: boolean | Question$userAnswersArgs<ExtArgs>
    _count?: boolean | QuestionCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $QuestionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Question"
    objects: {
      exam: Prisma.$ExamPayload<ExtArgs>
      choices: Prisma.$ChoicePayload<ExtArgs>[]
      userAnswers: Prisma.$UserAnswerPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      examId: number
      text: string
      createdAt: Date
      updatedAt: Date
      deleted: boolean
    }, ExtArgs["result"]["question"]>
    composites: {}
  }

  type QuestionGetPayload<S extends boolean | null | undefined | QuestionDefaultArgs> = $Result.GetResult<Prisma.$QuestionPayload, S>

  type QuestionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<QuestionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: QuestionCountAggregateInputType | true
    }

  export interface QuestionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Question'], meta: { name: 'Question' } }
    /**
     * Find zero or one Question that matches the filter.
     * @param {QuestionFindUniqueArgs} args - Arguments to find a Question
     * @example
     * // Get one Question
     * const question = await prisma.question.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends QuestionFindUniqueArgs>(args: SelectSubset<T, QuestionFindUniqueArgs<ExtArgs>>): Prisma__QuestionClient<$Result.GetResult<Prisma.$QuestionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Question that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {QuestionFindUniqueOrThrowArgs} args - Arguments to find a Question
     * @example
     * // Get one Question
     * const question = await prisma.question.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends QuestionFindUniqueOrThrowArgs>(args: SelectSubset<T, QuestionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__QuestionClient<$Result.GetResult<Prisma.$QuestionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Question that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionFindFirstArgs} args - Arguments to find a Question
     * @example
     * // Get one Question
     * const question = await prisma.question.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends QuestionFindFirstArgs>(args?: SelectSubset<T, QuestionFindFirstArgs<ExtArgs>>): Prisma__QuestionClient<$Result.GetResult<Prisma.$QuestionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Question that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionFindFirstOrThrowArgs} args - Arguments to find a Question
     * @example
     * // Get one Question
     * const question = await prisma.question.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends QuestionFindFirstOrThrowArgs>(args?: SelectSubset<T, QuestionFindFirstOrThrowArgs<ExtArgs>>): Prisma__QuestionClient<$Result.GetResult<Prisma.$QuestionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Questions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Questions
     * const questions = await prisma.question.findMany()
     * 
     * // Get first 10 Questions
     * const questions = await prisma.question.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const questionWithIdOnly = await prisma.question.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends QuestionFindManyArgs>(args?: SelectSubset<T, QuestionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuestionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Question.
     * @param {QuestionCreateArgs} args - Arguments to create a Question.
     * @example
     * // Create one Question
     * const Question = await prisma.question.create({
     *   data: {
     *     // ... data to create a Question
     *   }
     * })
     * 
     */
    create<T extends QuestionCreateArgs>(args: SelectSubset<T, QuestionCreateArgs<ExtArgs>>): Prisma__QuestionClient<$Result.GetResult<Prisma.$QuestionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Questions.
     * @param {QuestionCreateManyArgs} args - Arguments to create many Questions.
     * @example
     * // Create many Questions
     * const question = await prisma.question.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends QuestionCreateManyArgs>(args?: SelectSubset<T, QuestionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Question.
     * @param {QuestionDeleteArgs} args - Arguments to delete one Question.
     * @example
     * // Delete one Question
     * const Question = await prisma.question.delete({
     *   where: {
     *     // ... filter to delete one Question
     *   }
     * })
     * 
     */
    delete<T extends QuestionDeleteArgs>(args: SelectSubset<T, QuestionDeleteArgs<ExtArgs>>): Prisma__QuestionClient<$Result.GetResult<Prisma.$QuestionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Question.
     * @param {QuestionUpdateArgs} args - Arguments to update one Question.
     * @example
     * // Update one Question
     * const question = await prisma.question.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends QuestionUpdateArgs>(args: SelectSubset<T, QuestionUpdateArgs<ExtArgs>>): Prisma__QuestionClient<$Result.GetResult<Prisma.$QuestionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Questions.
     * @param {QuestionDeleteManyArgs} args - Arguments to filter Questions to delete.
     * @example
     * // Delete a few Questions
     * const { count } = await prisma.question.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends QuestionDeleteManyArgs>(args?: SelectSubset<T, QuestionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Questions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Questions
     * const question = await prisma.question.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends QuestionUpdateManyArgs>(args: SelectSubset<T, QuestionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Question.
     * @param {QuestionUpsertArgs} args - Arguments to update or create a Question.
     * @example
     * // Update or create a Question
     * const question = await prisma.question.upsert({
     *   create: {
     *     // ... data to create a Question
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Question we want to update
     *   }
     * })
     */
    upsert<T extends QuestionUpsertArgs>(args: SelectSubset<T, QuestionUpsertArgs<ExtArgs>>): Prisma__QuestionClient<$Result.GetResult<Prisma.$QuestionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Questions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionCountArgs} args - Arguments to filter Questions to count.
     * @example
     * // Count the number of Questions
     * const count = await prisma.question.count({
     *   where: {
     *     // ... the filter for the Questions we want to count
     *   }
     * })
    **/
    count<T extends QuestionCountArgs>(
      args?: Subset<T, QuestionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], QuestionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Question.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends QuestionAggregateArgs>(args: Subset<T, QuestionAggregateArgs>): Prisma.PrismaPromise<GetQuestionAggregateType<T>>

    /**
     * Group by Question.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends QuestionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: QuestionGroupByArgs['orderBy'] }
        : { orderBy?: QuestionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, QuestionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQuestionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Question model
   */
  readonly fields: QuestionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Question.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__QuestionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    exam<T extends ExamDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ExamDefaultArgs<ExtArgs>>): Prisma__ExamClient<$Result.GetResult<Prisma.$ExamPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    choices<T extends Question$choicesArgs<ExtArgs> = {}>(args?: Subset<T, Question$choicesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChoicePayload<ExtArgs>, T, "findMany"> | Null>
    userAnswers<T extends Question$userAnswersArgs<ExtArgs> = {}>(args?: Subset<T, Question$userAnswersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserAnswerPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Question model
   */ 
  interface QuestionFieldRefs {
    readonly id: FieldRef<"Question", 'Int'>
    readonly examId: FieldRef<"Question", 'Int'>
    readonly text: FieldRef<"Question", 'String'>
    readonly createdAt: FieldRef<"Question", 'DateTime'>
    readonly updatedAt: FieldRef<"Question", 'DateTime'>
    readonly deleted: FieldRef<"Question", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * Question findUnique
   */
  export type QuestionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Question
     */
    select?: QuestionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionInclude<ExtArgs> | null
    /**
     * Filter, which Question to fetch.
     */
    where: QuestionWhereUniqueInput
  }

  /**
   * Question findUniqueOrThrow
   */
  export type QuestionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Question
     */
    select?: QuestionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionInclude<ExtArgs> | null
    /**
     * Filter, which Question to fetch.
     */
    where: QuestionWhereUniqueInput
  }

  /**
   * Question findFirst
   */
  export type QuestionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Question
     */
    select?: QuestionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionInclude<ExtArgs> | null
    /**
     * Filter, which Question to fetch.
     */
    where?: QuestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Questions to fetch.
     */
    orderBy?: QuestionOrderByWithRelationInput | QuestionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Questions.
     */
    cursor?: QuestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Questions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Questions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Questions.
     */
    distinct?: QuestionScalarFieldEnum | QuestionScalarFieldEnum[]
  }

  /**
   * Question findFirstOrThrow
   */
  export type QuestionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Question
     */
    select?: QuestionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionInclude<ExtArgs> | null
    /**
     * Filter, which Question to fetch.
     */
    where?: QuestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Questions to fetch.
     */
    orderBy?: QuestionOrderByWithRelationInput | QuestionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Questions.
     */
    cursor?: QuestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Questions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Questions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Questions.
     */
    distinct?: QuestionScalarFieldEnum | QuestionScalarFieldEnum[]
  }

  /**
   * Question findMany
   */
  export type QuestionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Question
     */
    select?: QuestionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionInclude<ExtArgs> | null
    /**
     * Filter, which Questions to fetch.
     */
    where?: QuestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Questions to fetch.
     */
    orderBy?: QuestionOrderByWithRelationInput | QuestionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Questions.
     */
    cursor?: QuestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Questions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Questions.
     */
    skip?: number
    distinct?: QuestionScalarFieldEnum | QuestionScalarFieldEnum[]
  }

  /**
   * Question create
   */
  export type QuestionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Question
     */
    select?: QuestionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionInclude<ExtArgs> | null
    /**
     * The data needed to create a Question.
     */
    data: XOR<QuestionCreateInput, QuestionUncheckedCreateInput>
  }

  /**
   * Question createMany
   */
  export type QuestionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Questions.
     */
    data: QuestionCreateManyInput | QuestionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Question update
   */
  export type QuestionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Question
     */
    select?: QuestionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionInclude<ExtArgs> | null
    /**
     * The data needed to update a Question.
     */
    data: XOR<QuestionUpdateInput, QuestionUncheckedUpdateInput>
    /**
     * Choose, which Question to update.
     */
    where: QuestionWhereUniqueInput
  }

  /**
   * Question updateMany
   */
  export type QuestionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Questions.
     */
    data: XOR<QuestionUpdateManyMutationInput, QuestionUncheckedUpdateManyInput>
    /**
     * Filter which Questions to update
     */
    where?: QuestionWhereInput
  }

  /**
   * Question upsert
   */
  export type QuestionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Question
     */
    select?: QuestionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionInclude<ExtArgs> | null
    /**
     * The filter to search for the Question to update in case it exists.
     */
    where: QuestionWhereUniqueInput
    /**
     * In case the Question found by the `where` argument doesn't exist, create a new Question with this data.
     */
    create: XOR<QuestionCreateInput, QuestionUncheckedCreateInput>
    /**
     * In case the Question was found with the provided `where` argument, update it with this data.
     */
    update: XOR<QuestionUpdateInput, QuestionUncheckedUpdateInput>
  }

  /**
   * Question delete
   */
  export type QuestionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Question
     */
    select?: QuestionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionInclude<ExtArgs> | null
    /**
     * Filter which Question to delete.
     */
    where: QuestionWhereUniqueInput
  }

  /**
   * Question deleteMany
   */
  export type QuestionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Questions to delete
     */
    where?: QuestionWhereInput
  }

  /**
   * Question.choices
   */
  export type Question$choicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Choice
     */
    select?: ChoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChoiceInclude<ExtArgs> | null
    where?: ChoiceWhereInput
    orderBy?: ChoiceOrderByWithRelationInput | ChoiceOrderByWithRelationInput[]
    cursor?: ChoiceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChoiceScalarFieldEnum | ChoiceScalarFieldEnum[]
  }

  /**
   * Question.userAnswers
   */
  export type Question$userAnswersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAnswer
     */
    select?: UserAnswerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAnswerInclude<ExtArgs> | null
    where?: UserAnswerWhereInput
    orderBy?: UserAnswerOrderByWithRelationInput | UserAnswerOrderByWithRelationInput[]
    cursor?: UserAnswerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserAnswerScalarFieldEnum | UserAnswerScalarFieldEnum[]
  }

  /**
   * Question without action
   */
  export type QuestionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Question
     */
    select?: QuestionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionInclude<ExtArgs> | null
  }


  /**
   * Model Choice
   */

  export type AggregateChoice = {
    _count: ChoiceCountAggregateOutputType | null
    _avg: ChoiceAvgAggregateOutputType | null
    _sum: ChoiceSumAggregateOutputType | null
    _min: ChoiceMinAggregateOutputType | null
    _max: ChoiceMaxAggregateOutputType | null
  }

  export type ChoiceAvgAggregateOutputType = {
    id: number | null
    questionId: number | null
  }

  export type ChoiceSumAggregateOutputType = {
    id: number | null
    questionId: number | null
  }

  export type ChoiceMinAggregateOutputType = {
    id: number | null
    questionId: number | null
    text: string | null
    correct: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    deleted: boolean | null
  }

  export type ChoiceMaxAggregateOutputType = {
    id: number | null
    questionId: number | null
    text: string | null
    correct: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    deleted: boolean | null
  }

  export type ChoiceCountAggregateOutputType = {
    id: number
    questionId: number
    text: number
    correct: number
    createdAt: number
    updatedAt: number
    deleted: number
    _all: number
  }


  export type ChoiceAvgAggregateInputType = {
    id?: true
    questionId?: true
  }

  export type ChoiceSumAggregateInputType = {
    id?: true
    questionId?: true
  }

  export type ChoiceMinAggregateInputType = {
    id?: true
    questionId?: true
    text?: true
    correct?: true
    createdAt?: true
    updatedAt?: true
    deleted?: true
  }

  export type ChoiceMaxAggregateInputType = {
    id?: true
    questionId?: true
    text?: true
    correct?: true
    createdAt?: true
    updatedAt?: true
    deleted?: true
  }

  export type ChoiceCountAggregateInputType = {
    id?: true
    questionId?: true
    text?: true
    correct?: true
    createdAt?: true
    updatedAt?: true
    deleted?: true
    _all?: true
  }

  export type ChoiceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Choice to aggregate.
     */
    where?: ChoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Choices to fetch.
     */
    orderBy?: ChoiceOrderByWithRelationInput | ChoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ChoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Choices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Choices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Choices
    **/
    _count?: true | ChoiceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ChoiceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ChoiceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ChoiceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ChoiceMaxAggregateInputType
  }

  export type GetChoiceAggregateType<T extends ChoiceAggregateArgs> = {
        [P in keyof T & keyof AggregateChoice]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChoice[P]>
      : GetScalarType<T[P], AggregateChoice[P]>
  }




  export type ChoiceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChoiceWhereInput
    orderBy?: ChoiceOrderByWithAggregationInput | ChoiceOrderByWithAggregationInput[]
    by: ChoiceScalarFieldEnum[] | ChoiceScalarFieldEnum
    having?: ChoiceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ChoiceCountAggregateInputType | true
    _avg?: ChoiceAvgAggregateInputType
    _sum?: ChoiceSumAggregateInputType
    _min?: ChoiceMinAggregateInputType
    _max?: ChoiceMaxAggregateInputType
  }

  export type ChoiceGroupByOutputType = {
    id: number
    questionId: number
    text: string
    correct: boolean
    createdAt: Date
    updatedAt: Date
    deleted: boolean
    _count: ChoiceCountAggregateOutputType | null
    _avg: ChoiceAvgAggregateOutputType | null
    _sum: ChoiceSumAggregateOutputType | null
    _min: ChoiceMinAggregateOutputType | null
    _max: ChoiceMaxAggregateOutputType | null
  }

  type GetChoiceGroupByPayload<T extends ChoiceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ChoiceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ChoiceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ChoiceGroupByOutputType[P]>
            : GetScalarType<T[P], ChoiceGroupByOutputType[P]>
        }
      >
    >


  export type ChoiceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    questionId?: boolean
    text?: boolean
    correct?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deleted?: boolean
    question?: boolean | QuestionDefaultArgs<ExtArgs>
    UserAnswer?: boolean | Choice$UserAnswerArgs<ExtArgs>
    _count?: boolean | ChoiceCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["choice"]>


  export type ChoiceSelectScalar = {
    id?: boolean
    questionId?: boolean
    text?: boolean
    correct?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deleted?: boolean
  }

  export type ChoiceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    question?: boolean | QuestionDefaultArgs<ExtArgs>
    UserAnswer?: boolean | Choice$UserAnswerArgs<ExtArgs>
    _count?: boolean | ChoiceCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $ChoicePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Choice"
    objects: {
      question: Prisma.$QuestionPayload<ExtArgs>
      UserAnswer: Prisma.$UserAnswerPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      questionId: number
      text: string
      correct: boolean
      createdAt: Date
      updatedAt: Date
      deleted: boolean
    }, ExtArgs["result"]["choice"]>
    composites: {}
  }

  type ChoiceGetPayload<S extends boolean | null | undefined | ChoiceDefaultArgs> = $Result.GetResult<Prisma.$ChoicePayload, S>

  type ChoiceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ChoiceFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ChoiceCountAggregateInputType | true
    }

  export interface ChoiceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Choice'], meta: { name: 'Choice' } }
    /**
     * Find zero or one Choice that matches the filter.
     * @param {ChoiceFindUniqueArgs} args - Arguments to find a Choice
     * @example
     * // Get one Choice
     * const choice = await prisma.choice.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ChoiceFindUniqueArgs>(args: SelectSubset<T, ChoiceFindUniqueArgs<ExtArgs>>): Prisma__ChoiceClient<$Result.GetResult<Prisma.$ChoicePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Choice that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ChoiceFindUniqueOrThrowArgs} args - Arguments to find a Choice
     * @example
     * // Get one Choice
     * const choice = await prisma.choice.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ChoiceFindUniqueOrThrowArgs>(args: SelectSubset<T, ChoiceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ChoiceClient<$Result.GetResult<Prisma.$ChoicePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Choice that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChoiceFindFirstArgs} args - Arguments to find a Choice
     * @example
     * // Get one Choice
     * const choice = await prisma.choice.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ChoiceFindFirstArgs>(args?: SelectSubset<T, ChoiceFindFirstArgs<ExtArgs>>): Prisma__ChoiceClient<$Result.GetResult<Prisma.$ChoicePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Choice that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChoiceFindFirstOrThrowArgs} args - Arguments to find a Choice
     * @example
     * // Get one Choice
     * const choice = await prisma.choice.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ChoiceFindFirstOrThrowArgs>(args?: SelectSubset<T, ChoiceFindFirstOrThrowArgs<ExtArgs>>): Prisma__ChoiceClient<$Result.GetResult<Prisma.$ChoicePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Choices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChoiceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Choices
     * const choices = await prisma.choice.findMany()
     * 
     * // Get first 10 Choices
     * const choices = await prisma.choice.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const choiceWithIdOnly = await prisma.choice.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ChoiceFindManyArgs>(args?: SelectSubset<T, ChoiceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChoicePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Choice.
     * @param {ChoiceCreateArgs} args - Arguments to create a Choice.
     * @example
     * // Create one Choice
     * const Choice = await prisma.choice.create({
     *   data: {
     *     // ... data to create a Choice
     *   }
     * })
     * 
     */
    create<T extends ChoiceCreateArgs>(args: SelectSubset<T, ChoiceCreateArgs<ExtArgs>>): Prisma__ChoiceClient<$Result.GetResult<Prisma.$ChoicePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Choices.
     * @param {ChoiceCreateManyArgs} args - Arguments to create many Choices.
     * @example
     * // Create many Choices
     * const choice = await prisma.choice.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ChoiceCreateManyArgs>(args?: SelectSubset<T, ChoiceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Choice.
     * @param {ChoiceDeleteArgs} args - Arguments to delete one Choice.
     * @example
     * // Delete one Choice
     * const Choice = await prisma.choice.delete({
     *   where: {
     *     // ... filter to delete one Choice
     *   }
     * })
     * 
     */
    delete<T extends ChoiceDeleteArgs>(args: SelectSubset<T, ChoiceDeleteArgs<ExtArgs>>): Prisma__ChoiceClient<$Result.GetResult<Prisma.$ChoicePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Choice.
     * @param {ChoiceUpdateArgs} args - Arguments to update one Choice.
     * @example
     * // Update one Choice
     * const choice = await prisma.choice.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ChoiceUpdateArgs>(args: SelectSubset<T, ChoiceUpdateArgs<ExtArgs>>): Prisma__ChoiceClient<$Result.GetResult<Prisma.$ChoicePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Choices.
     * @param {ChoiceDeleteManyArgs} args - Arguments to filter Choices to delete.
     * @example
     * // Delete a few Choices
     * const { count } = await prisma.choice.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ChoiceDeleteManyArgs>(args?: SelectSubset<T, ChoiceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Choices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChoiceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Choices
     * const choice = await prisma.choice.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ChoiceUpdateManyArgs>(args: SelectSubset<T, ChoiceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Choice.
     * @param {ChoiceUpsertArgs} args - Arguments to update or create a Choice.
     * @example
     * // Update or create a Choice
     * const choice = await prisma.choice.upsert({
     *   create: {
     *     // ... data to create a Choice
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Choice we want to update
     *   }
     * })
     */
    upsert<T extends ChoiceUpsertArgs>(args: SelectSubset<T, ChoiceUpsertArgs<ExtArgs>>): Prisma__ChoiceClient<$Result.GetResult<Prisma.$ChoicePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Choices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChoiceCountArgs} args - Arguments to filter Choices to count.
     * @example
     * // Count the number of Choices
     * const count = await prisma.choice.count({
     *   where: {
     *     // ... the filter for the Choices we want to count
     *   }
     * })
    **/
    count<T extends ChoiceCountArgs>(
      args?: Subset<T, ChoiceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ChoiceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Choice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChoiceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ChoiceAggregateArgs>(args: Subset<T, ChoiceAggregateArgs>): Prisma.PrismaPromise<GetChoiceAggregateType<T>>

    /**
     * Group by Choice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChoiceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ChoiceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ChoiceGroupByArgs['orderBy'] }
        : { orderBy?: ChoiceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ChoiceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChoiceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Choice model
   */
  readonly fields: ChoiceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Choice.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ChoiceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    question<T extends QuestionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, QuestionDefaultArgs<ExtArgs>>): Prisma__QuestionClient<$Result.GetResult<Prisma.$QuestionPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    UserAnswer<T extends Choice$UserAnswerArgs<ExtArgs> = {}>(args?: Subset<T, Choice$UserAnswerArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserAnswerPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Choice model
   */ 
  interface ChoiceFieldRefs {
    readonly id: FieldRef<"Choice", 'Int'>
    readonly questionId: FieldRef<"Choice", 'Int'>
    readonly text: FieldRef<"Choice", 'String'>
    readonly correct: FieldRef<"Choice", 'Boolean'>
    readonly createdAt: FieldRef<"Choice", 'DateTime'>
    readonly updatedAt: FieldRef<"Choice", 'DateTime'>
    readonly deleted: FieldRef<"Choice", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * Choice findUnique
   */
  export type ChoiceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Choice
     */
    select?: ChoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChoiceInclude<ExtArgs> | null
    /**
     * Filter, which Choice to fetch.
     */
    where: ChoiceWhereUniqueInput
  }

  /**
   * Choice findUniqueOrThrow
   */
  export type ChoiceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Choice
     */
    select?: ChoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChoiceInclude<ExtArgs> | null
    /**
     * Filter, which Choice to fetch.
     */
    where: ChoiceWhereUniqueInput
  }

  /**
   * Choice findFirst
   */
  export type ChoiceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Choice
     */
    select?: ChoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChoiceInclude<ExtArgs> | null
    /**
     * Filter, which Choice to fetch.
     */
    where?: ChoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Choices to fetch.
     */
    orderBy?: ChoiceOrderByWithRelationInput | ChoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Choices.
     */
    cursor?: ChoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Choices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Choices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Choices.
     */
    distinct?: ChoiceScalarFieldEnum | ChoiceScalarFieldEnum[]
  }

  /**
   * Choice findFirstOrThrow
   */
  export type ChoiceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Choice
     */
    select?: ChoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChoiceInclude<ExtArgs> | null
    /**
     * Filter, which Choice to fetch.
     */
    where?: ChoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Choices to fetch.
     */
    orderBy?: ChoiceOrderByWithRelationInput | ChoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Choices.
     */
    cursor?: ChoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Choices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Choices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Choices.
     */
    distinct?: ChoiceScalarFieldEnum | ChoiceScalarFieldEnum[]
  }

  /**
   * Choice findMany
   */
  export type ChoiceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Choice
     */
    select?: ChoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChoiceInclude<ExtArgs> | null
    /**
     * Filter, which Choices to fetch.
     */
    where?: ChoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Choices to fetch.
     */
    orderBy?: ChoiceOrderByWithRelationInput | ChoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Choices.
     */
    cursor?: ChoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Choices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Choices.
     */
    skip?: number
    distinct?: ChoiceScalarFieldEnum | ChoiceScalarFieldEnum[]
  }

  /**
   * Choice create
   */
  export type ChoiceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Choice
     */
    select?: ChoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChoiceInclude<ExtArgs> | null
    /**
     * The data needed to create a Choice.
     */
    data: XOR<ChoiceCreateInput, ChoiceUncheckedCreateInput>
  }

  /**
   * Choice createMany
   */
  export type ChoiceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Choices.
     */
    data: ChoiceCreateManyInput | ChoiceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Choice update
   */
  export type ChoiceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Choice
     */
    select?: ChoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChoiceInclude<ExtArgs> | null
    /**
     * The data needed to update a Choice.
     */
    data: XOR<ChoiceUpdateInput, ChoiceUncheckedUpdateInput>
    /**
     * Choose, which Choice to update.
     */
    where: ChoiceWhereUniqueInput
  }

  /**
   * Choice updateMany
   */
  export type ChoiceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Choices.
     */
    data: XOR<ChoiceUpdateManyMutationInput, ChoiceUncheckedUpdateManyInput>
    /**
     * Filter which Choices to update
     */
    where?: ChoiceWhereInput
  }

  /**
   * Choice upsert
   */
  export type ChoiceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Choice
     */
    select?: ChoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChoiceInclude<ExtArgs> | null
    /**
     * The filter to search for the Choice to update in case it exists.
     */
    where: ChoiceWhereUniqueInput
    /**
     * In case the Choice found by the `where` argument doesn't exist, create a new Choice with this data.
     */
    create: XOR<ChoiceCreateInput, ChoiceUncheckedCreateInput>
    /**
     * In case the Choice was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ChoiceUpdateInput, ChoiceUncheckedUpdateInput>
  }

  /**
   * Choice delete
   */
  export type ChoiceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Choice
     */
    select?: ChoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChoiceInclude<ExtArgs> | null
    /**
     * Filter which Choice to delete.
     */
    where: ChoiceWhereUniqueInput
  }

  /**
   * Choice deleteMany
   */
  export type ChoiceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Choices to delete
     */
    where?: ChoiceWhereInput
  }

  /**
   * Choice.UserAnswer
   */
  export type Choice$UserAnswerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAnswer
     */
    select?: UserAnswerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAnswerInclude<ExtArgs> | null
    where?: UserAnswerWhereInput
    orderBy?: UserAnswerOrderByWithRelationInput | UserAnswerOrderByWithRelationInput[]
    cursor?: UserAnswerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserAnswerScalarFieldEnum | UserAnswerScalarFieldEnum[]
  }

  /**
   * Choice without action
   */
  export type ChoiceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Choice
     */
    select?: ChoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChoiceInclude<ExtArgs> | null
  }


  /**
   * Model ExamAttempt
   */

  export type AggregateExamAttempt = {
    _count: ExamAttemptCountAggregateOutputType | null
    _avg: ExamAttemptAvgAggregateOutputType | null
    _sum: ExamAttemptSumAggregateOutputType | null
    _min: ExamAttemptMinAggregateOutputType | null
    _max: ExamAttemptMaxAggregateOutputType | null
  }

  export type ExamAttemptAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    examId: number | null
    grade: number | null
  }

  export type ExamAttemptSumAggregateOutputType = {
    id: number | null
    userId: number | null
    examId: number | null
    grade: number | null
  }

  export type ExamAttemptMinAggregateOutputType = {
    id: number | null
    userId: number | null
    examId: number | null
    startedAt: Date | null
    endedAt: Date | null
    grade: number | null
    isPassed: boolean | null
  }

  export type ExamAttemptMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    examId: number | null
    startedAt: Date | null
    endedAt: Date | null
    grade: number | null
    isPassed: boolean | null
  }

  export type ExamAttemptCountAggregateOutputType = {
    id: number
    userId: number
    examId: number
    startedAt: number
    endedAt: number
    grade: number
    isPassed: number
    _all: number
  }


  export type ExamAttemptAvgAggregateInputType = {
    id?: true
    userId?: true
    examId?: true
    grade?: true
  }

  export type ExamAttemptSumAggregateInputType = {
    id?: true
    userId?: true
    examId?: true
    grade?: true
  }

  export type ExamAttemptMinAggregateInputType = {
    id?: true
    userId?: true
    examId?: true
    startedAt?: true
    endedAt?: true
    grade?: true
    isPassed?: true
  }

  export type ExamAttemptMaxAggregateInputType = {
    id?: true
    userId?: true
    examId?: true
    startedAt?: true
    endedAt?: true
    grade?: true
    isPassed?: true
  }

  export type ExamAttemptCountAggregateInputType = {
    id?: true
    userId?: true
    examId?: true
    startedAt?: true
    endedAt?: true
    grade?: true
    isPassed?: true
    _all?: true
  }

  export type ExamAttemptAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ExamAttempt to aggregate.
     */
    where?: ExamAttemptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExamAttempts to fetch.
     */
    orderBy?: ExamAttemptOrderByWithRelationInput | ExamAttemptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ExamAttemptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExamAttempts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExamAttempts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ExamAttempts
    **/
    _count?: true | ExamAttemptCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ExamAttemptAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ExamAttemptSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ExamAttemptMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ExamAttemptMaxAggregateInputType
  }

  export type GetExamAttemptAggregateType<T extends ExamAttemptAggregateArgs> = {
        [P in keyof T & keyof AggregateExamAttempt]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateExamAttempt[P]>
      : GetScalarType<T[P], AggregateExamAttempt[P]>
  }




  export type ExamAttemptGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExamAttemptWhereInput
    orderBy?: ExamAttemptOrderByWithAggregationInput | ExamAttemptOrderByWithAggregationInput[]
    by: ExamAttemptScalarFieldEnum[] | ExamAttemptScalarFieldEnum
    having?: ExamAttemptScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ExamAttemptCountAggregateInputType | true
    _avg?: ExamAttemptAvgAggregateInputType
    _sum?: ExamAttemptSumAggregateInputType
    _min?: ExamAttemptMinAggregateInputType
    _max?: ExamAttemptMaxAggregateInputType
  }

  export type ExamAttemptGroupByOutputType = {
    id: number
    userId: number
    examId: number
    startedAt: Date
    endedAt: Date | null
    grade: number | null
    isPassed: boolean | null
    _count: ExamAttemptCountAggregateOutputType | null
    _avg: ExamAttemptAvgAggregateOutputType | null
    _sum: ExamAttemptSumAggregateOutputType | null
    _min: ExamAttemptMinAggregateOutputType | null
    _max: ExamAttemptMaxAggregateOutputType | null
  }

  type GetExamAttemptGroupByPayload<T extends ExamAttemptGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ExamAttemptGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ExamAttemptGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ExamAttemptGroupByOutputType[P]>
            : GetScalarType<T[P], ExamAttemptGroupByOutputType[P]>
        }
      >
    >


  export type ExamAttemptSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    examId?: boolean
    startedAt?: boolean
    endedAt?: boolean
    grade?: boolean
    isPassed?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    exam?: boolean | ExamDefaultArgs<ExtArgs>
    answers?: boolean | ExamAttempt$answersArgs<ExtArgs>
    _count?: boolean | ExamAttemptCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["examAttempt"]>


  export type ExamAttemptSelectScalar = {
    id?: boolean
    userId?: boolean
    examId?: boolean
    startedAt?: boolean
    endedAt?: boolean
    grade?: boolean
    isPassed?: boolean
  }

  export type ExamAttemptInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    exam?: boolean | ExamDefaultArgs<ExtArgs>
    answers?: boolean | ExamAttempt$answersArgs<ExtArgs>
    _count?: boolean | ExamAttemptCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $ExamAttemptPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ExamAttempt"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      exam: Prisma.$ExamPayload<ExtArgs>
      answers: Prisma.$UserAnswerPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      examId: number
      startedAt: Date
      endedAt: Date | null
      grade: number | null
      isPassed: boolean | null
    }, ExtArgs["result"]["examAttempt"]>
    composites: {}
  }

  type ExamAttemptGetPayload<S extends boolean | null | undefined | ExamAttemptDefaultArgs> = $Result.GetResult<Prisma.$ExamAttemptPayload, S>

  type ExamAttemptCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ExamAttemptFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ExamAttemptCountAggregateInputType | true
    }

  export interface ExamAttemptDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ExamAttempt'], meta: { name: 'ExamAttempt' } }
    /**
     * Find zero or one ExamAttempt that matches the filter.
     * @param {ExamAttemptFindUniqueArgs} args - Arguments to find a ExamAttempt
     * @example
     * // Get one ExamAttempt
     * const examAttempt = await prisma.examAttempt.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ExamAttemptFindUniqueArgs>(args: SelectSubset<T, ExamAttemptFindUniqueArgs<ExtArgs>>): Prisma__ExamAttemptClient<$Result.GetResult<Prisma.$ExamAttemptPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ExamAttempt that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ExamAttemptFindUniqueOrThrowArgs} args - Arguments to find a ExamAttempt
     * @example
     * // Get one ExamAttempt
     * const examAttempt = await prisma.examAttempt.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ExamAttemptFindUniqueOrThrowArgs>(args: SelectSubset<T, ExamAttemptFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ExamAttemptClient<$Result.GetResult<Prisma.$ExamAttemptPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ExamAttempt that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamAttemptFindFirstArgs} args - Arguments to find a ExamAttempt
     * @example
     * // Get one ExamAttempt
     * const examAttempt = await prisma.examAttempt.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ExamAttemptFindFirstArgs>(args?: SelectSubset<T, ExamAttemptFindFirstArgs<ExtArgs>>): Prisma__ExamAttemptClient<$Result.GetResult<Prisma.$ExamAttemptPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ExamAttempt that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamAttemptFindFirstOrThrowArgs} args - Arguments to find a ExamAttempt
     * @example
     * // Get one ExamAttempt
     * const examAttempt = await prisma.examAttempt.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ExamAttemptFindFirstOrThrowArgs>(args?: SelectSubset<T, ExamAttemptFindFirstOrThrowArgs<ExtArgs>>): Prisma__ExamAttemptClient<$Result.GetResult<Prisma.$ExamAttemptPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ExamAttempts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamAttemptFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ExamAttempts
     * const examAttempts = await prisma.examAttempt.findMany()
     * 
     * // Get first 10 ExamAttempts
     * const examAttempts = await prisma.examAttempt.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const examAttemptWithIdOnly = await prisma.examAttempt.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ExamAttemptFindManyArgs>(args?: SelectSubset<T, ExamAttemptFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExamAttemptPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ExamAttempt.
     * @param {ExamAttemptCreateArgs} args - Arguments to create a ExamAttempt.
     * @example
     * // Create one ExamAttempt
     * const ExamAttempt = await prisma.examAttempt.create({
     *   data: {
     *     // ... data to create a ExamAttempt
     *   }
     * })
     * 
     */
    create<T extends ExamAttemptCreateArgs>(args: SelectSubset<T, ExamAttemptCreateArgs<ExtArgs>>): Prisma__ExamAttemptClient<$Result.GetResult<Prisma.$ExamAttemptPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ExamAttempts.
     * @param {ExamAttemptCreateManyArgs} args - Arguments to create many ExamAttempts.
     * @example
     * // Create many ExamAttempts
     * const examAttempt = await prisma.examAttempt.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ExamAttemptCreateManyArgs>(args?: SelectSubset<T, ExamAttemptCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ExamAttempt.
     * @param {ExamAttemptDeleteArgs} args - Arguments to delete one ExamAttempt.
     * @example
     * // Delete one ExamAttempt
     * const ExamAttempt = await prisma.examAttempt.delete({
     *   where: {
     *     // ... filter to delete one ExamAttempt
     *   }
     * })
     * 
     */
    delete<T extends ExamAttemptDeleteArgs>(args: SelectSubset<T, ExamAttemptDeleteArgs<ExtArgs>>): Prisma__ExamAttemptClient<$Result.GetResult<Prisma.$ExamAttemptPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ExamAttempt.
     * @param {ExamAttemptUpdateArgs} args - Arguments to update one ExamAttempt.
     * @example
     * // Update one ExamAttempt
     * const examAttempt = await prisma.examAttempt.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ExamAttemptUpdateArgs>(args: SelectSubset<T, ExamAttemptUpdateArgs<ExtArgs>>): Prisma__ExamAttemptClient<$Result.GetResult<Prisma.$ExamAttemptPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ExamAttempts.
     * @param {ExamAttemptDeleteManyArgs} args - Arguments to filter ExamAttempts to delete.
     * @example
     * // Delete a few ExamAttempts
     * const { count } = await prisma.examAttempt.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ExamAttemptDeleteManyArgs>(args?: SelectSubset<T, ExamAttemptDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ExamAttempts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamAttemptUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ExamAttempts
     * const examAttempt = await prisma.examAttempt.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ExamAttemptUpdateManyArgs>(args: SelectSubset<T, ExamAttemptUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ExamAttempt.
     * @param {ExamAttemptUpsertArgs} args - Arguments to update or create a ExamAttempt.
     * @example
     * // Update or create a ExamAttempt
     * const examAttempt = await prisma.examAttempt.upsert({
     *   create: {
     *     // ... data to create a ExamAttempt
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ExamAttempt we want to update
     *   }
     * })
     */
    upsert<T extends ExamAttemptUpsertArgs>(args: SelectSubset<T, ExamAttemptUpsertArgs<ExtArgs>>): Prisma__ExamAttemptClient<$Result.GetResult<Prisma.$ExamAttemptPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ExamAttempts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamAttemptCountArgs} args - Arguments to filter ExamAttempts to count.
     * @example
     * // Count the number of ExamAttempts
     * const count = await prisma.examAttempt.count({
     *   where: {
     *     // ... the filter for the ExamAttempts we want to count
     *   }
     * })
    **/
    count<T extends ExamAttemptCountArgs>(
      args?: Subset<T, ExamAttemptCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ExamAttemptCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ExamAttempt.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamAttemptAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ExamAttemptAggregateArgs>(args: Subset<T, ExamAttemptAggregateArgs>): Prisma.PrismaPromise<GetExamAttemptAggregateType<T>>

    /**
     * Group by ExamAttempt.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamAttemptGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ExamAttemptGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ExamAttemptGroupByArgs['orderBy'] }
        : { orderBy?: ExamAttemptGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ExamAttemptGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetExamAttemptGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ExamAttempt model
   */
  readonly fields: ExamAttemptFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ExamAttempt.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ExamAttemptClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    exam<T extends ExamDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ExamDefaultArgs<ExtArgs>>): Prisma__ExamClient<$Result.GetResult<Prisma.$ExamPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    answers<T extends ExamAttempt$answersArgs<ExtArgs> = {}>(args?: Subset<T, ExamAttempt$answersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserAnswerPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ExamAttempt model
   */ 
  interface ExamAttemptFieldRefs {
    readonly id: FieldRef<"ExamAttempt", 'Int'>
    readonly userId: FieldRef<"ExamAttempt", 'Int'>
    readonly examId: FieldRef<"ExamAttempt", 'Int'>
    readonly startedAt: FieldRef<"ExamAttempt", 'DateTime'>
    readonly endedAt: FieldRef<"ExamAttempt", 'DateTime'>
    readonly grade: FieldRef<"ExamAttempt", 'Float'>
    readonly isPassed: FieldRef<"ExamAttempt", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * ExamAttempt findUnique
   */
  export type ExamAttemptFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamAttempt
     */
    select?: ExamAttemptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamAttemptInclude<ExtArgs> | null
    /**
     * Filter, which ExamAttempt to fetch.
     */
    where: ExamAttemptWhereUniqueInput
  }

  /**
   * ExamAttempt findUniqueOrThrow
   */
  export type ExamAttemptFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamAttempt
     */
    select?: ExamAttemptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamAttemptInclude<ExtArgs> | null
    /**
     * Filter, which ExamAttempt to fetch.
     */
    where: ExamAttemptWhereUniqueInput
  }

  /**
   * ExamAttempt findFirst
   */
  export type ExamAttemptFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamAttempt
     */
    select?: ExamAttemptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamAttemptInclude<ExtArgs> | null
    /**
     * Filter, which ExamAttempt to fetch.
     */
    where?: ExamAttemptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExamAttempts to fetch.
     */
    orderBy?: ExamAttemptOrderByWithRelationInput | ExamAttemptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ExamAttempts.
     */
    cursor?: ExamAttemptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExamAttempts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExamAttempts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ExamAttempts.
     */
    distinct?: ExamAttemptScalarFieldEnum | ExamAttemptScalarFieldEnum[]
  }

  /**
   * ExamAttempt findFirstOrThrow
   */
  export type ExamAttemptFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamAttempt
     */
    select?: ExamAttemptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamAttemptInclude<ExtArgs> | null
    /**
     * Filter, which ExamAttempt to fetch.
     */
    where?: ExamAttemptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExamAttempts to fetch.
     */
    orderBy?: ExamAttemptOrderByWithRelationInput | ExamAttemptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ExamAttempts.
     */
    cursor?: ExamAttemptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExamAttempts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExamAttempts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ExamAttempts.
     */
    distinct?: ExamAttemptScalarFieldEnum | ExamAttemptScalarFieldEnum[]
  }

  /**
   * ExamAttempt findMany
   */
  export type ExamAttemptFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamAttempt
     */
    select?: ExamAttemptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamAttemptInclude<ExtArgs> | null
    /**
     * Filter, which ExamAttempts to fetch.
     */
    where?: ExamAttemptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExamAttempts to fetch.
     */
    orderBy?: ExamAttemptOrderByWithRelationInput | ExamAttemptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ExamAttempts.
     */
    cursor?: ExamAttemptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExamAttempts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExamAttempts.
     */
    skip?: number
    distinct?: ExamAttemptScalarFieldEnum | ExamAttemptScalarFieldEnum[]
  }

  /**
   * ExamAttempt create
   */
  export type ExamAttemptCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamAttempt
     */
    select?: ExamAttemptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamAttemptInclude<ExtArgs> | null
    /**
     * The data needed to create a ExamAttempt.
     */
    data: XOR<ExamAttemptCreateInput, ExamAttemptUncheckedCreateInput>
  }

  /**
   * ExamAttempt createMany
   */
  export type ExamAttemptCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ExamAttempts.
     */
    data: ExamAttemptCreateManyInput | ExamAttemptCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ExamAttempt update
   */
  export type ExamAttemptUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamAttempt
     */
    select?: ExamAttemptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamAttemptInclude<ExtArgs> | null
    /**
     * The data needed to update a ExamAttempt.
     */
    data: XOR<ExamAttemptUpdateInput, ExamAttemptUncheckedUpdateInput>
    /**
     * Choose, which ExamAttempt to update.
     */
    where: ExamAttemptWhereUniqueInput
  }

  /**
   * ExamAttempt updateMany
   */
  export type ExamAttemptUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ExamAttempts.
     */
    data: XOR<ExamAttemptUpdateManyMutationInput, ExamAttemptUncheckedUpdateManyInput>
    /**
     * Filter which ExamAttempts to update
     */
    where?: ExamAttemptWhereInput
  }

  /**
   * ExamAttempt upsert
   */
  export type ExamAttemptUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamAttempt
     */
    select?: ExamAttemptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamAttemptInclude<ExtArgs> | null
    /**
     * The filter to search for the ExamAttempt to update in case it exists.
     */
    where: ExamAttemptWhereUniqueInput
    /**
     * In case the ExamAttempt found by the `where` argument doesn't exist, create a new ExamAttempt with this data.
     */
    create: XOR<ExamAttemptCreateInput, ExamAttemptUncheckedCreateInput>
    /**
     * In case the ExamAttempt was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ExamAttemptUpdateInput, ExamAttemptUncheckedUpdateInput>
  }

  /**
   * ExamAttempt delete
   */
  export type ExamAttemptDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamAttempt
     */
    select?: ExamAttemptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamAttemptInclude<ExtArgs> | null
    /**
     * Filter which ExamAttempt to delete.
     */
    where: ExamAttemptWhereUniqueInput
  }

  /**
   * ExamAttempt deleteMany
   */
  export type ExamAttemptDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ExamAttempts to delete
     */
    where?: ExamAttemptWhereInput
  }

  /**
   * ExamAttempt.answers
   */
  export type ExamAttempt$answersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAnswer
     */
    select?: UserAnswerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAnswerInclude<ExtArgs> | null
    where?: UserAnswerWhereInput
    orderBy?: UserAnswerOrderByWithRelationInput | UserAnswerOrderByWithRelationInput[]
    cursor?: UserAnswerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserAnswerScalarFieldEnum | UserAnswerScalarFieldEnum[]
  }

  /**
   * ExamAttempt without action
   */
  export type ExamAttemptDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamAttempt
     */
    select?: ExamAttemptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamAttemptInclude<ExtArgs> | null
  }


  /**
   * Model UserAnswer
   */

  export type AggregateUserAnswer = {
    _count: UserAnswerCountAggregateOutputType | null
    _avg: UserAnswerAvgAggregateOutputType | null
    _sum: UserAnswerSumAggregateOutputType | null
    _min: UserAnswerMinAggregateOutputType | null
    _max: UserAnswerMaxAggregateOutputType | null
  }

  export type UserAnswerAvgAggregateOutputType = {
    id: number | null
    examAttemptId: number | null
    questionId: number | null
    selectedChoiceId: number | null
  }

  export type UserAnswerSumAggregateOutputType = {
    id: number | null
    examAttemptId: number | null
    questionId: number | null
    selectedChoiceId: number | null
  }

  export type UserAnswerMinAggregateOutputType = {
    id: number | null
    examAttemptId: number | null
    questionId: number | null
    selectedChoiceId: number | null
    isCorrect: boolean | null
    createdAt: Date | null
  }

  export type UserAnswerMaxAggregateOutputType = {
    id: number | null
    examAttemptId: number | null
    questionId: number | null
    selectedChoiceId: number | null
    isCorrect: boolean | null
    createdAt: Date | null
  }

  export type UserAnswerCountAggregateOutputType = {
    id: number
    examAttemptId: number
    questionId: number
    selectedChoiceId: number
    isCorrect: number
    createdAt: number
    _all: number
  }


  export type UserAnswerAvgAggregateInputType = {
    id?: true
    examAttemptId?: true
    questionId?: true
    selectedChoiceId?: true
  }

  export type UserAnswerSumAggregateInputType = {
    id?: true
    examAttemptId?: true
    questionId?: true
    selectedChoiceId?: true
  }

  export type UserAnswerMinAggregateInputType = {
    id?: true
    examAttemptId?: true
    questionId?: true
    selectedChoiceId?: true
    isCorrect?: true
    createdAt?: true
  }

  export type UserAnswerMaxAggregateInputType = {
    id?: true
    examAttemptId?: true
    questionId?: true
    selectedChoiceId?: true
    isCorrect?: true
    createdAt?: true
  }

  export type UserAnswerCountAggregateInputType = {
    id?: true
    examAttemptId?: true
    questionId?: true
    selectedChoiceId?: true
    isCorrect?: true
    createdAt?: true
    _all?: true
  }

  export type UserAnswerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserAnswer to aggregate.
     */
    where?: UserAnswerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserAnswers to fetch.
     */
    orderBy?: UserAnswerOrderByWithRelationInput | UserAnswerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserAnswerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserAnswers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserAnswers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserAnswers
    **/
    _count?: true | UserAnswerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAnswerAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserAnswerSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserAnswerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserAnswerMaxAggregateInputType
  }

  export type GetUserAnswerAggregateType<T extends UserAnswerAggregateArgs> = {
        [P in keyof T & keyof AggregateUserAnswer]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserAnswer[P]>
      : GetScalarType<T[P], AggregateUserAnswer[P]>
  }




  export type UserAnswerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserAnswerWhereInput
    orderBy?: UserAnswerOrderByWithAggregationInput | UserAnswerOrderByWithAggregationInput[]
    by: UserAnswerScalarFieldEnum[] | UserAnswerScalarFieldEnum
    having?: UserAnswerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserAnswerCountAggregateInputType | true
    _avg?: UserAnswerAvgAggregateInputType
    _sum?: UserAnswerSumAggregateInputType
    _min?: UserAnswerMinAggregateInputType
    _max?: UserAnswerMaxAggregateInputType
  }

  export type UserAnswerGroupByOutputType = {
    id: number
    examAttemptId: number
    questionId: number
    selectedChoiceId: number
    isCorrect: boolean
    createdAt: Date
    _count: UserAnswerCountAggregateOutputType | null
    _avg: UserAnswerAvgAggregateOutputType | null
    _sum: UserAnswerSumAggregateOutputType | null
    _min: UserAnswerMinAggregateOutputType | null
    _max: UserAnswerMaxAggregateOutputType | null
  }

  type GetUserAnswerGroupByPayload<T extends UserAnswerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserAnswerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserAnswerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserAnswerGroupByOutputType[P]>
            : GetScalarType<T[P], UserAnswerGroupByOutputType[P]>
        }
      >
    >


  export type UserAnswerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    examAttemptId?: boolean
    questionId?: boolean
    selectedChoiceId?: boolean
    isCorrect?: boolean
    createdAt?: boolean
    examAttempt?: boolean | ExamAttemptDefaultArgs<ExtArgs>
    question?: boolean | QuestionDefaultArgs<ExtArgs>
    selectedChoice?: boolean | ChoiceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userAnswer"]>


  export type UserAnswerSelectScalar = {
    id?: boolean
    examAttemptId?: boolean
    questionId?: boolean
    selectedChoiceId?: boolean
    isCorrect?: boolean
    createdAt?: boolean
  }

  export type UserAnswerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    examAttempt?: boolean | ExamAttemptDefaultArgs<ExtArgs>
    question?: boolean | QuestionDefaultArgs<ExtArgs>
    selectedChoice?: boolean | ChoiceDefaultArgs<ExtArgs>
  }

  export type $UserAnswerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserAnswer"
    objects: {
      examAttempt: Prisma.$ExamAttemptPayload<ExtArgs>
      question: Prisma.$QuestionPayload<ExtArgs>
      selectedChoice: Prisma.$ChoicePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      examAttemptId: number
      questionId: number
      selectedChoiceId: number
      isCorrect: boolean
      createdAt: Date
    }, ExtArgs["result"]["userAnswer"]>
    composites: {}
  }

  type UserAnswerGetPayload<S extends boolean | null | undefined | UserAnswerDefaultArgs> = $Result.GetResult<Prisma.$UserAnswerPayload, S>

  type UserAnswerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserAnswerFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserAnswerCountAggregateInputType | true
    }

  export interface UserAnswerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserAnswer'], meta: { name: 'UserAnswer' } }
    /**
     * Find zero or one UserAnswer that matches the filter.
     * @param {UserAnswerFindUniqueArgs} args - Arguments to find a UserAnswer
     * @example
     * // Get one UserAnswer
     * const userAnswer = await prisma.userAnswer.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserAnswerFindUniqueArgs>(args: SelectSubset<T, UserAnswerFindUniqueArgs<ExtArgs>>): Prisma__UserAnswerClient<$Result.GetResult<Prisma.$UserAnswerPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one UserAnswer that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserAnswerFindUniqueOrThrowArgs} args - Arguments to find a UserAnswer
     * @example
     * // Get one UserAnswer
     * const userAnswer = await prisma.userAnswer.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserAnswerFindUniqueOrThrowArgs>(args: SelectSubset<T, UserAnswerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserAnswerClient<$Result.GetResult<Prisma.$UserAnswerPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first UserAnswer that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAnswerFindFirstArgs} args - Arguments to find a UserAnswer
     * @example
     * // Get one UserAnswer
     * const userAnswer = await prisma.userAnswer.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserAnswerFindFirstArgs>(args?: SelectSubset<T, UserAnswerFindFirstArgs<ExtArgs>>): Prisma__UserAnswerClient<$Result.GetResult<Prisma.$UserAnswerPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first UserAnswer that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAnswerFindFirstOrThrowArgs} args - Arguments to find a UserAnswer
     * @example
     * // Get one UserAnswer
     * const userAnswer = await prisma.userAnswer.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserAnswerFindFirstOrThrowArgs>(args?: SelectSubset<T, UserAnswerFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserAnswerClient<$Result.GetResult<Prisma.$UserAnswerPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more UserAnswers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAnswerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserAnswers
     * const userAnswers = await prisma.userAnswer.findMany()
     * 
     * // Get first 10 UserAnswers
     * const userAnswers = await prisma.userAnswer.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userAnswerWithIdOnly = await prisma.userAnswer.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserAnswerFindManyArgs>(args?: SelectSubset<T, UserAnswerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserAnswerPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a UserAnswer.
     * @param {UserAnswerCreateArgs} args - Arguments to create a UserAnswer.
     * @example
     * // Create one UserAnswer
     * const UserAnswer = await prisma.userAnswer.create({
     *   data: {
     *     // ... data to create a UserAnswer
     *   }
     * })
     * 
     */
    create<T extends UserAnswerCreateArgs>(args: SelectSubset<T, UserAnswerCreateArgs<ExtArgs>>): Prisma__UserAnswerClient<$Result.GetResult<Prisma.$UserAnswerPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many UserAnswers.
     * @param {UserAnswerCreateManyArgs} args - Arguments to create many UserAnswers.
     * @example
     * // Create many UserAnswers
     * const userAnswer = await prisma.userAnswer.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserAnswerCreateManyArgs>(args?: SelectSubset<T, UserAnswerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a UserAnswer.
     * @param {UserAnswerDeleteArgs} args - Arguments to delete one UserAnswer.
     * @example
     * // Delete one UserAnswer
     * const UserAnswer = await prisma.userAnswer.delete({
     *   where: {
     *     // ... filter to delete one UserAnswer
     *   }
     * })
     * 
     */
    delete<T extends UserAnswerDeleteArgs>(args: SelectSubset<T, UserAnswerDeleteArgs<ExtArgs>>): Prisma__UserAnswerClient<$Result.GetResult<Prisma.$UserAnswerPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one UserAnswer.
     * @param {UserAnswerUpdateArgs} args - Arguments to update one UserAnswer.
     * @example
     * // Update one UserAnswer
     * const userAnswer = await prisma.userAnswer.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserAnswerUpdateArgs>(args: SelectSubset<T, UserAnswerUpdateArgs<ExtArgs>>): Prisma__UserAnswerClient<$Result.GetResult<Prisma.$UserAnswerPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more UserAnswers.
     * @param {UserAnswerDeleteManyArgs} args - Arguments to filter UserAnswers to delete.
     * @example
     * // Delete a few UserAnswers
     * const { count } = await prisma.userAnswer.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserAnswerDeleteManyArgs>(args?: SelectSubset<T, UserAnswerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserAnswers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAnswerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserAnswers
     * const userAnswer = await prisma.userAnswer.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserAnswerUpdateManyArgs>(args: SelectSubset<T, UserAnswerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UserAnswer.
     * @param {UserAnswerUpsertArgs} args - Arguments to update or create a UserAnswer.
     * @example
     * // Update or create a UserAnswer
     * const userAnswer = await prisma.userAnswer.upsert({
     *   create: {
     *     // ... data to create a UserAnswer
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserAnswer we want to update
     *   }
     * })
     */
    upsert<T extends UserAnswerUpsertArgs>(args: SelectSubset<T, UserAnswerUpsertArgs<ExtArgs>>): Prisma__UserAnswerClient<$Result.GetResult<Prisma.$UserAnswerPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of UserAnswers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAnswerCountArgs} args - Arguments to filter UserAnswers to count.
     * @example
     * // Count the number of UserAnswers
     * const count = await prisma.userAnswer.count({
     *   where: {
     *     // ... the filter for the UserAnswers we want to count
     *   }
     * })
    **/
    count<T extends UserAnswerCountArgs>(
      args?: Subset<T, UserAnswerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserAnswerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserAnswer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAnswerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAnswerAggregateArgs>(args: Subset<T, UserAnswerAggregateArgs>): Prisma.PrismaPromise<GetUserAnswerAggregateType<T>>

    /**
     * Group by UserAnswer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAnswerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserAnswerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserAnswerGroupByArgs['orderBy'] }
        : { orderBy?: UserAnswerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserAnswerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserAnswerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserAnswer model
   */
  readonly fields: UserAnswerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserAnswer.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserAnswerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    examAttempt<T extends ExamAttemptDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ExamAttemptDefaultArgs<ExtArgs>>): Prisma__ExamAttemptClient<$Result.GetResult<Prisma.$ExamAttemptPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    question<T extends QuestionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, QuestionDefaultArgs<ExtArgs>>): Prisma__QuestionClient<$Result.GetResult<Prisma.$QuestionPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    selectedChoice<T extends ChoiceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ChoiceDefaultArgs<ExtArgs>>): Prisma__ChoiceClient<$Result.GetResult<Prisma.$ChoicePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserAnswer model
   */ 
  interface UserAnswerFieldRefs {
    readonly id: FieldRef<"UserAnswer", 'Int'>
    readonly examAttemptId: FieldRef<"UserAnswer", 'Int'>
    readonly questionId: FieldRef<"UserAnswer", 'Int'>
    readonly selectedChoiceId: FieldRef<"UserAnswer", 'Int'>
    readonly isCorrect: FieldRef<"UserAnswer", 'Boolean'>
    readonly createdAt: FieldRef<"UserAnswer", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserAnswer findUnique
   */
  export type UserAnswerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAnswer
     */
    select?: UserAnswerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAnswerInclude<ExtArgs> | null
    /**
     * Filter, which UserAnswer to fetch.
     */
    where: UserAnswerWhereUniqueInput
  }

  /**
   * UserAnswer findUniqueOrThrow
   */
  export type UserAnswerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAnswer
     */
    select?: UserAnswerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAnswerInclude<ExtArgs> | null
    /**
     * Filter, which UserAnswer to fetch.
     */
    where: UserAnswerWhereUniqueInput
  }

  /**
   * UserAnswer findFirst
   */
  export type UserAnswerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAnswer
     */
    select?: UserAnswerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAnswerInclude<ExtArgs> | null
    /**
     * Filter, which UserAnswer to fetch.
     */
    where?: UserAnswerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserAnswers to fetch.
     */
    orderBy?: UserAnswerOrderByWithRelationInput | UserAnswerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserAnswers.
     */
    cursor?: UserAnswerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserAnswers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserAnswers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserAnswers.
     */
    distinct?: UserAnswerScalarFieldEnum | UserAnswerScalarFieldEnum[]
  }

  /**
   * UserAnswer findFirstOrThrow
   */
  export type UserAnswerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAnswer
     */
    select?: UserAnswerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAnswerInclude<ExtArgs> | null
    /**
     * Filter, which UserAnswer to fetch.
     */
    where?: UserAnswerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserAnswers to fetch.
     */
    orderBy?: UserAnswerOrderByWithRelationInput | UserAnswerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserAnswers.
     */
    cursor?: UserAnswerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserAnswers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserAnswers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserAnswers.
     */
    distinct?: UserAnswerScalarFieldEnum | UserAnswerScalarFieldEnum[]
  }

  /**
   * UserAnswer findMany
   */
  export type UserAnswerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAnswer
     */
    select?: UserAnswerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAnswerInclude<ExtArgs> | null
    /**
     * Filter, which UserAnswers to fetch.
     */
    where?: UserAnswerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserAnswers to fetch.
     */
    orderBy?: UserAnswerOrderByWithRelationInput | UserAnswerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserAnswers.
     */
    cursor?: UserAnswerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserAnswers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserAnswers.
     */
    skip?: number
    distinct?: UserAnswerScalarFieldEnum | UserAnswerScalarFieldEnum[]
  }

  /**
   * UserAnswer create
   */
  export type UserAnswerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAnswer
     */
    select?: UserAnswerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAnswerInclude<ExtArgs> | null
    /**
     * The data needed to create a UserAnswer.
     */
    data: XOR<UserAnswerCreateInput, UserAnswerUncheckedCreateInput>
  }

  /**
   * UserAnswer createMany
   */
  export type UserAnswerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserAnswers.
     */
    data: UserAnswerCreateManyInput | UserAnswerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserAnswer update
   */
  export type UserAnswerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAnswer
     */
    select?: UserAnswerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAnswerInclude<ExtArgs> | null
    /**
     * The data needed to update a UserAnswer.
     */
    data: XOR<UserAnswerUpdateInput, UserAnswerUncheckedUpdateInput>
    /**
     * Choose, which UserAnswer to update.
     */
    where: UserAnswerWhereUniqueInput
  }

  /**
   * UserAnswer updateMany
   */
  export type UserAnswerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserAnswers.
     */
    data: XOR<UserAnswerUpdateManyMutationInput, UserAnswerUncheckedUpdateManyInput>
    /**
     * Filter which UserAnswers to update
     */
    where?: UserAnswerWhereInput
  }

  /**
   * UserAnswer upsert
   */
  export type UserAnswerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAnswer
     */
    select?: UserAnswerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAnswerInclude<ExtArgs> | null
    /**
     * The filter to search for the UserAnswer to update in case it exists.
     */
    where: UserAnswerWhereUniqueInput
    /**
     * In case the UserAnswer found by the `where` argument doesn't exist, create a new UserAnswer with this data.
     */
    create: XOR<UserAnswerCreateInput, UserAnswerUncheckedCreateInput>
    /**
     * In case the UserAnswer was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserAnswerUpdateInput, UserAnswerUncheckedUpdateInput>
  }

  /**
   * UserAnswer delete
   */
  export type UserAnswerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAnswer
     */
    select?: UserAnswerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAnswerInclude<ExtArgs> | null
    /**
     * Filter which UserAnswer to delete.
     */
    where: UserAnswerWhereUniqueInput
  }

  /**
   * UserAnswer deleteMany
   */
  export type UserAnswerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserAnswers to delete
     */
    where?: UserAnswerWhereInput
  }

  /**
   * UserAnswer without action
   */
  export type UserAnswerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAnswer
     */
    select?: UserAnswerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAnswerInclude<ExtArgs> | null
  }


  /**
   * Model OplDocument
   */

  export type AggregateOplDocument = {
    _count: OplDocumentCountAggregateOutputType | null
    _avg: OplDocumentAvgAggregateOutputType | null
    _sum: OplDocumentSumAggregateOutputType | null
    _min: OplDocumentMinAggregateOutputType | null
    _max: OplDocumentMaxAggregateOutputType | null
  }

  export type OplDocumentAvgAggregateOutputType = {
    id: number | null
    uploadedBy: number | null
  }

  export type OplDocumentSumAggregateOutputType = {
    id: number | null
    uploadedBy: number | null
  }

  export type OplDocumentMinAggregateOutputType = {
    id: number | null
    title: string | null
    description: string | null
    fileName: string | null
    fileType: string | null
    filePath: string | null
    template: boolean | null
    createdAt: Date | null
    uploadedBy: number | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type OplDocumentMaxAggregateOutputType = {
    id: number | null
    title: string | null
    description: string | null
    fileName: string | null
    fileType: string | null
    filePath: string | null
    template: boolean | null
    createdAt: Date | null
    uploadedBy: number | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type OplDocumentCountAggregateOutputType = {
    id: number
    title: number
    description: number
    fileName: number
    fileType: number
    filePath: number
    template: number
    createdAt: number
    uploadedBy: number
    updatedAt: number
    deletedAt: number
    _all: number
  }


  export type OplDocumentAvgAggregateInputType = {
    id?: true
    uploadedBy?: true
  }

  export type OplDocumentSumAggregateInputType = {
    id?: true
    uploadedBy?: true
  }

  export type OplDocumentMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    fileName?: true
    fileType?: true
    filePath?: true
    template?: true
    createdAt?: true
    uploadedBy?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type OplDocumentMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    fileName?: true
    fileType?: true
    filePath?: true
    template?: true
    createdAt?: true
    uploadedBy?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type OplDocumentCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    fileName?: true
    fileType?: true
    filePath?: true
    template?: true
    createdAt?: true
    uploadedBy?: true
    updatedAt?: true
    deletedAt?: true
    _all?: true
  }

  export type OplDocumentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OplDocument to aggregate.
     */
    where?: OplDocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OplDocuments to fetch.
     */
    orderBy?: OplDocumentOrderByWithRelationInput | OplDocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OplDocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OplDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OplDocuments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OplDocuments
    **/
    _count?: true | OplDocumentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OplDocumentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OplDocumentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OplDocumentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OplDocumentMaxAggregateInputType
  }

  export type GetOplDocumentAggregateType<T extends OplDocumentAggregateArgs> = {
        [P in keyof T & keyof AggregateOplDocument]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOplDocument[P]>
      : GetScalarType<T[P], AggregateOplDocument[P]>
  }




  export type OplDocumentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OplDocumentWhereInput
    orderBy?: OplDocumentOrderByWithAggregationInput | OplDocumentOrderByWithAggregationInput[]
    by: OplDocumentScalarFieldEnum[] | OplDocumentScalarFieldEnum
    having?: OplDocumentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OplDocumentCountAggregateInputType | true
    _avg?: OplDocumentAvgAggregateInputType
    _sum?: OplDocumentSumAggregateInputType
    _min?: OplDocumentMinAggregateInputType
    _max?: OplDocumentMaxAggregateInputType
  }

  export type OplDocumentGroupByOutputType = {
    id: number
    title: string
    description: string | null
    fileName: string
    fileType: string
    filePath: string
    template: boolean
    createdAt: Date
    uploadedBy: number
    updatedAt: Date
    deletedAt: Date | null
    _count: OplDocumentCountAggregateOutputType | null
    _avg: OplDocumentAvgAggregateOutputType | null
    _sum: OplDocumentSumAggregateOutputType | null
    _min: OplDocumentMinAggregateOutputType | null
    _max: OplDocumentMaxAggregateOutputType | null
  }

  type GetOplDocumentGroupByPayload<T extends OplDocumentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OplDocumentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OplDocumentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OplDocumentGroupByOutputType[P]>
            : GetScalarType<T[P], OplDocumentGroupByOutputType[P]>
        }
      >
    >


  export type OplDocumentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    fileName?: boolean
    fileType?: boolean
    filePath?: boolean
    template?: boolean
    createdAt?: boolean
    uploadedBy?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["oplDocument"]>


  export type OplDocumentSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    fileName?: boolean
    fileType?: boolean
    filePath?: boolean
    template?: boolean
    createdAt?: boolean
    uploadedBy?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }

  export type OplDocumentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $OplDocumentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "OplDocument"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      title: string
      description: string | null
      fileName: string
      fileType: string
      filePath: string
      template: boolean
      createdAt: Date
      uploadedBy: number
      updatedAt: Date
      deletedAt: Date | null
    }, ExtArgs["result"]["oplDocument"]>
    composites: {}
  }

  type OplDocumentGetPayload<S extends boolean | null | undefined | OplDocumentDefaultArgs> = $Result.GetResult<Prisma.$OplDocumentPayload, S>

  type OplDocumentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<OplDocumentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: OplDocumentCountAggregateInputType | true
    }

  export interface OplDocumentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['OplDocument'], meta: { name: 'OplDocument' } }
    /**
     * Find zero or one OplDocument that matches the filter.
     * @param {OplDocumentFindUniqueArgs} args - Arguments to find a OplDocument
     * @example
     * // Get one OplDocument
     * const oplDocument = await prisma.oplDocument.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OplDocumentFindUniqueArgs>(args: SelectSubset<T, OplDocumentFindUniqueArgs<ExtArgs>>): Prisma__OplDocumentClient<$Result.GetResult<Prisma.$OplDocumentPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one OplDocument that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {OplDocumentFindUniqueOrThrowArgs} args - Arguments to find a OplDocument
     * @example
     * // Get one OplDocument
     * const oplDocument = await prisma.oplDocument.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OplDocumentFindUniqueOrThrowArgs>(args: SelectSubset<T, OplDocumentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OplDocumentClient<$Result.GetResult<Prisma.$OplDocumentPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first OplDocument that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OplDocumentFindFirstArgs} args - Arguments to find a OplDocument
     * @example
     * // Get one OplDocument
     * const oplDocument = await prisma.oplDocument.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OplDocumentFindFirstArgs>(args?: SelectSubset<T, OplDocumentFindFirstArgs<ExtArgs>>): Prisma__OplDocumentClient<$Result.GetResult<Prisma.$OplDocumentPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first OplDocument that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OplDocumentFindFirstOrThrowArgs} args - Arguments to find a OplDocument
     * @example
     * // Get one OplDocument
     * const oplDocument = await prisma.oplDocument.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OplDocumentFindFirstOrThrowArgs>(args?: SelectSubset<T, OplDocumentFindFirstOrThrowArgs<ExtArgs>>): Prisma__OplDocumentClient<$Result.GetResult<Prisma.$OplDocumentPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more OplDocuments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OplDocumentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OplDocuments
     * const oplDocuments = await prisma.oplDocument.findMany()
     * 
     * // Get first 10 OplDocuments
     * const oplDocuments = await prisma.oplDocument.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const oplDocumentWithIdOnly = await prisma.oplDocument.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OplDocumentFindManyArgs>(args?: SelectSubset<T, OplDocumentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OplDocumentPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a OplDocument.
     * @param {OplDocumentCreateArgs} args - Arguments to create a OplDocument.
     * @example
     * // Create one OplDocument
     * const OplDocument = await prisma.oplDocument.create({
     *   data: {
     *     // ... data to create a OplDocument
     *   }
     * })
     * 
     */
    create<T extends OplDocumentCreateArgs>(args: SelectSubset<T, OplDocumentCreateArgs<ExtArgs>>): Prisma__OplDocumentClient<$Result.GetResult<Prisma.$OplDocumentPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many OplDocuments.
     * @param {OplDocumentCreateManyArgs} args - Arguments to create many OplDocuments.
     * @example
     * // Create many OplDocuments
     * const oplDocument = await prisma.oplDocument.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OplDocumentCreateManyArgs>(args?: SelectSubset<T, OplDocumentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a OplDocument.
     * @param {OplDocumentDeleteArgs} args - Arguments to delete one OplDocument.
     * @example
     * // Delete one OplDocument
     * const OplDocument = await prisma.oplDocument.delete({
     *   where: {
     *     // ... filter to delete one OplDocument
     *   }
     * })
     * 
     */
    delete<T extends OplDocumentDeleteArgs>(args: SelectSubset<T, OplDocumentDeleteArgs<ExtArgs>>): Prisma__OplDocumentClient<$Result.GetResult<Prisma.$OplDocumentPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one OplDocument.
     * @param {OplDocumentUpdateArgs} args - Arguments to update one OplDocument.
     * @example
     * // Update one OplDocument
     * const oplDocument = await prisma.oplDocument.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OplDocumentUpdateArgs>(args: SelectSubset<T, OplDocumentUpdateArgs<ExtArgs>>): Prisma__OplDocumentClient<$Result.GetResult<Prisma.$OplDocumentPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more OplDocuments.
     * @param {OplDocumentDeleteManyArgs} args - Arguments to filter OplDocuments to delete.
     * @example
     * // Delete a few OplDocuments
     * const { count } = await prisma.oplDocument.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OplDocumentDeleteManyArgs>(args?: SelectSubset<T, OplDocumentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OplDocuments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OplDocumentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OplDocuments
     * const oplDocument = await prisma.oplDocument.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OplDocumentUpdateManyArgs>(args: SelectSubset<T, OplDocumentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one OplDocument.
     * @param {OplDocumentUpsertArgs} args - Arguments to update or create a OplDocument.
     * @example
     * // Update or create a OplDocument
     * const oplDocument = await prisma.oplDocument.upsert({
     *   create: {
     *     // ... data to create a OplDocument
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OplDocument we want to update
     *   }
     * })
     */
    upsert<T extends OplDocumentUpsertArgs>(args: SelectSubset<T, OplDocumentUpsertArgs<ExtArgs>>): Prisma__OplDocumentClient<$Result.GetResult<Prisma.$OplDocumentPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of OplDocuments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OplDocumentCountArgs} args - Arguments to filter OplDocuments to count.
     * @example
     * // Count the number of OplDocuments
     * const count = await prisma.oplDocument.count({
     *   where: {
     *     // ... the filter for the OplDocuments we want to count
     *   }
     * })
    **/
    count<T extends OplDocumentCountArgs>(
      args?: Subset<T, OplDocumentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OplDocumentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OplDocument.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OplDocumentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OplDocumentAggregateArgs>(args: Subset<T, OplDocumentAggregateArgs>): Prisma.PrismaPromise<GetOplDocumentAggregateType<T>>

    /**
     * Group by OplDocument.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OplDocumentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OplDocumentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OplDocumentGroupByArgs['orderBy'] }
        : { orderBy?: OplDocumentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OplDocumentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOplDocumentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the OplDocument model
   */
  readonly fields: OplDocumentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for OplDocument.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OplDocumentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the OplDocument model
   */ 
  interface OplDocumentFieldRefs {
    readonly id: FieldRef<"OplDocument", 'Int'>
    readonly title: FieldRef<"OplDocument", 'String'>
    readonly description: FieldRef<"OplDocument", 'String'>
    readonly fileName: FieldRef<"OplDocument", 'String'>
    readonly fileType: FieldRef<"OplDocument", 'String'>
    readonly filePath: FieldRef<"OplDocument", 'String'>
    readonly template: FieldRef<"OplDocument", 'Boolean'>
    readonly createdAt: FieldRef<"OplDocument", 'DateTime'>
    readonly uploadedBy: FieldRef<"OplDocument", 'Int'>
    readonly updatedAt: FieldRef<"OplDocument", 'DateTime'>
    readonly deletedAt: FieldRef<"OplDocument", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * OplDocument findUnique
   */
  export type OplDocumentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OplDocument
     */
    select?: OplDocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OplDocumentInclude<ExtArgs> | null
    /**
     * Filter, which OplDocument to fetch.
     */
    where: OplDocumentWhereUniqueInput
  }

  /**
   * OplDocument findUniqueOrThrow
   */
  export type OplDocumentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OplDocument
     */
    select?: OplDocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OplDocumentInclude<ExtArgs> | null
    /**
     * Filter, which OplDocument to fetch.
     */
    where: OplDocumentWhereUniqueInput
  }

  /**
   * OplDocument findFirst
   */
  export type OplDocumentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OplDocument
     */
    select?: OplDocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OplDocumentInclude<ExtArgs> | null
    /**
     * Filter, which OplDocument to fetch.
     */
    where?: OplDocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OplDocuments to fetch.
     */
    orderBy?: OplDocumentOrderByWithRelationInput | OplDocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OplDocuments.
     */
    cursor?: OplDocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OplDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OplDocuments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OplDocuments.
     */
    distinct?: OplDocumentScalarFieldEnum | OplDocumentScalarFieldEnum[]
  }

  /**
   * OplDocument findFirstOrThrow
   */
  export type OplDocumentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OplDocument
     */
    select?: OplDocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OplDocumentInclude<ExtArgs> | null
    /**
     * Filter, which OplDocument to fetch.
     */
    where?: OplDocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OplDocuments to fetch.
     */
    orderBy?: OplDocumentOrderByWithRelationInput | OplDocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OplDocuments.
     */
    cursor?: OplDocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OplDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OplDocuments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OplDocuments.
     */
    distinct?: OplDocumentScalarFieldEnum | OplDocumentScalarFieldEnum[]
  }

  /**
   * OplDocument findMany
   */
  export type OplDocumentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OplDocument
     */
    select?: OplDocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OplDocumentInclude<ExtArgs> | null
    /**
     * Filter, which OplDocuments to fetch.
     */
    where?: OplDocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OplDocuments to fetch.
     */
    orderBy?: OplDocumentOrderByWithRelationInput | OplDocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OplDocuments.
     */
    cursor?: OplDocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OplDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OplDocuments.
     */
    skip?: number
    distinct?: OplDocumentScalarFieldEnum | OplDocumentScalarFieldEnum[]
  }

  /**
   * OplDocument create
   */
  export type OplDocumentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OplDocument
     */
    select?: OplDocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OplDocumentInclude<ExtArgs> | null
    /**
     * The data needed to create a OplDocument.
     */
    data: XOR<OplDocumentCreateInput, OplDocumentUncheckedCreateInput>
  }

  /**
   * OplDocument createMany
   */
  export type OplDocumentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many OplDocuments.
     */
    data: OplDocumentCreateManyInput | OplDocumentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * OplDocument update
   */
  export type OplDocumentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OplDocument
     */
    select?: OplDocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OplDocumentInclude<ExtArgs> | null
    /**
     * The data needed to update a OplDocument.
     */
    data: XOR<OplDocumentUpdateInput, OplDocumentUncheckedUpdateInput>
    /**
     * Choose, which OplDocument to update.
     */
    where: OplDocumentWhereUniqueInput
  }

  /**
   * OplDocument updateMany
   */
  export type OplDocumentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update OplDocuments.
     */
    data: XOR<OplDocumentUpdateManyMutationInput, OplDocumentUncheckedUpdateManyInput>
    /**
     * Filter which OplDocuments to update
     */
    where?: OplDocumentWhereInput
  }

  /**
   * OplDocument upsert
   */
  export type OplDocumentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OplDocument
     */
    select?: OplDocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OplDocumentInclude<ExtArgs> | null
    /**
     * The filter to search for the OplDocument to update in case it exists.
     */
    where: OplDocumentWhereUniqueInput
    /**
     * In case the OplDocument found by the `where` argument doesn't exist, create a new OplDocument with this data.
     */
    create: XOR<OplDocumentCreateInput, OplDocumentUncheckedCreateInput>
    /**
     * In case the OplDocument was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OplDocumentUpdateInput, OplDocumentUncheckedUpdateInput>
  }

  /**
   * OplDocument delete
   */
  export type OplDocumentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OplDocument
     */
    select?: OplDocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OplDocumentInclude<ExtArgs> | null
    /**
     * Filter which OplDocument to delete.
     */
    where: OplDocumentWhereUniqueInput
  }

  /**
   * OplDocument deleteMany
   */
  export type OplDocumentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OplDocuments to delete
     */
    where?: OplDocumentWhereInput
  }

  /**
   * OplDocument without action
   */
  export type OplDocumentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OplDocument
     */
    select?: OplDocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OplDocumentInclude<ExtArgs> | null
  }


  /**
   * Model File
   */

  export type AggregateFile = {
    _count: FileCountAggregateOutputType | null
    _avg: FileAvgAggregateOutputType | null
    _sum: FileSumAggregateOutputType | null
    _min: FileMinAggregateOutputType | null
    _max: FileMaxAggregateOutputType | null
  }

  export type FileAvgAggregateOutputType = {
    id: number | null
    fileSize: number | null
    userId: number | null
    courseId: number | null
  }

  export type FileSumAggregateOutputType = {
    id: number | null
    fileSize: bigint | null
    userId: number | null
    courseId: number | null
  }

  export type FileMinAggregateOutputType = {
    id: number | null
    originalName: string | null
    storedName: string | null
    fileType: string | null
    fileSize: bigint | null
    filePath: string | null
    uploadDate: Date | null
    userId: number | null
    courseId: number | null
  }

  export type FileMaxAggregateOutputType = {
    id: number | null
    originalName: string | null
    storedName: string | null
    fileType: string | null
    fileSize: bigint | null
    filePath: string | null
    uploadDate: Date | null
    userId: number | null
    courseId: number | null
  }

  export type FileCountAggregateOutputType = {
    id: number
    originalName: number
    storedName: number
    fileType: number
    fileSize: number
    filePath: number
    uploadDate: number
    userId: number
    courseId: number
    _all: number
  }


  export type FileAvgAggregateInputType = {
    id?: true
    fileSize?: true
    userId?: true
    courseId?: true
  }

  export type FileSumAggregateInputType = {
    id?: true
    fileSize?: true
    userId?: true
    courseId?: true
  }

  export type FileMinAggregateInputType = {
    id?: true
    originalName?: true
    storedName?: true
    fileType?: true
    fileSize?: true
    filePath?: true
    uploadDate?: true
    userId?: true
    courseId?: true
  }

  export type FileMaxAggregateInputType = {
    id?: true
    originalName?: true
    storedName?: true
    fileType?: true
    fileSize?: true
    filePath?: true
    uploadDate?: true
    userId?: true
    courseId?: true
  }

  export type FileCountAggregateInputType = {
    id?: true
    originalName?: true
    storedName?: true
    fileType?: true
    fileSize?: true
    filePath?: true
    uploadDate?: true
    userId?: true
    courseId?: true
    _all?: true
  }

  export type FileAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which File to aggregate.
     */
    where?: FileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Files to fetch.
     */
    orderBy?: FileOrderByWithRelationInput | FileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Files from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Files.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Files
    **/
    _count?: true | FileCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FileAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FileSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FileMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FileMaxAggregateInputType
  }

  export type GetFileAggregateType<T extends FileAggregateArgs> = {
        [P in keyof T & keyof AggregateFile]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFile[P]>
      : GetScalarType<T[P], AggregateFile[P]>
  }




  export type FileGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FileWhereInput
    orderBy?: FileOrderByWithAggregationInput | FileOrderByWithAggregationInput[]
    by: FileScalarFieldEnum[] | FileScalarFieldEnum
    having?: FileScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FileCountAggregateInputType | true
    _avg?: FileAvgAggregateInputType
    _sum?: FileSumAggregateInputType
    _min?: FileMinAggregateInputType
    _max?: FileMaxAggregateInputType
  }

  export type FileGroupByOutputType = {
    id: number
    originalName: string
    storedName: string
    fileType: string
    fileSize: bigint
    filePath: string
    uploadDate: Date
    userId: number | null
    courseId: number | null
    _count: FileCountAggregateOutputType | null
    _avg: FileAvgAggregateOutputType | null
    _sum: FileSumAggregateOutputType | null
    _min: FileMinAggregateOutputType | null
    _max: FileMaxAggregateOutputType | null
  }

  type GetFileGroupByPayload<T extends FileGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FileGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FileGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FileGroupByOutputType[P]>
            : GetScalarType<T[P], FileGroupByOutputType[P]>
        }
      >
    >


  export type FileSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    originalName?: boolean
    storedName?: boolean
    fileType?: boolean
    fileSize?: boolean
    filePath?: boolean
    uploadDate?: boolean
    userId?: boolean
    courseId?: boolean
    user?: boolean | File$userArgs<ExtArgs>
    course?: boolean | File$courseArgs<ExtArgs>
  }, ExtArgs["result"]["file"]>


  export type FileSelectScalar = {
    id?: boolean
    originalName?: boolean
    storedName?: boolean
    fileType?: boolean
    fileSize?: boolean
    filePath?: boolean
    uploadDate?: boolean
    userId?: boolean
    courseId?: boolean
  }

  export type FileInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | File$userArgs<ExtArgs>
    course?: boolean | File$courseArgs<ExtArgs>
  }

  export type $FilePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "File"
    objects: {
      user: Prisma.$UserPayload<ExtArgs> | null
      course: Prisma.$CoursePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      originalName: string
      storedName: string
      fileType: string
      fileSize: bigint
      filePath: string
      uploadDate: Date
      userId: number | null
      courseId: number | null
    }, ExtArgs["result"]["file"]>
    composites: {}
  }

  type FileGetPayload<S extends boolean | null | undefined | FileDefaultArgs> = $Result.GetResult<Prisma.$FilePayload, S>

  type FileCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<FileFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: FileCountAggregateInputType | true
    }

  export interface FileDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['File'], meta: { name: 'File' } }
    /**
     * Find zero or one File that matches the filter.
     * @param {FileFindUniqueArgs} args - Arguments to find a File
     * @example
     * // Get one File
     * const file = await prisma.file.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FileFindUniqueArgs>(args: SelectSubset<T, FileFindUniqueArgs<ExtArgs>>): Prisma__FileClient<$Result.GetResult<Prisma.$FilePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one File that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {FileFindUniqueOrThrowArgs} args - Arguments to find a File
     * @example
     * // Get one File
     * const file = await prisma.file.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FileFindUniqueOrThrowArgs>(args: SelectSubset<T, FileFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FileClient<$Result.GetResult<Prisma.$FilePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first File that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileFindFirstArgs} args - Arguments to find a File
     * @example
     * // Get one File
     * const file = await prisma.file.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FileFindFirstArgs>(args?: SelectSubset<T, FileFindFirstArgs<ExtArgs>>): Prisma__FileClient<$Result.GetResult<Prisma.$FilePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first File that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileFindFirstOrThrowArgs} args - Arguments to find a File
     * @example
     * // Get one File
     * const file = await prisma.file.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FileFindFirstOrThrowArgs>(args?: SelectSubset<T, FileFindFirstOrThrowArgs<ExtArgs>>): Prisma__FileClient<$Result.GetResult<Prisma.$FilePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Files that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Files
     * const files = await prisma.file.findMany()
     * 
     * // Get first 10 Files
     * const files = await prisma.file.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const fileWithIdOnly = await prisma.file.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FileFindManyArgs>(args?: SelectSubset<T, FileFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FilePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a File.
     * @param {FileCreateArgs} args - Arguments to create a File.
     * @example
     * // Create one File
     * const File = await prisma.file.create({
     *   data: {
     *     // ... data to create a File
     *   }
     * })
     * 
     */
    create<T extends FileCreateArgs>(args: SelectSubset<T, FileCreateArgs<ExtArgs>>): Prisma__FileClient<$Result.GetResult<Prisma.$FilePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Files.
     * @param {FileCreateManyArgs} args - Arguments to create many Files.
     * @example
     * // Create many Files
     * const file = await prisma.file.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FileCreateManyArgs>(args?: SelectSubset<T, FileCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a File.
     * @param {FileDeleteArgs} args - Arguments to delete one File.
     * @example
     * // Delete one File
     * const File = await prisma.file.delete({
     *   where: {
     *     // ... filter to delete one File
     *   }
     * })
     * 
     */
    delete<T extends FileDeleteArgs>(args: SelectSubset<T, FileDeleteArgs<ExtArgs>>): Prisma__FileClient<$Result.GetResult<Prisma.$FilePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one File.
     * @param {FileUpdateArgs} args - Arguments to update one File.
     * @example
     * // Update one File
     * const file = await prisma.file.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FileUpdateArgs>(args: SelectSubset<T, FileUpdateArgs<ExtArgs>>): Prisma__FileClient<$Result.GetResult<Prisma.$FilePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Files.
     * @param {FileDeleteManyArgs} args - Arguments to filter Files to delete.
     * @example
     * // Delete a few Files
     * const { count } = await prisma.file.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FileDeleteManyArgs>(args?: SelectSubset<T, FileDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Files.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Files
     * const file = await prisma.file.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FileUpdateManyArgs>(args: SelectSubset<T, FileUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one File.
     * @param {FileUpsertArgs} args - Arguments to update or create a File.
     * @example
     * // Update or create a File
     * const file = await prisma.file.upsert({
     *   create: {
     *     // ... data to create a File
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the File we want to update
     *   }
     * })
     */
    upsert<T extends FileUpsertArgs>(args: SelectSubset<T, FileUpsertArgs<ExtArgs>>): Prisma__FileClient<$Result.GetResult<Prisma.$FilePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Files.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileCountArgs} args - Arguments to filter Files to count.
     * @example
     * // Count the number of Files
     * const count = await prisma.file.count({
     *   where: {
     *     // ... the filter for the Files we want to count
     *   }
     * })
    **/
    count<T extends FileCountArgs>(
      args?: Subset<T, FileCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FileCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a File.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FileAggregateArgs>(args: Subset<T, FileAggregateArgs>): Prisma.PrismaPromise<GetFileAggregateType<T>>

    /**
     * Group by File.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FileGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FileGroupByArgs['orderBy'] }
        : { orderBy?: FileGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FileGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFileGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the File model
   */
  readonly fields: FileFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for File.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FileClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends File$userArgs<ExtArgs> = {}>(args?: Subset<T, File$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    course<T extends File$courseArgs<ExtArgs> = {}>(args?: Subset<T, File$courseArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the File model
   */ 
  interface FileFieldRefs {
    readonly id: FieldRef<"File", 'Int'>
    readonly originalName: FieldRef<"File", 'String'>
    readonly storedName: FieldRef<"File", 'String'>
    readonly fileType: FieldRef<"File", 'String'>
    readonly fileSize: FieldRef<"File", 'BigInt'>
    readonly filePath: FieldRef<"File", 'String'>
    readonly uploadDate: FieldRef<"File", 'DateTime'>
    readonly userId: FieldRef<"File", 'Int'>
    readonly courseId: FieldRef<"File", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * File findUnique
   */
  export type FileFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileInclude<ExtArgs> | null
    /**
     * Filter, which File to fetch.
     */
    where: FileWhereUniqueInput
  }

  /**
   * File findUniqueOrThrow
   */
  export type FileFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileInclude<ExtArgs> | null
    /**
     * Filter, which File to fetch.
     */
    where: FileWhereUniqueInput
  }

  /**
   * File findFirst
   */
  export type FileFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileInclude<ExtArgs> | null
    /**
     * Filter, which File to fetch.
     */
    where?: FileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Files to fetch.
     */
    orderBy?: FileOrderByWithRelationInput | FileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Files.
     */
    cursor?: FileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Files from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Files.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Files.
     */
    distinct?: FileScalarFieldEnum | FileScalarFieldEnum[]
  }

  /**
   * File findFirstOrThrow
   */
  export type FileFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileInclude<ExtArgs> | null
    /**
     * Filter, which File to fetch.
     */
    where?: FileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Files to fetch.
     */
    orderBy?: FileOrderByWithRelationInput | FileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Files.
     */
    cursor?: FileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Files from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Files.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Files.
     */
    distinct?: FileScalarFieldEnum | FileScalarFieldEnum[]
  }

  /**
   * File findMany
   */
  export type FileFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileInclude<ExtArgs> | null
    /**
     * Filter, which Files to fetch.
     */
    where?: FileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Files to fetch.
     */
    orderBy?: FileOrderByWithRelationInput | FileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Files.
     */
    cursor?: FileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Files from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Files.
     */
    skip?: number
    distinct?: FileScalarFieldEnum | FileScalarFieldEnum[]
  }

  /**
   * File create
   */
  export type FileCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileInclude<ExtArgs> | null
    /**
     * The data needed to create a File.
     */
    data: XOR<FileCreateInput, FileUncheckedCreateInput>
  }

  /**
   * File createMany
   */
  export type FileCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Files.
     */
    data: FileCreateManyInput | FileCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * File update
   */
  export type FileUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileInclude<ExtArgs> | null
    /**
     * The data needed to update a File.
     */
    data: XOR<FileUpdateInput, FileUncheckedUpdateInput>
    /**
     * Choose, which File to update.
     */
    where: FileWhereUniqueInput
  }

  /**
   * File updateMany
   */
  export type FileUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Files.
     */
    data: XOR<FileUpdateManyMutationInput, FileUncheckedUpdateManyInput>
    /**
     * Filter which Files to update
     */
    where?: FileWhereInput
  }

  /**
   * File upsert
   */
  export type FileUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileInclude<ExtArgs> | null
    /**
     * The filter to search for the File to update in case it exists.
     */
    where: FileWhereUniqueInput
    /**
     * In case the File found by the `where` argument doesn't exist, create a new File with this data.
     */
    create: XOR<FileCreateInput, FileUncheckedCreateInput>
    /**
     * In case the File was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FileUpdateInput, FileUncheckedUpdateInput>
  }

  /**
   * File delete
   */
  export type FileDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileInclude<ExtArgs> | null
    /**
     * Filter which File to delete.
     */
    where: FileWhereUniqueInput
  }

  /**
   * File deleteMany
   */
  export type FileDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Files to delete
     */
    where?: FileWhereInput
  }

  /**
   * File.user
   */
  export type File$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * File.course
   */
  export type File$courseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    where?: CourseWhereInput
  }

  /**
   * File without action
   */
  export type FileDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileInclude<ExtArgs> | null
  }


  /**
   * Model Process
   */

  export type AggregateProcess = {
    _count: ProcessCountAggregateOutputType | null
    _avg: ProcessAvgAggregateOutputType | null
    _sum: ProcessSumAggregateOutputType | null
    _min: ProcessMinAggregateOutputType | null
    _max: ProcessMaxAggregateOutputType | null
  }

  export type ProcessAvgAggregateOutputType = {
    id: number | null
    pc_totalProcess: number | null
  }

  export type ProcessSumAggregateOutputType = {
    id: number | null
    pc_totalProcess: number | null
  }

  export type ProcessMinAggregateOutputType = {
    id: number | null
    pc_bluePrintNo: string | null
    pc_imageBluePrint: string | null
    pc_totalProcess: number | null
    pc_userId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type ProcessMaxAggregateOutputType = {
    id: number | null
    pc_bluePrintNo: string | null
    pc_imageBluePrint: string | null
    pc_totalProcess: number | null
    pc_userId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type ProcessCountAggregateOutputType = {
    id: number
    pc_bluePrintNo: number
    pc_imageBluePrint: number
    pc_totalProcess: number
    pc_userId: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    _all: number
  }


  export type ProcessAvgAggregateInputType = {
    id?: true
    pc_totalProcess?: true
  }

  export type ProcessSumAggregateInputType = {
    id?: true
    pc_totalProcess?: true
  }

  export type ProcessMinAggregateInputType = {
    id?: true
    pc_bluePrintNo?: true
    pc_imageBluePrint?: true
    pc_totalProcess?: true
    pc_userId?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type ProcessMaxAggregateInputType = {
    id?: true
    pc_bluePrintNo?: true
    pc_imageBluePrint?: true
    pc_totalProcess?: true
    pc_userId?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type ProcessCountAggregateInputType = {
    id?: true
    pc_bluePrintNo?: true
    pc_imageBluePrint?: true
    pc_totalProcess?: true
    pc_userId?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    _all?: true
  }

  export type ProcessAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Process to aggregate.
     */
    where?: ProcessWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Processes to fetch.
     */
    orderBy?: ProcessOrderByWithRelationInput | ProcessOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProcessWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Processes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Processes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Processes
    **/
    _count?: true | ProcessCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProcessAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProcessSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProcessMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProcessMaxAggregateInputType
  }

  export type GetProcessAggregateType<T extends ProcessAggregateArgs> = {
        [P in keyof T & keyof AggregateProcess]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProcess[P]>
      : GetScalarType<T[P], AggregateProcess[P]>
  }




  export type ProcessGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProcessWhereInput
    orderBy?: ProcessOrderByWithAggregationInput | ProcessOrderByWithAggregationInput[]
    by: ProcessScalarFieldEnum[] | ProcessScalarFieldEnum
    having?: ProcessScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProcessCountAggregateInputType | true
    _avg?: ProcessAvgAggregateInputType
    _sum?: ProcessSumAggregateInputType
    _min?: ProcessMinAggregateInputType
    _max?: ProcessMaxAggregateInputType
  }

  export type ProcessGroupByOutputType = {
    id: number
    pc_bluePrintNo: string
    pc_imageBluePrint: string
    pc_totalProcess: number
    pc_userId: string
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
    _count: ProcessCountAggregateOutputType | null
    _avg: ProcessAvgAggregateOutputType | null
    _sum: ProcessSumAggregateOutputType | null
    _min: ProcessMinAggregateOutputType | null
    _max: ProcessMaxAggregateOutputType | null
  }

  type GetProcessGroupByPayload<T extends ProcessGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProcessGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProcessGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProcessGroupByOutputType[P]>
            : GetScalarType<T[P], ProcessGroupByOutputType[P]>
        }
      >
    >


  export type ProcessSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    pc_bluePrintNo?: boolean
    pc_imageBluePrint?: boolean
    pc_totalProcess?: boolean
    pc_userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    courses?: boolean | Process$coursesArgs<ExtArgs>
    completions?: boolean | Process$completionsArgs<ExtArgs>
    processDetail?: boolean | Process$processDetailArgs<ExtArgs>
    _count?: boolean | ProcessCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["process"]>


  export type ProcessSelectScalar = {
    id?: boolean
    pc_bluePrintNo?: boolean
    pc_imageBluePrint?: boolean
    pc_totalProcess?: boolean
    pc_userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }

  export type ProcessInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    courses?: boolean | Process$coursesArgs<ExtArgs>
    completions?: boolean | Process$completionsArgs<ExtArgs>
    processDetail?: boolean | Process$processDetailArgs<ExtArgs>
    _count?: boolean | ProcessCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $ProcessPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Process"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      courses: Prisma.$CoursePayload<ExtArgs>[]
      completions: Prisma.$UserCourseCompletionPayload<ExtArgs>[]
      processDetail: Prisma.$ProcessDetailPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      pc_bluePrintNo: string
      pc_imageBluePrint: string
      pc_totalProcess: number
      pc_userId: string
      createdAt: Date
      updatedAt: Date
      deletedAt: Date | null
    }, ExtArgs["result"]["process"]>
    composites: {}
  }

  type ProcessGetPayload<S extends boolean | null | undefined | ProcessDefaultArgs> = $Result.GetResult<Prisma.$ProcessPayload, S>

  type ProcessCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ProcessFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ProcessCountAggregateInputType | true
    }

  export interface ProcessDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Process'], meta: { name: 'Process' } }
    /**
     * Find zero or one Process that matches the filter.
     * @param {ProcessFindUniqueArgs} args - Arguments to find a Process
     * @example
     * // Get one Process
     * const process = await prisma.process.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProcessFindUniqueArgs>(args: SelectSubset<T, ProcessFindUniqueArgs<ExtArgs>>): Prisma__ProcessClient<$Result.GetResult<Prisma.$ProcessPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Process that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ProcessFindUniqueOrThrowArgs} args - Arguments to find a Process
     * @example
     * // Get one Process
     * const process = await prisma.process.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProcessFindUniqueOrThrowArgs>(args: SelectSubset<T, ProcessFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProcessClient<$Result.GetResult<Prisma.$ProcessPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Process that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProcessFindFirstArgs} args - Arguments to find a Process
     * @example
     * // Get one Process
     * const process = await prisma.process.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProcessFindFirstArgs>(args?: SelectSubset<T, ProcessFindFirstArgs<ExtArgs>>): Prisma__ProcessClient<$Result.GetResult<Prisma.$ProcessPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Process that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProcessFindFirstOrThrowArgs} args - Arguments to find a Process
     * @example
     * // Get one Process
     * const process = await prisma.process.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProcessFindFirstOrThrowArgs>(args?: SelectSubset<T, ProcessFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProcessClient<$Result.GetResult<Prisma.$ProcessPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Processes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProcessFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Processes
     * const processes = await prisma.process.findMany()
     * 
     * // Get first 10 Processes
     * const processes = await prisma.process.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const processWithIdOnly = await prisma.process.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProcessFindManyArgs>(args?: SelectSubset<T, ProcessFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProcessPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Process.
     * @param {ProcessCreateArgs} args - Arguments to create a Process.
     * @example
     * // Create one Process
     * const Process = await prisma.process.create({
     *   data: {
     *     // ... data to create a Process
     *   }
     * })
     * 
     */
    create<T extends ProcessCreateArgs>(args: SelectSubset<T, ProcessCreateArgs<ExtArgs>>): Prisma__ProcessClient<$Result.GetResult<Prisma.$ProcessPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Processes.
     * @param {ProcessCreateManyArgs} args - Arguments to create many Processes.
     * @example
     * // Create many Processes
     * const process = await prisma.process.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProcessCreateManyArgs>(args?: SelectSubset<T, ProcessCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Process.
     * @param {ProcessDeleteArgs} args - Arguments to delete one Process.
     * @example
     * // Delete one Process
     * const Process = await prisma.process.delete({
     *   where: {
     *     // ... filter to delete one Process
     *   }
     * })
     * 
     */
    delete<T extends ProcessDeleteArgs>(args: SelectSubset<T, ProcessDeleteArgs<ExtArgs>>): Prisma__ProcessClient<$Result.GetResult<Prisma.$ProcessPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Process.
     * @param {ProcessUpdateArgs} args - Arguments to update one Process.
     * @example
     * // Update one Process
     * const process = await prisma.process.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProcessUpdateArgs>(args: SelectSubset<T, ProcessUpdateArgs<ExtArgs>>): Prisma__ProcessClient<$Result.GetResult<Prisma.$ProcessPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Processes.
     * @param {ProcessDeleteManyArgs} args - Arguments to filter Processes to delete.
     * @example
     * // Delete a few Processes
     * const { count } = await prisma.process.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProcessDeleteManyArgs>(args?: SelectSubset<T, ProcessDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Processes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProcessUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Processes
     * const process = await prisma.process.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProcessUpdateManyArgs>(args: SelectSubset<T, ProcessUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Process.
     * @param {ProcessUpsertArgs} args - Arguments to update or create a Process.
     * @example
     * // Update or create a Process
     * const process = await prisma.process.upsert({
     *   create: {
     *     // ... data to create a Process
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Process we want to update
     *   }
     * })
     */
    upsert<T extends ProcessUpsertArgs>(args: SelectSubset<T, ProcessUpsertArgs<ExtArgs>>): Prisma__ProcessClient<$Result.GetResult<Prisma.$ProcessPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Processes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProcessCountArgs} args - Arguments to filter Processes to count.
     * @example
     * // Count the number of Processes
     * const count = await prisma.process.count({
     *   where: {
     *     // ... the filter for the Processes we want to count
     *   }
     * })
    **/
    count<T extends ProcessCountArgs>(
      args?: Subset<T, ProcessCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProcessCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Process.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProcessAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProcessAggregateArgs>(args: Subset<T, ProcessAggregateArgs>): Prisma.PrismaPromise<GetProcessAggregateType<T>>

    /**
     * Group by Process.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProcessGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProcessGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProcessGroupByArgs['orderBy'] }
        : { orderBy?: ProcessGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProcessGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProcessGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Process model
   */
  readonly fields: ProcessFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Process.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProcessClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    courses<T extends Process$coursesArgs<ExtArgs> = {}>(args?: Subset<T, Process$coursesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findMany"> | Null>
    completions<T extends Process$completionsArgs<ExtArgs> = {}>(args?: Subset<T, Process$completionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserCourseCompletionPayload<ExtArgs>, T, "findMany"> | Null>
    processDetail<T extends Process$processDetailArgs<ExtArgs> = {}>(args?: Subset<T, Process$processDetailArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProcessDetailPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Process model
   */ 
  interface ProcessFieldRefs {
    readonly id: FieldRef<"Process", 'Int'>
    readonly pc_bluePrintNo: FieldRef<"Process", 'String'>
    readonly pc_imageBluePrint: FieldRef<"Process", 'String'>
    readonly pc_totalProcess: FieldRef<"Process", 'Int'>
    readonly pc_userId: FieldRef<"Process", 'String'>
    readonly createdAt: FieldRef<"Process", 'DateTime'>
    readonly updatedAt: FieldRef<"Process", 'DateTime'>
    readonly deletedAt: FieldRef<"Process", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Process findUnique
   */
  export type ProcessFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Process
     */
    select?: ProcessSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessInclude<ExtArgs> | null
    /**
     * Filter, which Process to fetch.
     */
    where: ProcessWhereUniqueInput
  }

  /**
   * Process findUniqueOrThrow
   */
  export type ProcessFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Process
     */
    select?: ProcessSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessInclude<ExtArgs> | null
    /**
     * Filter, which Process to fetch.
     */
    where: ProcessWhereUniqueInput
  }

  /**
   * Process findFirst
   */
  export type ProcessFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Process
     */
    select?: ProcessSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessInclude<ExtArgs> | null
    /**
     * Filter, which Process to fetch.
     */
    where?: ProcessWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Processes to fetch.
     */
    orderBy?: ProcessOrderByWithRelationInput | ProcessOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Processes.
     */
    cursor?: ProcessWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Processes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Processes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Processes.
     */
    distinct?: ProcessScalarFieldEnum | ProcessScalarFieldEnum[]
  }

  /**
   * Process findFirstOrThrow
   */
  export type ProcessFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Process
     */
    select?: ProcessSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessInclude<ExtArgs> | null
    /**
     * Filter, which Process to fetch.
     */
    where?: ProcessWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Processes to fetch.
     */
    orderBy?: ProcessOrderByWithRelationInput | ProcessOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Processes.
     */
    cursor?: ProcessWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Processes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Processes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Processes.
     */
    distinct?: ProcessScalarFieldEnum | ProcessScalarFieldEnum[]
  }

  /**
   * Process findMany
   */
  export type ProcessFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Process
     */
    select?: ProcessSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessInclude<ExtArgs> | null
    /**
     * Filter, which Processes to fetch.
     */
    where?: ProcessWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Processes to fetch.
     */
    orderBy?: ProcessOrderByWithRelationInput | ProcessOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Processes.
     */
    cursor?: ProcessWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Processes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Processes.
     */
    skip?: number
    distinct?: ProcessScalarFieldEnum | ProcessScalarFieldEnum[]
  }

  /**
   * Process create
   */
  export type ProcessCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Process
     */
    select?: ProcessSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessInclude<ExtArgs> | null
    /**
     * The data needed to create a Process.
     */
    data: XOR<ProcessCreateInput, ProcessUncheckedCreateInput>
  }

  /**
   * Process createMany
   */
  export type ProcessCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Processes.
     */
    data: ProcessCreateManyInput | ProcessCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Process update
   */
  export type ProcessUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Process
     */
    select?: ProcessSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessInclude<ExtArgs> | null
    /**
     * The data needed to update a Process.
     */
    data: XOR<ProcessUpdateInput, ProcessUncheckedUpdateInput>
    /**
     * Choose, which Process to update.
     */
    where: ProcessWhereUniqueInput
  }

  /**
   * Process updateMany
   */
  export type ProcessUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Processes.
     */
    data: XOR<ProcessUpdateManyMutationInput, ProcessUncheckedUpdateManyInput>
    /**
     * Filter which Processes to update
     */
    where?: ProcessWhereInput
  }

  /**
   * Process upsert
   */
  export type ProcessUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Process
     */
    select?: ProcessSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessInclude<ExtArgs> | null
    /**
     * The filter to search for the Process to update in case it exists.
     */
    where: ProcessWhereUniqueInput
    /**
     * In case the Process found by the `where` argument doesn't exist, create a new Process with this data.
     */
    create: XOR<ProcessCreateInput, ProcessUncheckedCreateInput>
    /**
     * In case the Process was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProcessUpdateInput, ProcessUncheckedUpdateInput>
  }

  /**
   * Process delete
   */
  export type ProcessDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Process
     */
    select?: ProcessSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessInclude<ExtArgs> | null
    /**
     * Filter which Process to delete.
     */
    where: ProcessWhereUniqueInput
  }

  /**
   * Process deleteMany
   */
  export type ProcessDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Processes to delete
     */
    where?: ProcessWhereInput
  }

  /**
   * Process.courses
   */
  export type Process$coursesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    where?: CourseWhereInput
    orderBy?: CourseOrderByWithRelationInput | CourseOrderByWithRelationInput[]
    cursor?: CourseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CourseScalarFieldEnum | CourseScalarFieldEnum[]
  }

  /**
   * Process.completions
   */
  export type Process$completionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCourseCompletion
     */
    select?: UserCourseCompletionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserCourseCompletionInclude<ExtArgs> | null
    where?: UserCourseCompletionWhereInput
    orderBy?: UserCourseCompletionOrderByWithRelationInput | UserCourseCompletionOrderByWithRelationInput[]
    cursor?: UserCourseCompletionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserCourseCompletionScalarFieldEnum | UserCourseCompletionScalarFieldEnum[]
  }

  /**
   * Process.processDetail
   */
  export type Process$processDetailArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcessDetail
     */
    select?: ProcessDetailSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessDetailInclude<ExtArgs> | null
    where?: ProcessDetailWhereInput
    orderBy?: ProcessDetailOrderByWithRelationInput | ProcessDetailOrderByWithRelationInput[]
    cursor?: ProcessDetailWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProcessDetailScalarFieldEnum | ProcessDetailScalarFieldEnum[]
  }

  /**
   * Process without action
   */
  export type ProcessDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Process
     */
    select?: ProcessSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessInclude<ExtArgs> | null
  }


  /**
   * Model ProcessDetail
   */

  export type AggregateProcessDetail = {
    _count: ProcessDetailCountAggregateOutputType | null
    _avg: ProcessDetailAvgAggregateOutputType | null
    _sum: ProcessDetailSumAggregateOutputType | null
    _min: ProcessDetailMinAggregateOutputType | null
    _max: ProcessDetailMaxAggregateOutputType | null
  }

  export type ProcessDetailAvgAggregateOutputType = {
    id: number | null
    pc_amountDay: number | null
  }

  export type ProcessDetailSumAggregateOutputType = {
    id: number | null
    pc_amountDay: number | null
  }

  export type ProcessDetailMinAggregateOutputType = {
    id: number | null
    pc_bluePrintNo: string | null
    pc_processTitle: string | null
    pc_amountDay: number | null
    pc_reasonType: string | null
  }

  export type ProcessDetailMaxAggregateOutputType = {
    id: number | null
    pc_bluePrintNo: string | null
    pc_processTitle: string | null
    pc_amountDay: number | null
    pc_reasonType: string | null
  }

  export type ProcessDetailCountAggregateOutputType = {
    id: number
    pc_bluePrintNo: number
    pc_processTitle: number
    pc_amountDay: number
    pc_reasonType: number
    _all: number
  }


  export type ProcessDetailAvgAggregateInputType = {
    id?: true
    pc_amountDay?: true
  }

  export type ProcessDetailSumAggregateInputType = {
    id?: true
    pc_amountDay?: true
  }

  export type ProcessDetailMinAggregateInputType = {
    id?: true
    pc_bluePrintNo?: true
    pc_processTitle?: true
    pc_amountDay?: true
    pc_reasonType?: true
  }

  export type ProcessDetailMaxAggregateInputType = {
    id?: true
    pc_bluePrintNo?: true
    pc_processTitle?: true
    pc_amountDay?: true
    pc_reasonType?: true
  }

  export type ProcessDetailCountAggregateInputType = {
    id?: true
    pc_bluePrintNo?: true
    pc_processTitle?: true
    pc_amountDay?: true
    pc_reasonType?: true
    _all?: true
  }

  export type ProcessDetailAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProcessDetail to aggregate.
     */
    where?: ProcessDetailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProcessDetails to fetch.
     */
    orderBy?: ProcessDetailOrderByWithRelationInput | ProcessDetailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProcessDetailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProcessDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProcessDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProcessDetails
    **/
    _count?: true | ProcessDetailCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProcessDetailAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProcessDetailSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProcessDetailMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProcessDetailMaxAggregateInputType
  }

  export type GetProcessDetailAggregateType<T extends ProcessDetailAggregateArgs> = {
        [P in keyof T & keyof AggregateProcessDetail]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProcessDetail[P]>
      : GetScalarType<T[P], AggregateProcessDetail[P]>
  }




  export type ProcessDetailGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProcessDetailWhereInput
    orderBy?: ProcessDetailOrderByWithAggregationInput | ProcessDetailOrderByWithAggregationInput[]
    by: ProcessDetailScalarFieldEnum[] | ProcessDetailScalarFieldEnum
    having?: ProcessDetailScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProcessDetailCountAggregateInputType | true
    _avg?: ProcessDetailAvgAggregateInputType
    _sum?: ProcessDetailSumAggregateInputType
    _min?: ProcessDetailMinAggregateInputType
    _max?: ProcessDetailMaxAggregateInputType
  }

  export type ProcessDetailGroupByOutputType = {
    id: number
    pc_bluePrintNo: string
    pc_processTitle: string
    pc_amountDay: number
    pc_reasonType: string
    _count: ProcessDetailCountAggregateOutputType | null
    _avg: ProcessDetailAvgAggregateOutputType | null
    _sum: ProcessDetailSumAggregateOutputType | null
    _min: ProcessDetailMinAggregateOutputType | null
    _max: ProcessDetailMaxAggregateOutputType | null
  }

  type GetProcessDetailGroupByPayload<T extends ProcessDetailGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProcessDetailGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProcessDetailGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProcessDetailGroupByOutputType[P]>
            : GetScalarType<T[P], ProcessDetailGroupByOutputType[P]>
        }
      >
    >


  export type ProcessDetailSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    pc_bluePrintNo?: boolean
    pc_processTitle?: boolean
    pc_amountDay?: boolean
    pc_reasonType?: boolean
    process?: boolean | ProcessDefaultArgs<ExtArgs>
    processBranch?: boolean | ProcessDetail$processBranchArgs<ExtArgs>
    processMat?: boolean | ProcessDetail$processMatArgs<ExtArgs>
    processBom?: boolean | ProcessDetail$processBomArgs<ExtArgs>
    _count?: boolean | ProcessDetailCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["processDetail"]>


  export type ProcessDetailSelectScalar = {
    id?: boolean
    pc_bluePrintNo?: boolean
    pc_processTitle?: boolean
    pc_amountDay?: boolean
    pc_reasonType?: boolean
  }

  export type ProcessDetailInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    process?: boolean | ProcessDefaultArgs<ExtArgs>
    processBranch?: boolean | ProcessDetail$processBranchArgs<ExtArgs>
    processMat?: boolean | ProcessDetail$processMatArgs<ExtArgs>
    processBom?: boolean | ProcessDetail$processBomArgs<ExtArgs>
    _count?: boolean | ProcessDetailCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $ProcessDetailPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProcessDetail"
    objects: {
      process: Prisma.$ProcessPayload<ExtArgs>
      processBranch: Prisma.$ProcessBranchPayload<ExtArgs>[]
      processMat: Prisma.$ProcessMatPayload<ExtArgs>[]
      processBom: Prisma.$ProcessBomPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      pc_bluePrintNo: string
      pc_processTitle: string
      pc_amountDay: number
      pc_reasonType: string
    }, ExtArgs["result"]["processDetail"]>
    composites: {}
  }

  type ProcessDetailGetPayload<S extends boolean | null | undefined | ProcessDetailDefaultArgs> = $Result.GetResult<Prisma.$ProcessDetailPayload, S>

  type ProcessDetailCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ProcessDetailFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ProcessDetailCountAggregateInputType | true
    }

  export interface ProcessDetailDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProcessDetail'], meta: { name: 'ProcessDetail' } }
    /**
     * Find zero or one ProcessDetail that matches the filter.
     * @param {ProcessDetailFindUniqueArgs} args - Arguments to find a ProcessDetail
     * @example
     * // Get one ProcessDetail
     * const processDetail = await prisma.processDetail.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProcessDetailFindUniqueArgs>(args: SelectSubset<T, ProcessDetailFindUniqueArgs<ExtArgs>>): Prisma__ProcessDetailClient<$Result.GetResult<Prisma.$ProcessDetailPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ProcessDetail that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ProcessDetailFindUniqueOrThrowArgs} args - Arguments to find a ProcessDetail
     * @example
     * // Get one ProcessDetail
     * const processDetail = await prisma.processDetail.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProcessDetailFindUniqueOrThrowArgs>(args: SelectSubset<T, ProcessDetailFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProcessDetailClient<$Result.GetResult<Prisma.$ProcessDetailPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ProcessDetail that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProcessDetailFindFirstArgs} args - Arguments to find a ProcessDetail
     * @example
     * // Get one ProcessDetail
     * const processDetail = await prisma.processDetail.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProcessDetailFindFirstArgs>(args?: SelectSubset<T, ProcessDetailFindFirstArgs<ExtArgs>>): Prisma__ProcessDetailClient<$Result.GetResult<Prisma.$ProcessDetailPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ProcessDetail that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProcessDetailFindFirstOrThrowArgs} args - Arguments to find a ProcessDetail
     * @example
     * // Get one ProcessDetail
     * const processDetail = await prisma.processDetail.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProcessDetailFindFirstOrThrowArgs>(args?: SelectSubset<T, ProcessDetailFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProcessDetailClient<$Result.GetResult<Prisma.$ProcessDetailPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ProcessDetails that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProcessDetailFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProcessDetails
     * const processDetails = await prisma.processDetail.findMany()
     * 
     * // Get first 10 ProcessDetails
     * const processDetails = await prisma.processDetail.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const processDetailWithIdOnly = await prisma.processDetail.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProcessDetailFindManyArgs>(args?: SelectSubset<T, ProcessDetailFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProcessDetailPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ProcessDetail.
     * @param {ProcessDetailCreateArgs} args - Arguments to create a ProcessDetail.
     * @example
     * // Create one ProcessDetail
     * const ProcessDetail = await prisma.processDetail.create({
     *   data: {
     *     // ... data to create a ProcessDetail
     *   }
     * })
     * 
     */
    create<T extends ProcessDetailCreateArgs>(args: SelectSubset<T, ProcessDetailCreateArgs<ExtArgs>>): Prisma__ProcessDetailClient<$Result.GetResult<Prisma.$ProcessDetailPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ProcessDetails.
     * @param {ProcessDetailCreateManyArgs} args - Arguments to create many ProcessDetails.
     * @example
     * // Create many ProcessDetails
     * const processDetail = await prisma.processDetail.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProcessDetailCreateManyArgs>(args?: SelectSubset<T, ProcessDetailCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ProcessDetail.
     * @param {ProcessDetailDeleteArgs} args - Arguments to delete one ProcessDetail.
     * @example
     * // Delete one ProcessDetail
     * const ProcessDetail = await prisma.processDetail.delete({
     *   where: {
     *     // ... filter to delete one ProcessDetail
     *   }
     * })
     * 
     */
    delete<T extends ProcessDetailDeleteArgs>(args: SelectSubset<T, ProcessDetailDeleteArgs<ExtArgs>>): Prisma__ProcessDetailClient<$Result.GetResult<Prisma.$ProcessDetailPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ProcessDetail.
     * @param {ProcessDetailUpdateArgs} args - Arguments to update one ProcessDetail.
     * @example
     * // Update one ProcessDetail
     * const processDetail = await prisma.processDetail.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProcessDetailUpdateArgs>(args: SelectSubset<T, ProcessDetailUpdateArgs<ExtArgs>>): Prisma__ProcessDetailClient<$Result.GetResult<Prisma.$ProcessDetailPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ProcessDetails.
     * @param {ProcessDetailDeleteManyArgs} args - Arguments to filter ProcessDetails to delete.
     * @example
     * // Delete a few ProcessDetails
     * const { count } = await prisma.processDetail.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProcessDetailDeleteManyArgs>(args?: SelectSubset<T, ProcessDetailDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProcessDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProcessDetailUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProcessDetails
     * const processDetail = await prisma.processDetail.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProcessDetailUpdateManyArgs>(args: SelectSubset<T, ProcessDetailUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ProcessDetail.
     * @param {ProcessDetailUpsertArgs} args - Arguments to update or create a ProcessDetail.
     * @example
     * // Update or create a ProcessDetail
     * const processDetail = await prisma.processDetail.upsert({
     *   create: {
     *     // ... data to create a ProcessDetail
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProcessDetail we want to update
     *   }
     * })
     */
    upsert<T extends ProcessDetailUpsertArgs>(args: SelectSubset<T, ProcessDetailUpsertArgs<ExtArgs>>): Prisma__ProcessDetailClient<$Result.GetResult<Prisma.$ProcessDetailPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ProcessDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProcessDetailCountArgs} args - Arguments to filter ProcessDetails to count.
     * @example
     * // Count the number of ProcessDetails
     * const count = await prisma.processDetail.count({
     *   where: {
     *     // ... the filter for the ProcessDetails we want to count
     *   }
     * })
    **/
    count<T extends ProcessDetailCountArgs>(
      args?: Subset<T, ProcessDetailCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProcessDetailCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProcessDetail.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProcessDetailAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProcessDetailAggregateArgs>(args: Subset<T, ProcessDetailAggregateArgs>): Prisma.PrismaPromise<GetProcessDetailAggregateType<T>>

    /**
     * Group by ProcessDetail.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProcessDetailGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProcessDetailGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProcessDetailGroupByArgs['orderBy'] }
        : { orderBy?: ProcessDetailGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProcessDetailGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProcessDetailGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProcessDetail model
   */
  readonly fields: ProcessDetailFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProcessDetail.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProcessDetailClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    process<T extends ProcessDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProcessDefaultArgs<ExtArgs>>): Prisma__ProcessClient<$Result.GetResult<Prisma.$ProcessPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    processBranch<T extends ProcessDetail$processBranchArgs<ExtArgs> = {}>(args?: Subset<T, ProcessDetail$processBranchArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProcessBranchPayload<ExtArgs>, T, "findMany"> | Null>
    processMat<T extends ProcessDetail$processMatArgs<ExtArgs> = {}>(args?: Subset<T, ProcessDetail$processMatArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProcessMatPayload<ExtArgs>, T, "findMany"> | Null>
    processBom<T extends ProcessDetail$processBomArgs<ExtArgs> = {}>(args?: Subset<T, ProcessDetail$processBomArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProcessBomPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProcessDetail model
   */ 
  interface ProcessDetailFieldRefs {
    readonly id: FieldRef<"ProcessDetail", 'Int'>
    readonly pc_bluePrintNo: FieldRef<"ProcessDetail", 'String'>
    readonly pc_processTitle: FieldRef<"ProcessDetail", 'String'>
    readonly pc_amountDay: FieldRef<"ProcessDetail", 'Int'>
    readonly pc_reasonType: FieldRef<"ProcessDetail", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ProcessDetail findUnique
   */
  export type ProcessDetailFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcessDetail
     */
    select?: ProcessDetailSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessDetailInclude<ExtArgs> | null
    /**
     * Filter, which ProcessDetail to fetch.
     */
    where: ProcessDetailWhereUniqueInput
  }

  /**
   * ProcessDetail findUniqueOrThrow
   */
  export type ProcessDetailFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcessDetail
     */
    select?: ProcessDetailSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessDetailInclude<ExtArgs> | null
    /**
     * Filter, which ProcessDetail to fetch.
     */
    where: ProcessDetailWhereUniqueInput
  }

  /**
   * ProcessDetail findFirst
   */
  export type ProcessDetailFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcessDetail
     */
    select?: ProcessDetailSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessDetailInclude<ExtArgs> | null
    /**
     * Filter, which ProcessDetail to fetch.
     */
    where?: ProcessDetailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProcessDetails to fetch.
     */
    orderBy?: ProcessDetailOrderByWithRelationInput | ProcessDetailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProcessDetails.
     */
    cursor?: ProcessDetailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProcessDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProcessDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProcessDetails.
     */
    distinct?: ProcessDetailScalarFieldEnum | ProcessDetailScalarFieldEnum[]
  }

  /**
   * ProcessDetail findFirstOrThrow
   */
  export type ProcessDetailFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcessDetail
     */
    select?: ProcessDetailSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessDetailInclude<ExtArgs> | null
    /**
     * Filter, which ProcessDetail to fetch.
     */
    where?: ProcessDetailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProcessDetails to fetch.
     */
    orderBy?: ProcessDetailOrderByWithRelationInput | ProcessDetailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProcessDetails.
     */
    cursor?: ProcessDetailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProcessDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProcessDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProcessDetails.
     */
    distinct?: ProcessDetailScalarFieldEnum | ProcessDetailScalarFieldEnum[]
  }

  /**
   * ProcessDetail findMany
   */
  export type ProcessDetailFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcessDetail
     */
    select?: ProcessDetailSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessDetailInclude<ExtArgs> | null
    /**
     * Filter, which ProcessDetails to fetch.
     */
    where?: ProcessDetailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProcessDetails to fetch.
     */
    orderBy?: ProcessDetailOrderByWithRelationInput | ProcessDetailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProcessDetails.
     */
    cursor?: ProcessDetailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProcessDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProcessDetails.
     */
    skip?: number
    distinct?: ProcessDetailScalarFieldEnum | ProcessDetailScalarFieldEnum[]
  }

  /**
   * ProcessDetail create
   */
  export type ProcessDetailCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcessDetail
     */
    select?: ProcessDetailSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessDetailInclude<ExtArgs> | null
    /**
     * The data needed to create a ProcessDetail.
     */
    data: XOR<ProcessDetailCreateInput, ProcessDetailUncheckedCreateInput>
  }

  /**
   * ProcessDetail createMany
   */
  export type ProcessDetailCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProcessDetails.
     */
    data: ProcessDetailCreateManyInput | ProcessDetailCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProcessDetail update
   */
  export type ProcessDetailUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcessDetail
     */
    select?: ProcessDetailSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessDetailInclude<ExtArgs> | null
    /**
     * The data needed to update a ProcessDetail.
     */
    data: XOR<ProcessDetailUpdateInput, ProcessDetailUncheckedUpdateInput>
    /**
     * Choose, which ProcessDetail to update.
     */
    where: ProcessDetailWhereUniqueInput
  }

  /**
   * ProcessDetail updateMany
   */
  export type ProcessDetailUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProcessDetails.
     */
    data: XOR<ProcessDetailUpdateManyMutationInput, ProcessDetailUncheckedUpdateManyInput>
    /**
     * Filter which ProcessDetails to update
     */
    where?: ProcessDetailWhereInput
  }

  /**
   * ProcessDetail upsert
   */
  export type ProcessDetailUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcessDetail
     */
    select?: ProcessDetailSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessDetailInclude<ExtArgs> | null
    /**
     * The filter to search for the ProcessDetail to update in case it exists.
     */
    where: ProcessDetailWhereUniqueInput
    /**
     * In case the ProcessDetail found by the `where` argument doesn't exist, create a new ProcessDetail with this data.
     */
    create: XOR<ProcessDetailCreateInput, ProcessDetailUncheckedCreateInput>
    /**
     * In case the ProcessDetail was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProcessDetailUpdateInput, ProcessDetailUncheckedUpdateInput>
  }

  /**
   * ProcessDetail delete
   */
  export type ProcessDetailDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcessDetail
     */
    select?: ProcessDetailSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessDetailInclude<ExtArgs> | null
    /**
     * Filter which ProcessDetail to delete.
     */
    where: ProcessDetailWhereUniqueInput
  }

  /**
   * ProcessDetail deleteMany
   */
  export type ProcessDetailDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProcessDetails to delete
     */
    where?: ProcessDetailWhereInput
  }

  /**
   * ProcessDetail.processBranch
   */
  export type ProcessDetail$processBranchArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcessBranch
     */
    select?: ProcessBranchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessBranchInclude<ExtArgs> | null
    where?: ProcessBranchWhereInput
    orderBy?: ProcessBranchOrderByWithRelationInput | ProcessBranchOrderByWithRelationInput[]
    cursor?: ProcessBranchWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProcessBranchScalarFieldEnum | ProcessBranchScalarFieldEnum[]
  }

  /**
   * ProcessDetail.processMat
   */
  export type ProcessDetail$processMatArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcessMat
     */
    select?: ProcessMatSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessMatInclude<ExtArgs> | null
    where?: ProcessMatWhereInput
    orderBy?: ProcessMatOrderByWithRelationInput | ProcessMatOrderByWithRelationInput[]
    cursor?: ProcessMatWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProcessMatScalarFieldEnum | ProcessMatScalarFieldEnum[]
  }

  /**
   * ProcessDetail.processBom
   */
  export type ProcessDetail$processBomArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcessBom
     */
    select?: ProcessBomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessBomInclude<ExtArgs> | null
    where?: ProcessBomWhereInput
    orderBy?: ProcessBomOrderByWithRelationInput | ProcessBomOrderByWithRelationInput[]
    cursor?: ProcessBomWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProcessBomScalarFieldEnum | ProcessBomScalarFieldEnum[]
  }

  /**
   * ProcessDetail without action
   */
  export type ProcessDetailDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcessDetail
     */
    select?: ProcessDetailSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessDetailInclude<ExtArgs> | null
  }


  /**
   * Model ProcessBranch
   */

  export type AggregateProcessBranch = {
    _count: ProcessBranchCountAggregateOutputType | null
    _avg: ProcessBranchAvgAggregateOutputType | null
    _sum: ProcessBranchSumAggregateOutputType | null
    _min: ProcessBranchMinAggregateOutputType | null
    _max: ProcessBranchMaxAggregateOutputType | null
  }

  export type ProcessBranchAvgAggregateOutputType = {
    id: number | null
    pc_processDetailId: number | null
  }

  export type ProcessBranchSumAggregateOutputType = {
    id: number | null
    pc_processDetailId: number | null
  }

  export type ProcessBranchMinAggregateOutputType = {
    id: number | null
    pc_processDetailId: number | null
    pc_remark: string | null
  }

  export type ProcessBranchMaxAggregateOutputType = {
    id: number | null
    pc_processDetailId: number | null
    pc_remark: string | null
  }

  export type ProcessBranchCountAggregateOutputType = {
    id: number
    pc_processDetailId: number
    pc_remark: number
    _all: number
  }


  export type ProcessBranchAvgAggregateInputType = {
    id?: true
    pc_processDetailId?: true
  }

  export type ProcessBranchSumAggregateInputType = {
    id?: true
    pc_processDetailId?: true
  }

  export type ProcessBranchMinAggregateInputType = {
    id?: true
    pc_processDetailId?: true
    pc_remark?: true
  }

  export type ProcessBranchMaxAggregateInputType = {
    id?: true
    pc_processDetailId?: true
    pc_remark?: true
  }

  export type ProcessBranchCountAggregateInputType = {
    id?: true
    pc_processDetailId?: true
    pc_remark?: true
    _all?: true
  }

  export type ProcessBranchAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProcessBranch to aggregate.
     */
    where?: ProcessBranchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProcessBranches to fetch.
     */
    orderBy?: ProcessBranchOrderByWithRelationInput | ProcessBranchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProcessBranchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProcessBranches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProcessBranches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProcessBranches
    **/
    _count?: true | ProcessBranchCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProcessBranchAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProcessBranchSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProcessBranchMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProcessBranchMaxAggregateInputType
  }

  export type GetProcessBranchAggregateType<T extends ProcessBranchAggregateArgs> = {
        [P in keyof T & keyof AggregateProcessBranch]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProcessBranch[P]>
      : GetScalarType<T[P], AggregateProcessBranch[P]>
  }




  export type ProcessBranchGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProcessBranchWhereInput
    orderBy?: ProcessBranchOrderByWithAggregationInput | ProcessBranchOrderByWithAggregationInput[]
    by: ProcessBranchScalarFieldEnum[] | ProcessBranchScalarFieldEnum
    having?: ProcessBranchScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProcessBranchCountAggregateInputType | true
    _avg?: ProcessBranchAvgAggregateInputType
    _sum?: ProcessBranchSumAggregateInputType
    _min?: ProcessBranchMinAggregateInputType
    _max?: ProcessBranchMaxAggregateInputType
  }

  export type ProcessBranchGroupByOutputType = {
    id: number
    pc_processDetailId: number
    pc_remark: string
    _count: ProcessBranchCountAggregateOutputType | null
    _avg: ProcessBranchAvgAggregateOutputType | null
    _sum: ProcessBranchSumAggregateOutputType | null
    _min: ProcessBranchMinAggregateOutputType | null
    _max: ProcessBranchMaxAggregateOutputType | null
  }

  type GetProcessBranchGroupByPayload<T extends ProcessBranchGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProcessBranchGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProcessBranchGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProcessBranchGroupByOutputType[P]>
            : GetScalarType<T[P], ProcessBranchGroupByOutputType[P]>
        }
      >
    >


  export type ProcessBranchSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    pc_processDetailId?: boolean
    pc_remark?: boolean
    processDetail?: boolean | ProcessDetailDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["processBranch"]>


  export type ProcessBranchSelectScalar = {
    id?: boolean
    pc_processDetailId?: boolean
    pc_remark?: boolean
  }

  export type ProcessBranchInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    processDetail?: boolean | ProcessDetailDefaultArgs<ExtArgs>
  }

  export type $ProcessBranchPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProcessBranch"
    objects: {
      processDetail: Prisma.$ProcessDetailPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      pc_processDetailId: number
      pc_remark: string
    }, ExtArgs["result"]["processBranch"]>
    composites: {}
  }

  type ProcessBranchGetPayload<S extends boolean | null | undefined | ProcessBranchDefaultArgs> = $Result.GetResult<Prisma.$ProcessBranchPayload, S>

  type ProcessBranchCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ProcessBranchFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ProcessBranchCountAggregateInputType | true
    }

  export interface ProcessBranchDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProcessBranch'], meta: { name: 'ProcessBranch' } }
    /**
     * Find zero or one ProcessBranch that matches the filter.
     * @param {ProcessBranchFindUniqueArgs} args - Arguments to find a ProcessBranch
     * @example
     * // Get one ProcessBranch
     * const processBranch = await prisma.processBranch.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProcessBranchFindUniqueArgs>(args: SelectSubset<T, ProcessBranchFindUniqueArgs<ExtArgs>>): Prisma__ProcessBranchClient<$Result.GetResult<Prisma.$ProcessBranchPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ProcessBranch that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ProcessBranchFindUniqueOrThrowArgs} args - Arguments to find a ProcessBranch
     * @example
     * // Get one ProcessBranch
     * const processBranch = await prisma.processBranch.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProcessBranchFindUniqueOrThrowArgs>(args: SelectSubset<T, ProcessBranchFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProcessBranchClient<$Result.GetResult<Prisma.$ProcessBranchPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ProcessBranch that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProcessBranchFindFirstArgs} args - Arguments to find a ProcessBranch
     * @example
     * // Get one ProcessBranch
     * const processBranch = await prisma.processBranch.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProcessBranchFindFirstArgs>(args?: SelectSubset<T, ProcessBranchFindFirstArgs<ExtArgs>>): Prisma__ProcessBranchClient<$Result.GetResult<Prisma.$ProcessBranchPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ProcessBranch that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProcessBranchFindFirstOrThrowArgs} args - Arguments to find a ProcessBranch
     * @example
     * // Get one ProcessBranch
     * const processBranch = await prisma.processBranch.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProcessBranchFindFirstOrThrowArgs>(args?: SelectSubset<T, ProcessBranchFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProcessBranchClient<$Result.GetResult<Prisma.$ProcessBranchPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ProcessBranches that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProcessBranchFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProcessBranches
     * const processBranches = await prisma.processBranch.findMany()
     * 
     * // Get first 10 ProcessBranches
     * const processBranches = await prisma.processBranch.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const processBranchWithIdOnly = await prisma.processBranch.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProcessBranchFindManyArgs>(args?: SelectSubset<T, ProcessBranchFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProcessBranchPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ProcessBranch.
     * @param {ProcessBranchCreateArgs} args - Arguments to create a ProcessBranch.
     * @example
     * // Create one ProcessBranch
     * const ProcessBranch = await prisma.processBranch.create({
     *   data: {
     *     // ... data to create a ProcessBranch
     *   }
     * })
     * 
     */
    create<T extends ProcessBranchCreateArgs>(args: SelectSubset<T, ProcessBranchCreateArgs<ExtArgs>>): Prisma__ProcessBranchClient<$Result.GetResult<Prisma.$ProcessBranchPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ProcessBranches.
     * @param {ProcessBranchCreateManyArgs} args - Arguments to create many ProcessBranches.
     * @example
     * // Create many ProcessBranches
     * const processBranch = await prisma.processBranch.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProcessBranchCreateManyArgs>(args?: SelectSubset<T, ProcessBranchCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ProcessBranch.
     * @param {ProcessBranchDeleteArgs} args - Arguments to delete one ProcessBranch.
     * @example
     * // Delete one ProcessBranch
     * const ProcessBranch = await prisma.processBranch.delete({
     *   where: {
     *     // ... filter to delete one ProcessBranch
     *   }
     * })
     * 
     */
    delete<T extends ProcessBranchDeleteArgs>(args: SelectSubset<T, ProcessBranchDeleteArgs<ExtArgs>>): Prisma__ProcessBranchClient<$Result.GetResult<Prisma.$ProcessBranchPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ProcessBranch.
     * @param {ProcessBranchUpdateArgs} args - Arguments to update one ProcessBranch.
     * @example
     * // Update one ProcessBranch
     * const processBranch = await prisma.processBranch.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProcessBranchUpdateArgs>(args: SelectSubset<T, ProcessBranchUpdateArgs<ExtArgs>>): Prisma__ProcessBranchClient<$Result.GetResult<Prisma.$ProcessBranchPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ProcessBranches.
     * @param {ProcessBranchDeleteManyArgs} args - Arguments to filter ProcessBranches to delete.
     * @example
     * // Delete a few ProcessBranches
     * const { count } = await prisma.processBranch.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProcessBranchDeleteManyArgs>(args?: SelectSubset<T, ProcessBranchDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProcessBranches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProcessBranchUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProcessBranches
     * const processBranch = await prisma.processBranch.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProcessBranchUpdateManyArgs>(args: SelectSubset<T, ProcessBranchUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ProcessBranch.
     * @param {ProcessBranchUpsertArgs} args - Arguments to update or create a ProcessBranch.
     * @example
     * // Update or create a ProcessBranch
     * const processBranch = await prisma.processBranch.upsert({
     *   create: {
     *     // ... data to create a ProcessBranch
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProcessBranch we want to update
     *   }
     * })
     */
    upsert<T extends ProcessBranchUpsertArgs>(args: SelectSubset<T, ProcessBranchUpsertArgs<ExtArgs>>): Prisma__ProcessBranchClient<$Result.GetResult<Prisma.$ProcessBranchPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ProcessBranches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProcessBranchCountArgs} args - Arguments to filter ProcessBranches to count.
     * @example
     * // Count the number of ProcessBranches
     * const count = await prisma.processBranch.count({
     *   where: {
     *     // ... the filter for the ProcessBranches we want to count
     *   }
     * })
    **/
    count<T extends ProcessBranchCountArgs>(
      args?: Subset<T, ProcessBranchCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProcessBranchCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProcessBranch.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProcessBranchAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProcessBranchAggregateArgs>(args: Subset<T, ProcessBranchAggregateArgs>): Prisma.PrismaPromise<GetProcessBranchAggregateType<T>>

    /**
     * Group by ProcessBranch.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProcessBranchGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProcessBranchGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProcessBranchGroupByArgs['orderBy'] }
        : { orderBy?: ProcessBranchGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProcessBranchGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProcessBranchGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProcessBranch model
   */
  readonly fields: ProcessBranchFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProcessBranch.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProcessBranchClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    processDetail<T extends ProcessDetailDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProcessDetailDefaultArgs<ExtArgs>>): Prisma__ProcessDetailClient<$Result.GetResult<Prisma.$ProcessDetailPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProcessBranch model
   */ 
  interface ProcessBranchFieldRefs {
    readonly id: FieldRef<"ProcessBranch", 'Int'>
    readonly pc_processDetailId: FieldRef<"ProcessBranch", 'Int'>
    readonly pc_remark: FieldRef<"ProcessBranch", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ProcessBranch findUnique
   */
  export type ProcessBranchFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcessBranch
     */
    select?: ProcessBranchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessBranchInclude<ExtArgs> | null
    /**
     * Filter, which ProcessBranch to fetch.
     */
    where: ProcessBranchWhereUniqueInput
  }

  /**
   * ProcessBranch findUniqueOrThrow
   */
  export type ProcessBranchFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcessBranch
     */
    select?: ProcessBranchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessBranchInclude<ExtArgs> | null
    /**
     * Filter, which ProcessBranch to fetch.
     */
    where: ProcessBranchWhereUniqueInput
  }

  /**
   * ProcessBranch findFirst
   */
  export type ProcessBranchFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcessBranch
     */
    select?: ProcessBranchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessBranchInclude<ExtArgs> | null
    /**
     * Filter, which ProcessBranch to fetch.
     */
    where?: ProcessBranchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProcessBranches to fetch.
     */
    orderBy?: ProcessBranchOrderByWithRelationInput | ProcessBranchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProcessBranches.
     */
    cursor?: ProcessBranchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProcessBranches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProcessBranches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProcessBranches.
     */
    distinct?: ProcessBranchScalarFieldEnum | ProcessBranchScalarFieldEnum[]
  }

  /**
   * ProcessBranch findFirstOrThrow
   */
  export type ProcessBranchFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcessBranch
     */
    select?: ProcessBranchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessBranchInclude<ExtArgs> | null
    /**
     * Filter, which ProcessBranch to fetch.
     */
    where?: ProcessBranchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProcessBranches to fetch.
     */
    orderBy?: ProcessBranchOrderByWithRelationInput | ProcessBranchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProcessBranches.
     */
    cursor?: ProcessBranchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProcessBranches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProcessBranches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProcessBranches.
     */
    distinct?: ProcessBranchScalarFieldEnum | ProcessBranchScalarFieldEnum[]
  }

  /**
   * ProcessBranch findMany
   */
  export type ProcessBranchFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcessBranch
     */
    select?: ProcessBranchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessBranchInclude<ExtArgs> | null
    /**
     * Filter, which ProcessBranches to fetch.
     */
    where?: ProcessBranchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProcessBranches to fetch.
     */
    orderBy?: ProcessBranchOrderByWithRelationInput | ProcessBranchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProcessBranches.
     */
    cursor?: ProcessBranchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProcessBranches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProcessBranches.
     */
    skip?: number
    distinct?: ProcessBranchScalarFieldEnum | ProcessBranchScalarFieldEnum[]
  }

  /**
   * ProcessBranch create
   */
  export type ProcessBranchCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcessBranch
     */
    select?: ProcessBranchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessBranchInclude<ExtArgs> | null
    /**
     * The data needed to create a ProcessBranch.
     */
    data: XOR<ProcessBranchCreateInput, ProcessBranchUncheckedCreateInput>
  }

  /**
   * ProcessBranch createMany
   */
  export type ProcessBranchCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProcessBranches.
     */
    data: ProcessBranchCreateManyInput | ProcessBranchCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProcessBranch update
   */
  export type ProcessBranchUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcessBranch
     */
    select?: ProcessBranchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessBranchInclude<ExtArgs> | null
    /**
     * The data needed to update a ProcessBranch.
     */
    data: XOR<ProcessBranchUpdateInput, ProcessBranchUncheckedUpdateInput>
    /**
     * Choose, which ProcessBranch to update.
     */
    where: ProcessBranchWhereUniqueInput
  }

  /**
   * ProcessBranch updateMany
   */
  export type ProcessBranchUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProcessBranches.
     */
    data: XOR<ProcessBranchUpdateManyMutationInput, ProcessBranchUncheckedUpdateManyInput>
    /**
     * Filter which ProcessBranches to update
     */
    where?: ProcessBranchWhereInput
  }

  /**
   * ProcessBranch upsert
   */
  export type ProcessBranchUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcessBranch
     */
    select?: ProcessBranchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessBranchInclude<ExtArgs> | null
    /**
     * The filter to search for the ProcessBranch to update in case it exists.
     */
    where: ProcessBranchWhereUniqueInput
    /**
     * In case the ProcessBranch found by the `where` argument doesn't exist, create a new ProcessBranch with this data.
     */
    create: XOR<ProcessBranchCreateInput, ProcessBranchUncheckedCreateInput>
    /**
     * In case the ProcessBranch was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProcessBranchUpdateInput, ProcessBranchUncheckedUpdateInput>
  }

  /**
   * ProcessBranch delete
   */
  export type ProcessBranchDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcessBranch
     */
    select?: ProcessBranchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessBranchInclude<ExtArgs> | null
    /**
     * Filter which ProcessBranch to delete.
     */
    where: ProcessBranchWhereUniqueInput
  }

  /**
   * ProcessBranch deleteMany
   */
  export type ProcessBranchDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProcessBranches to delete
     */
    where?: ProcessBranchWhereInput
  }

  /**
   * ProcessBranch without action
   */
  export type ProcessBranchDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcessBranch
     */
    select?: ProcessBranchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessBranchInclude<ExtArgs> | null
  }


  /**
   * Model ProcessMat
   */

  export type AggregateProcessMat = {
    _count: ProcessMatCountAggregateOutputType | null
    _avg: ProcessMatAvgAggregateOutputType | null
    _sum: ProcessMatSumAggregateOutputType | null
    _min: ProcessMatMinAggregateOutputType | null
    _max: ProcessMatMaxAggregateOutputType | null
  }

  export type ProcessMatAvgAggregateOutputType = {
    id: number | null
    pc_processDetailId: number | null
    pc_matamount: number | null
  }

  export type ProcessMatSumAggregateOutputType = {
    id: number | null
    pc_processDetailId: number | null
    pc_matamount: number | null
  }

  export type ProcessMatMinAggregateOutputType = {
    id: number | null
    pc_processDetailId: number | null
    pc_matId: string | null
    pc_matamount: number | null
  }

  export type ProcessMatMaxAggregateOutputType = {
    id: number | null
    pc_processDetailId: number | null
    pc_matId: string | null
    pc_matamount: number | null
  }

  export type ProcessMatCountAggregateOutputType = {
    id: number
    pc_processDetailId: number
    pc_matId: number
    pc_matamount: number
    _all: number
  }


  export type ProcessMatAvgAggregateInputType = {
    id?: true
    pc_processDetailId?: true
    pc_matamount?: true
  }

  export type ProcessMatSumAggregateInputType = {
    id?: true
    pc_processDetailId?: true
    pc_matamount?: true
  }

  export type ProcessMatMinAggregateInputType = {
    id?: true
    pc_processDetailId?: true
    pc_matId?: true
    pc_matamount?: true
  }

  export type ProcessMatMaxAggregateInputType = {
    id?: true
    pc_processDetailId?: true
    pc_matId?: true
    pc_matamount?: true
  }

  export type ProcessMatCountAggregateInputType = {
    id?: true
    pc_processDetailId?: true
    pc_matId?: true
    pc_matamount?: true
    _all?: true
  }

  export type ProcessMatAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProcessMat to aggregate.
     */
    where?: ProcessMatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProcessMats to fetch.
     */
    orderBy?: ProcessMatOrderByWithRelationInput | ProcessMatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProcessMatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProcessMats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProcessMats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProcessMats
    **/
    _count?: true | ProcessMatCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProcessMatAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProcessMatSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProcessMatMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProcessMatMaxAggregateInputType
  }

  export type GetProcessMatAggregateType<T extends ProcessMatAggregateArgs> = {
        [P in keyof T & keyof AggregateProcessMat]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProcessMat[P]>
      : GetScalarType<T[P], AggregateProcessMat[P]>
  }




  export type ProcessMatGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProcessMatWhereInput
    orderBy?: ProcessMatOrderByWithAggregationInput | ProcessMatOrderByWithAggregationInput[]
    by: ProcessMatScalarFieldEnum[] | ProcessMatScalarFieldEnum
    having?: ProcessMatScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProcessMatCountAggregateInputType | true
    _avg?: ProcessMatAvgAggregateInputType
    _sum?: ProcessMatSumAggregateInputType
    _min?: ProcessMatMinAggregateInputType
    _max?: ProcessMatMaxAggregateInputType
  }

  export type ProcessMatGroupByOutputType = {
    id: number
    pc_processDetailId: number
    pc_matId: string
    pc_matamount: number
    _count: ProcessMatCountAggregateOutputType | null
    _avg: ProcessMatAvgAggregateOutputType | null
    _sum: ProcessMatSumAggregateOutputType | null
    _min: ProcessMatMinAggregateOutputType | null
    _max: ProcessMatMaxAggregateOutputType | null
  }

  type GetProcessMatGroupByPayload<T extends ProcessMatGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProcessMatGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProcessMatGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProcessMatGroupByOutputType[P]>
            : GetScalarType<T[P], ProcessMatGroupByOutputType[P]>
        }
      >
    >


  export type ProcessMatSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    pc_processDetailId?: boolean
    pc_matId?: boolean
    pc_matamount?: boolean
    stock?: boolean | StockDefaultArgs<ExtArgs>
    processDetail?: boolean | ProcessDetailDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["processMat"]>


  export type ProcessMatSelectScalar = {
    id?: boolean
    pc_processDetailId?: boolean
    pc_matId?: boolean
    pc_matamount?: boolean
  }

  export type ProcessMatInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    stock?: boolean | StockDefaultArgs<ExtArgs>
    processDetail?: boolean | ProcessDetailDefaultArgs<ExtArgs>
  }

  export type $ProcessMatPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProcessMat"
    objects: {
      stock: Prisma.$StockPayload<ExtArgs>
      processDetail: Prisma.$ProcessDetailPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      pc_processDetailId: number
      pc_matId: string
      pc_matamount: number
    }, ExtArgs["result"]["processMat"]>
    composites: {}
  }

  type ProcessMatGetPayload<S extends boolean | null | undefined | ProcessMatDefaultArgs> = $Result.GetResult<Prisma.$ProcessMatPayload, S>

  type ProcessMatCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ProcessMatFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ProcessMatCountAggregateInputType | true
    }

  export interface ProcessMatDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProcessMat'], meta: { name: 'ProcessMat' } }
    /**
     * Find zero or one ProcessMat that matches the filter.
     * @param {ProcessMatFindUniqueArgs} args - Arguments to find a ProcessMat
     * @example
     * // Get one ProcessMat
     * const processMat = await prisma.processMat.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProcessMatFindUniqueArgs>(args: SelectSubset<T, ProcessMatFindUniqueArgs<ExtArgs>>): Prisma__ProcessMatClient<$Result.GetResult<Prisma.$ProcessMatPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ProcessMat that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ProcessMatFindUniqueOrThrowArgs} args - Arguments to find a ProcessMat
     * @example
     * // Get one ProcessMat
     * const processMat = await prisma.processMat.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProcessMatFindUniqueOrThrowArgs>(args: SelectSubset<T, ProcessMatFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProcessMatClient<$Result.GetResult<Prisma.$ProcessMatPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ProcessMat that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProcessMatFindFirstArgs} args - Arguments to find a ProcessMat
     * @example
     * // Get one ProcessMat
     * const processMat = await prisma.processMat.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProcessMatFindFirstArgs>(args?: SelectSubset<T, ProcessMatFindFirstArgs<ExtArgs>>): Prisma__ProcessMatClient<$Result.GetResult<Prisma.$ProcessMatPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ProcessMat that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProcessMatFindFirstOrThrowArgs} args - Arguments to find a ProcessMat
     * @example
     * // Get one ProcessMat
     * const processMat = await prisma.processMat.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProcessMatFindFirstOrThrowArgs>(args?: SelectSubset<T, ProcessMatFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProcessMatClient<$Result.GetResult<Prisma.$ProcessMatPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ProcessMats that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProcessMatFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProcessMats
     * const processMats = await prisma.processMat.findMany()
     * 
     * // Get first 10 ProcessMats
     * const processMats = await prisma.processMat.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const processMatWithIdOnly = await prisma.processMat.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProcessMatFindManyArgs>(args?: SelectSubset<T, ProcessMatFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProcessMatPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ProcessMat.
     * @param {ProcessMatCreateArgs} args - Arguments to create a ProcessMat.
     * @example
     * // Create one ProcessMat
     * const ProcessMat = await prisma.processMat.create({
     *   data: {
     *     // ... data to create a ProcessMat
     *   }
     * })
     * 
     */
    create<T extends ProcessMatCreateArgs>(args: SelectSubset<T, ProcessMatCreateArgs<ExtArgs>>): Prisma__ProcessMatClient<$Result.GetResult<Prisma.$ProcessMatPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ProcessMats.
     * @param {ProcessMatCreateManyArgs} args - Arguments to create many ProcessMats.
     * @example
     * // Create many ProcessMats
     * const processMat = await prisma.processMat.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProcessMatCreateManyArgs>(args?: SelectSubset<T, ProcessMatCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ProcessMat.
     * @param {ProcessMatDeleteArgs} args - Arguments to delete one ProcessMat.
     * @example
     * // Delete one ProcessMat
     * const ProcessMat = await prisma.processMat.delete({
     *   where: {
     *     // ... filter to delete one ProcessMat
     *   }
     * })
     * 
     */
    delete<T extends ProcessMatDeleteArgs>(args: SelectSubset<T, ProcessMatDeleteArgs<ExtArgs>>): Prisma__ProcessMatClient<$Result.GetResult<Prisma.$ProcessMatPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ProcessMat.
     * @param {ProcessMatUpdateArgs} args - Arguments to update one ProcessMat.
     * @example
     * // Update one ProcessMat
     * const processMat = await prisma.processMat.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProcessMatUpdateArgs>(args: SelectSubset<T, ProcessMatUpdateArgs<ExtArgs>>): Prisma__ProcessMatClient<$Result.GetResult<Prisma.$ProcessMatPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ProcessMats.
     * @param {ProcessMatDeleteManyArgs} args - Arguments to filter ProcessMats to delete.
     * @example
     * // Delete a few ProcessMats
     * const { count } = await prisma.processMat.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProcessMatDeleteManyArgs>(args?: SelectSubset<T, ProcessMatDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProcessMats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProcessMatUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProcessMats
     * const processMat = await prisma.processMat.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProcessMatUpdateManyArgs>(args: SelectSubset<T, ProcessMatUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ProcessMat.
     * @param {ProcessMatUpsertArgs} args - Arguments to update or create a ProcessMat.
     * @example
     * // Update or create a ProcessMat
     * const processMat = await prisma.processMat.upsert({
     *   create: {
     *     // ... data to create a ProcessMat
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProcessMat we want to update
     *   }
     * })
     */
    upsert<T extends ProcessMatUpsertArgs>(args: SelectSubset<T, ProcessMatUpsertArgs<ExtArgs>>): Prisma__ProcessMatClient<$Result.GetResult<Prisma.$ProcessMatPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ProcessMats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProcessMatCountArgs} args - Arguments to filter ProcessMats to count.
     * @example
     * // Count the number of ProcessMats
     * const count = await prisma.processMat.count({
     *   where: {
     *     // ... the filter for the ProcessMats we want to count
     *   }
     * })
    **/
    count<T extends ProcessMatCountArgs>(
      args?: Subset<T, ProcessMatCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProcessMatCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProcessMat.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProcessMatAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProcessMatAggregateArgs>(args: Subset<T, ProcessMatAggregateArgs>): Prisma.PrismaPromise<GetProcessMatAggregateType<T>>

    /**
     * Group by ProcessMat.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProcessMatGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProcessMatGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProcessMatGroupByArgs['orderBy'] }
        : { orderBy?: ProcessMatGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProcessMatGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProcessMatGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProcessMat model
   */
  readonly fields: ProcessMatFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProcessMat.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProcessMatClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    stock<T extends StockDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StockDefaultArgs<ExtArgs>>): Prisma__StockClient<$Result.GetResult<Prisma.$StockPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    processDetail<T extends ProcessDetailDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProcessDetailDefaultArgs<ExtArgs>>): Prisma__ProcessDetailClient<$Result.GetResult<Prisma.$ProcessDetailPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProcessMat model
   */ 
  interface ProcessMatFieldRefs {
    readonly id: FieldRef<"ProcessMat", 'Int'>
    readonly pc_processDetailId: FieldRef<"ProcessMat", 'Int'>
    readonly pc_matId: FieldRef<"ProcessMat", 'String'>
    readonly pc_matamount: FieldRef<"ProcessMat", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * ProcessMat findUnique
   */
  export type ProcessMatFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcessMat
     */
    select?: ProcessMatSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessMatInclude<ExtArgs> | null
    /**
     * Filter, which ProcessMat to fetch.
     */
    where: ProcessMatWhereUniqueInput
  }

  /**
   * ProcessMat findUniqueOrThrow
   */
  export type ProcessMatFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcessMat
     */
    select?: ProcessMatSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessMatInclude<ExtArgs> | null
    /**
     * Filter, which ProcessMat to fetch.
     */
    where: ProcessMatWhereUniqueInput
  }

  /**
   * ProcessMat findFirst
   */
  export type ProcessMatFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcessMat
     */
    select?: ProcessMatSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessMatInclude<ExtArgs> | null
    /**
     * Filter, which ProcessMat to fetch.
     */
    where?: ProcessMatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProcessMats to fetch.
     */
    orderBy?: ProcessMatOrderByWithRelationInput | ProcessMatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProcessMats.
     */
    cursor?: ProcessMatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProcessMats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProcessMats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProcessMats.
     */
    distinct?: ProcessMatScalarFieldEnum | ProcessMatScalarFieldEnum[]
  }

  /**
   * ProcessMat findFirstOrThrow
   */
  export type ProcessMatFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcessMat
     */
    select?: ProcessMatSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessMatInclude<ExtArgs> | null
    /**
     * Filter, which ProcessMat to fetch.
     */
    where?: ProcessMatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProcessMats to fetch.
     */
    orderBy?: ProcessMatOrderByWithRelationInput | ProcessMatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProcessMats.
     */
    cursor?: ProcessMatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProcessMats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProcessMats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProcessMats.
     */
    distinct?: ProcessMatScalarFieldEnum | ProcessMatScalarFieldEnum[]
  }

  /**
   * ProcessMat findMany
   */
  export type ProcessMatFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcessMat
     */
    select?: ProcessMatSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessMatInclude<ExtArgs> | null
    /**
     * Filter, which ProcessMats to fetch.
     */
    where?: ProcessMatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProcessMats to fetch.
     */
    orderBy?: ProcessMatOrderByWithRelationInput | ProcessMatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProcessMats.
     */
    cursor?: ProcessMatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProcessMats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProcessMats.
     */
    skip?: number
    distinct?: ProcessMatScalarFieldEnum | ProcessMatScalarFieldEnum[]
  }

  /**
   * ProcessMat create
   */
  export type ProcessMatCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcessMat
     */
    select?: ProcessMatSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessMatInclude<ExtArgs> | null
    /**
     * The data needed to create a ProcessMat.
     */
    data: XOR<ProcessMatCreateInput, ProcessMatUncheckedCreateInput>
  }

  /**
   * ProcessMat createMany
   */
  export type ProcessMatCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProcessMats.
     */
    data: ProcessMatCreateManyInput | ProcessMatCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProcessMat update
   */
  export type ProcessMatUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcessMat
     */
    select?: ProcessMatSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessMatInclude<ExtArgs> | null
    /**
     * The data needed to update a ProcessMat.
     */
    data: XOR<ProcessMatUpdateInput, ProcessMatUncheckedUpdateInput>
    /**
     * Choose, which ProcessMat to update.
     */
    where: ProcessMatWhereUniqueInput
  }

  /**
   * ProcessMat updateMany
   */
  export type ProcessMatUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProcessMats.
     */
    data: XOR<ProcessMatUpdateManyMutationInput, ProcessMatUncheckedUpdateManyInput>
    /**
     * Filter which ProcessMats to update
     */
    where?: ProcessMatWhereInput
  }

  /**
   * ProcessMat upsert
   */
  export type ProcessMatUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcessMat
     */
    select?: ProcessMatSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessMatInclude<ExtArgs> | null
    /**
     * The filter to search for the ProcessMat to update in case it exists.
     */
    where: ProcessMatWhereUniqueInput
    /**
     * In case the ProcessMat found by the `where` argument doesn't exist, create a new ProcessMat with this data.
     */
    create: XOR<ProcessMatCreateInput, ProcessMatUncheckedCreateInput>
    /**
     * In case the ProcessMat was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProcessMatUpdateInput, ProcessMatUncheckedUpdateInput>
  }

  /**
   * ProcessMat delete
   */
  export type ProcessMatDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcessMat
     */
    select?: ProcessMatSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessMatInclude<ExtArgs> | null
    /**
     * Filter which ProcessMat to delete.
     */
    where: ProcessMatWhereUniqueInput
  }

  /**
   * ProcessMat deleteMany
   */
  export type ProcessMatDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProcessMats to delete
     */
    where?: ProcessMatWhereInput
  }

  /**
   * ProcessMat without action
   */
  export type ProcessMatDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcessMat
     */
    select?: ProcessMatSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessMatInclude<ExtArgs> | null
  }


  /**
   * Model ProcessBom
   */

  export type AggregateProcessBom = {
    _count: ProcessBomCountAggregateOutputType | null
    _avg: ProcessBomAvgAggregateOutputType | null
    _sum: ProcessBomSumAggregateOutputType | null
    _min: ProcessBomMinAggregateOutputType | null
    _max: ProcessBomMaxAggregateOutputType | null
  }

  export type ProcessBomAvgAggregateOutputType = {
    id: number | null
    pc_processDetailId: number | null
    pc_bomamount: number | null
  }

  export type ProcessBomSumAggregateOutputType = {
    id: number | null
    pc_processDetailId: number | null
    pc_bomamount: number | null
  }

  export type ProcessBomMinAggregateOutputType = {
    id: number | null
    pc_processDetailId: number | null
    pc_bomId: string | null
    pc_bomamount: number | null
  }

  export type ProcessBomMaxAggregateOutputType = {
    id: number | null
    pc_processDetailId: number | null
    pc_bomId: string | null
    pc_bomamount: number | null
  }

  export type ProcessBomCountAggregateOutputType = {
    id: number
    pc_processDetailId: number
    pc_bomId: number
    pc_bomamount: number
    _all: number
  }


  export type ProcessBomAvgAggregateInputType = {
    id?: true
    pc_processDetailId?: true
    pc_bomamount?: true
  }

  export type ProcessBomSumAggregateInputType = {
    id?: true
    pc_processDetailId?: true
    pc_bomamount?: true
  }

  export type ProcessBomMinAggregateInputType = {
    id?: true
    pc_processDetailId?: true
    pc_bomId?: true
    pc_bomamount?: true
  }

  export type ProcessBomMaxAggregateInputType = {
    id?: true
    pc_processDetailId?: true
    pc_bomId?: true
    pc_bomamount?: true
  }

  export type ProcessBomCountAggregateInputType = {
    id?: true
    pc_processDetailId?: true
    pc_bomId?: true
    pc_bomamount?: true
    _all?: true
  }

  export type ProcessBomAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProcessBom to aggregate.
     */
    where?: ProcessBomWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProcessBoms to fetch.
     */
    orderBy?: ProcessBomOrderByWithRelationInput | ProcessBomOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProcessBomWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProcessBoms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProcessBoms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProcessBoms
    **/
    _count?: true | ProcessBomCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProcessBomAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProcessBomSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProcessBomMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProcessBomMaxAggregateInputType
  }

  export type GetProcessBomAggregateType<T extends ProcessBomAggregateArgs> = {
        [P in keyof T & keyof AggregateProcessBom]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProcessBom[P]>
      : GetScalarType<T[P], AggregateProcessBom[P]>
  }




  export type ProcessBomGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProcessBomWhereInput
    orderBy?: ProcessBomOrderByWithAggregationInput | ProcessBomOrderByWithAggregationInput[]
    by: ProcessBomScalarFieldEnum[] | ProcessBomScalarFieldEnum
    having?: ProcessBomScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProcessBomCountAggregateInputType | true
    _avg?: ProcessBomAvgAggregateInputType
    _sum?: ProcessBomSumAggregateInputType
    _min?: ProcessBomMinAggregateInputType
    _max?: ProcessBomMaxAggregateInputType
  }

  export type ProcessBomGroupByOutputType = {
    id: number
    pc_processDetailId: number
    pc_bomId: string
    pc_bomamount: number
    _count: ProcessBomCountAggregateOutputType | null
    _avg: ProcessBomAvgAggregateOutputType | null
    _sum: ProcessBomSumAggregateOutputType | null
    _min: ProcessBomMinAggregateOutputType | null
    _max: ProcessBomMaxAggregateOutputType | null
  }

  type GetProcessBomGroupByPayload<T extends ProcessBomGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProcessBomGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProcessBomGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProcessBomGroupByOutputType[P]>
            : GetScalarType<T[P], ProcessBomGroupByOutputType[P]>
        }
      >
    >


  export type ProcessBomSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    pc_processDetailId?: boolean
    pc_bomId?: boolean
    pc_bomamount?: boolean
    stock?: boolean | StockDefaultArgs<ExtArgs>
    processDetail?: boolean | ProcessDetailDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["processBom"]>


  export type ProcessBomSelectScalar = {
    id?: boolean
    pc_processDetailId?: boolean
    pc_bomId?: boolean
    pc_bomamount?: boolean
  }

  export type ProcessBomInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    stock?: boolean | StockDefaultArgs<ExtArgs>
    processDetail?: boolean | ProcessDetailDefaultArgs<ExtArgs>
  }

  export type $ProcessBomPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProcessBom"
    objects: {
      stock: Prisma.$StockPayload<ExtArgs>
      processDetail: Prisma.$ProcessDetailPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      pc_processDetailId: number
      pc_bomId: string
      pc_bomamount: number
    }, ExtArgs["result"]["processBom"]>
    composites: {}
  }

  type ProcessBomGetPayload<S extends boolean | null | undefined | ProcessBomDefaultArgs> = $Result.GetResult<Prisma.$ProcessBomPayload, S>

  type ProcessBomCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ProcessBomFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ProcessBomCountAggregateInputType | true
    }

  export interface ProcessBomDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProcessBom'], meta: { name: 'ProcessBom' } }
    /**
     * Find zero or one ProcessBom that matches the filter.
     * @param {ProcessBomFindUniqueArgs} args - Arguments to find a ProcessBom
     * @example
     * // Get one ProcessBom
     * const processBom = await prisma.processBom.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProcessBomFindUniqueArgs>(args: SelectSubset<T, ProcessBomFindUniqueArgs<ExtArgs>>): Prisma__ProcessBomClient<$Result.GetResult<Prisma.$ProcessBomPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ProcessBom that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ProcessBomFindUniqueOrThrowArgs} args - Arguments to find a ProcessBom
     * @example
     * // Get one ProcessBom
     * const processBom = await prisma.processBom.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProcessBomFindUniqueOrThrowArgs>(args: SelectSubset<T, ProcessBomFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProcessBomClient<$Result.GetResult<Prisma.$ProcessBomPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ProcessBom that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProcessBomFindFirstArgs} args - Arguments to find a ProcessBom
     * @example
     * // Get one ProcessBom
     * const processBom = await prisma.processBom.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProcessBomFindFirstArgs>(args?: SelectSubset<T, ProcessBomFindFirstArgs<ExtArgs>>): Prisma__ProcessBomClient<$Result.GetResult<Prisma.$ProcessBomPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ProcessBom that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProcessBomFindFirstOrThrowArgs} args - Arguments to find a ProcessBom
     * @example
     * // Get one ProcessBom
     * const processBom = await prisma.processBom.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProcessBomFindFirstOrThrowArgs>(args?: SelectSubset<T, ProcessBomFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProcessBomClient<$Result.GetResult<Prisma.$ProcessBomPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ProcessBoms that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProcessBomFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProcessBoms
     * const processBoms = await prisma.processBom.findMany()
     * 
     * // Get first 10 ProcessBoms
     * const processBoms = await prisma.processBom.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const processBomWithIdOnly = await prisma.processBom.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProcessBomFindManyArgs>(args?: SelectSubset<T, ProcessBomFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProcessBomPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ProcessBom.
     * @param {ProcessBomCreateArgs} args - Arguments to create a ProcessBom.
     * @example
     * // Create one ProcessBom
     * const ProcessBom = await prisma.processBom.create({
     *   data: {
     *     // ... data to create a ProcessBom
     *   }
     * })
     * 
     */
    create<T extends ProcessBomCreateArgs>(args: SelectSubset<T, ProcessBomCreateArgs<ExtArgs>>): Prisma__ProcessBomClient<$Result.GetResult<Prisma.$ProcessBomPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ProcessBoms.
     * @param {ProcessBomCreateManyArgs} args - Arguments to create many ProcessBoms.
     * @example
     * // Create many ProcessBoms
     * const processBom = await prisma.processBom.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProcessBomCreateManyArgs>(args?: SelectSubset<T, ProcessBomCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ProcessBom.
     * @param {ProcessBomDeleteArgs} args - Arguments to delete one ProcessBom.
     * @example
     * // Delete one ProcessBom
     * const ProcessBom = await prisma.processBom.delete({
     *   where: {
     *     // ... filter to delete one ProcessBom
     *   }
     * })
     * 
     */
    delete<T extends ProcessBomDeleteArgs>(args: SelectSubset<T, ProcessBomDeleteArgs<ExtArgs>>): Prisma__ProcessBomClient<$Result.GetResult<Prisma.$ProcessBomPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ProcessBom.
     * @param {ProcessBomUpdateArgs} args - Arguments to update one ProcessBom.
     * @example
     * // Update one ProcessBom
     * const processBom = await prisma.processBom.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProcessBomUpdateArgs>(args: SelectSubset<T, ProcessBomUpdateArgs<ExtArgs>>): Prisma__ProcessBomClient<$Result.GetResult<Prisma.$ProcessBomPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ProcessBoms.
     * @param {ProcessBomDeleteManyArgs} args - Arguments to filter ProcessBoms to delete.
     * @example
     * // Delete a few ProcessBoms
     * const { count } = await prisma.processBom.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProcessBomDeleteManyArgs>(args?: SelectSubset<T, ProcessBomDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProcessBoms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProcessBomUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProcessBoms
     * const processBom = await prisma.processBom.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProcessBomUpdateManyArgs>(args: SelectSubset<T, ProcessBomUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ProcessBom.
     * @param {ProcessBomUpsertArgs} args - Arguments to update or create a ProcessBom.
     * @example
     * // Update or create a ProcessBom
     * const processBom = await prisma.processBom.upsert({
     *   create: {
     *     // ... data to create a ProcessBom
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProcessBom we want to update
     *   }
     * })
     */
    upsert<T extends ProcessBomUpsertArgs>(args: SelectSubset<T, ProcessBomUpsertArgs<ExtArgs>>): Prisma__ProcessBomClient<$Result.GetResult<Prisma.$ProcessBomPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ProcessBoms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProcessBomCountArgs} args - Arguments to filter ProcessBoms to count.
     * @example
     * // Count the number of ProcessBoms
     * const count = await prisma.processBom.count({
     *   where: {
     *     // ... the filter for the ProcessBoms we want to count
     *   }
     * })
    **/
    count<T extends ProcessBomCountArgs>(
      args?: Subset<T, ProcessBomCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProcessBomCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProcessBom.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProcessBomAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProcessBomAggregateArgs>(args: Subset<T, ProcessBomAggregateArgs>): Prisma.PrismaPromise<GetProcessBomAggregateType<T>>

    /**
     * Group by ProcessBom.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProcessBomGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProcessBomGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProcessBomGroupByArgs['orderBy'] }
        : { orderBy?: ProcessBomGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProcessBomGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProcessBomGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProcessBom model
   */
  readonly fields: ProcessBomFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProcessBom.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProcessBomClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    stock<T extends StockDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StockDefaultArgs<ExtArgs>>): Prisma__StockClient<$Result.GetResult<Prisma.$StockPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    processDetail<T extends ProcessDetailDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProcessDetailDefaultArgs<ExtArgs>>): Prisma__ProcessDetailClient<$Result.GetResult<Prisma.$ProcessDetailPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProcessBom model
   */ 
  interface ProcessBomFieldRefs {
    readonly id: FieldRef<"ProcessBom", 'Int'>
    readonly pc_processDetailId: FieldRef<"ProcessBom", 'Int'>
    readonly pc_bomId: FieldRef<"ProcessBom", 'String'>
    readonly pc_bomamount: FieldRef<"ProcessBom", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * ProcessBom findUnique
   */
  export type ProcessBomFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcessBom
     */
    select?: ProcessBomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessBomInclude<ExtArgs> | null
    /**
     * Filter, which ProcessBom to fetch.
     */
    where: ProcessBomWhereUniqueInput
  }

  /**
   * ProcessBom findUniqueOrThrow
   */
  export type ProcessBomFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcessBom
     */
    select?: ProcessBomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessBomInclude<ExtArgs> | null
    /**
     * Filter, which ProcessBom to fetch.
     */
    where: ProcessBomWhereUniqueInput
  }

  /**
   * ProcessBom findFirst
   */
  export type ProcessBomFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcessBom
     */
    select?: ProcessBomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessBomInclude<ExtArgs> | null
    /**
     * Filter, which ProcessBom to fetch.
     */
    where?: ProcessBomWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProcessBoms to fetch.
     */
    orderBy?: ProcessBomOrderByWithRelationInput | ProcessBomOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProcessBoms.
     */
    cursor?: ProcessBomWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProcessBoms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProcessBoms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProcessBoms.
     */
    distinct?: ProcessBomScalarFieldEnum | ProcessBomScalarFieldEnum[]
  }

  /**
   * ProcessBom findFirstOrThrow
   */
  export type ProcessBomFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcessBom
     */
    select?: ProcessBomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessBomInclude<ExtArgs> | null
    /**
     * Filter, which ProcessBom to fetch.
     */
    where?: ProcessBomWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProcessBoms to fetch.
     */
    orderBy?: ProcessBomOrderByWithRelationInput | ProcessBomOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProcessBoms.
     */
    cursor?: ProcessBomWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProcessBoms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProcessBoms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProcessBoms.
     */
    distinct?: ProcessBomScalarFieldEnum | ProcessBomScalarFieldEnum[]
  }

  /**
   * ProcessBom findMany
   */
  export type ProcessBomFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcessBom
     */
    select?: ProcessBomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessBomInclude<ExtArgs> | null
    /**
     * Filter, which ProcessBoms to fetch.
     */
    where?: ProcessBomWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProcessBoms to fetch.
     */
    orderBy?: ProcessBomOrderByWithRelationInput | ProcessBomOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProcessBoms.
     */
    cursor?: ProcessBomWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProcessBoms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProcessBoms.
     */
    skip?: number
    distinct?: ProcessBomScalarFieldEnum | ProcessBomScalarFieldEnum[]
  }

  /**
   * ProcessBom create
   */
  export type ProcessBomCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcessBom
     */
    select?: ProcessBomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessBomInclude<ExtArgs> | null
    /**
     * The data needed to create a ProcessBom.
     */
    data: XOR<ProcessBomCreateInput, ProcessBomUncheckedCreateInput>
  }

  /**
   * ProcessBom createMany
   */
  export type ProcessBomCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProcessBoms.
     */
    data: ProcessBomCreateManyInput | ProcessBomCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProcessBom update
   */
  export type ProcessBomUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcessBom
     */
    select?: ProcessBomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessBomInclude<ExtArgs> | null
    /**
     * The data needed to update a ProcessBom.
     */
    data: XOR<ProcessBomUpdateInput, ProcessBomUncheckedUpdateInput>
    /**
     * Choose, which ProcessBom to update.
     */
    where: ProcessBomWhereUniqueInput
  }

  /**
   * ProcessBom updateMany
   */
  export type ProcessBomUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProcessBoms.
     */
    data: XOR<ProcessBomUpdateManyMutationInput, ProcessBomUncheckedUpdateManyInput>
    /**
     * Filter which ProcessBoms to update
     */
    where?: ProcessBomWhereInput
  }

  /**
   * ProcessBom upsert
   */
  export type ProcessBomUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcessBom
     */
    select?: ProcessBomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessBomInclude<ExtArgs> | null
    /**
     * The filter to search for the ProcessBom to update in case it exists.
     */
    where: ProcessBomWhereUniqueInput
    /**
     * In case the ProcessBom found by the `where` argument doesn't exist, create a new ProcessBom with this data.
     */
    create: XOR<ProcessBomCreateInput, ProcessBomUncheckedCreateInput>
    /**
     * In case the ProcessBom was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProcessBomUpdateInput, ProcessBomUncheckedUpdateInput>
  }

  /**
   * ProcessBom delete
   */
  export type ProcessBomDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcessBom
     */
    select?: ProcessBomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessBomInclude<ExtArgs> | null
    /**
     * Filter which ProcessBom to delete.
     */
    where: ProcessBomWhereUniqueInput
  }

  /**
   * ProcessBom deleteMany
   */
  export type ProcessBomDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProcessBoms to delete
     */
    where?: ProcessBomWhereInput
  }

  /**
   * ProcessBom without action
   */
  export type ProcessBomDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcessBom
     */
    select?: ProcessBomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessBomInclude<ExtArgs> | null
  }


  /**
   * Model Project
   */

  export type AggregateProject = {
    _count: ProjectCountAggregateOutputType | null
    _avg: ProjectAvgAggregateOutputType | null
    _sum: ProjectSumAggregateOutputType | null
    _min: ProjectMinAggregateOutputType | null
    _max: ProjectMaxAggregateOutputType | null
  }

  export type ProjectAvgAggregateOutputType = {
    id: number | null
    pj_amountProduct: number | null
    pj_totalDay: number | null
  }

  export type ProjectSumAggregateOutputType = {
    id: number | null
    pj_amountProduct: number | null
    pj_totalDay: number | null
  }

  export type ProjectMinAggregateOutputType = {
    id: number | null
    pj_bluePrintNo: string | null
    pj_serialNumber: string | null
    pj_projectName: string | null
    pj_startDate: Date | null
    pj_endDate: Date | null
    pj_amountProduct: number | null
    pj_totalDay: number | null
    pj_imageProduct: string | null
    pj_remark: string | null
    pj_status: string | null
    pj_type: string | null
    pj_userId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type ProjectMaxAggregateOutputType = {
    id: number | null
    pj_bluePrintNo: string | null
    pj_serialNumber: string | null
    pj_projectName: string | null
    pj_startDate: Date | null
    pj_endDate: Date | null
    pj_amountProduct: number | null
    pj_totalDay: number | null
    pj_imageProduct: string | null
    pj_remark: string | null
    pj_status: string | null
    pj_type: string | null
    pj_userId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type ProjectCountAggregateOutputType = {
    id: number
    pj_bluePrintNo: number
    pj_serialNumber: number
    pj_projectName: number
    pj_startDate: number
    pj_endDate: number
    pj_amountProduct: number
    pj_totalDay: number
    pj_imageProduct: number
    pj_remark: number
    pj_status: number
    pj_type: number
    pj_userId: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    _all: number
  }


  export type ProjectAvgAggregateInputType = {
    id?: true
    pj_amountProduct?: true
    pj_totalDay?: true
  }

  export type ProjectSumAggregateInputType = {
    id?: true
    pj_amountProduct?: true
    pj_totalDay?: true
  }

  export type ProjectMinAggregateInputType = {
    id?: true
    pj_bluePrintNo?: true
    pj_serialNumber?: true
    pj_projectName?: true
    pj_startDate?: true
    pj_endDate?: true
    pj_amountProduct?: true
    pj_totalDay?: true
    pj_imageProduct?: true
    pj_remark?: true
    pj_status?: true
    pj_type?: true
    pj_userId?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type ProjectMaxAggregateInputType = {
    id?: true
    pj_bluePrintNo?: true
    pj_serialNumber?: true
    pj_projectName?: true
    pj_startDate?: true
    pj_endDate?: true
    pj_amountProduct?: true
    pj_totalDay?: true
    pj_imageProduct?: true
    pj_remark?: true
    pj_status?: true
    pj_type?: true
    pj_userId?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type ProjectCountAggregateInputType = {
    id?: true
    pj_bluePrintNo?: true
    pj_serialNumber?: true
    pj_projectName?: true
    pj_startDate?: true
    pj_endDate?: true
    pj_amountProduct?: true
    pj_totalDay?: true
    pj_imageProduct?: true
    pj_remark?: true
    pj_status?: true
    pj_type?: true
    pj_userId?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    _all?: true
  }

  export type ProjectAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Project to aggregate.
     */
    where?: ProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Projects to fetch.
     */
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Projects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Projects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Projects
    **/
    _count?: true | ProjectCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProjectAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProjectSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProjectMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProjectMaxAggregateInputType
  }

  export type GetProjectAggregateType<T extends ProjectAggregateArgs> = {
        [P in keyof T & keyof AggregateProject]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProject[P]>
      : GetScalarType<T[P], AggregateProject[P]>
  }




  export type ProjectGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectWhereInput
    orderBy?: ProjectOrderByWithAggregationInput | ProjectOrderByWithAggregationInput[]
    by: ProjectScalarFieldEnum[] | ProjectScalarFieldEnum
    having?: ProjectScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProjectCountAggregateInputType | true
    _avg?: ProjectAvgAggregateInputType
    _sum?: ProjectSumAggregateInputType
    _min?: ProjectMinAggregateInputType
    _max?: ProjectMaxAggregateInputType
  }

  export type ProjectGroupByOutputType = {
    id: number
    pj_bluePrintNo: string
    pj_serialNumber: string
    pj_projectName: string
    pj_startDate: Date
    pj_endDate: Date
    pj_amountProduct: number
    pj_totalDay: number
    pj_imageProduct: string
    pj_remark: string
    pj_status: string
    pj_type: string
    pj_userId: string
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
    _count: ProjectCountAggregateOutputType | null
    _avg: ProjectAvgAggregateOutputType | null
    _sum: ProjectSumAggregateOutputType | null
    _min: ProjectMinAggregateOutputType | null
    _max: ProjectMaxAggregateOutputType | null
  }

  type GetProjectGroupByPayload<T extends ProjectGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProjectGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProjectGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProjectGroupByOutputType[P]>
            : GetScalarType<T[P], ProjectGroupByOutputType[P]>
        }
      >
    >


  export type ProjectSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    pj_bluePrintNo?: boolean
    pj_serialNumber?: boolean
    pj_projectName?: boolean
    pj_startDate?: boolean
    pj_endDate?: boolean
    pj_amountProduct?: boolean
    pj_totalDay?: boolean
    pj_imageProduct?: boolean
    pj_remark?: boolean
    pj_status?: boolean
    pj_type?: boolean
    pj_userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    projectDetail?: boolean | Project$projectDetailArgs<ExtArgs>
    _count?: boolean | ProjectCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["project"]>


  export type ProjectSelectScalar = {
    id?: boolean
    pj_bluePrintNo?: boolean
    pj_serialNumber?: boolean
    pj_projectName?: boolean
    pj_startDate?: boolean
    pj_endDate?: boolean
    pj_amountProduct?: boolean
    pj_totalDay?: boolean
    pj_imageProduct?: boolean
    pj_remark?: boolean
    pj_status?: boolean
    pj_type?: boolean
    pj_userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }

  export type ProjectInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    projectDetail?: boolean | Project$projectDetailArgs<ExtArgs>
    _count?: boolean | ProjectCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $ProjectPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Project"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      projectDetail: Prisma.$ProjectDetailPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      pj_bluePrintNo: string
      pj_serialNumber: string
      pj_projectName: string
      pj_startDate: Date
      pj_endDate: Date
      pj_amountProduct: number
      pj_totalDay: number
      pj_imageProduct: string
      pj_remark: string
      pj_status: string
      pj_type: string
      pj_userId: string
      createdAt: Date
      updatedAt: Date
      deletedAt: Date | null
    }, ExtArgs["result"]["project"]>
    composites: {}
  }

  type ProjectGetPayload<S extends boolean | null | undefined | ProjectDefaultArgs> = $Result.GetResult<Prisma.$ProjectPayload, S>

  type ProjectCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ProjectFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ProjectCountAggregateInputType | true
    }

  export interface ProjectDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Project'], meta: { name: 'Project' } }
    /**
     * Find zero or one Project that matches the filter.
     * @param {ProjectFindUniqueArgs} args - Arguments to find a Project
     * @example
     * // Get one Project
     * const project = await prisma.project.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProjectFindUniqueArgs>(args: SelectSubset<T, ProjectFindUniqueArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Project that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ProjectFindUniqueOrThrowArgs} args - Arguments to find a Project
     * @example
     * // Get one Project
     * const project = await prisma.project.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProjectFindUniqueOrThrowArgs>(args: SelectSubset<T, ProjectFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Project that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectFindFirstArgs} args - Arguments to find a Project
     * @example
     * // Get one Project
     * const project = await prisma.project.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProjectFindFirstArgs>(args?: SelectSubset<T, ProjectFindFirstArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Project that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectFindFirstOrThrowArgs} args - Arguments to find a Project
     * @example
     * // Get one Project
     * const project = await prisma.project.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProjectFindFirstOrThrowArgs>(args?: SelectSubset<T, ProjectFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Projects that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Projects
     * const projects = await prisma.project.findMany()
     * 
     * // Get first 10 Projects
     * const projects = await prisma.project.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const projectWithIdOnly = await prisma.project.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProjectFindManyArgs>(args?: SelectSubset<T, ProjectFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Project.
     * @param {ProjectCreateArgs} args - Arguments to create a Project.
     * @example
     * // Create one Project
     * const Project = await prisma.project.create({
     *   data: {
     *     // ... data to create a Project
     *   }
     * })
     * 
     */
    create<T extends ProjectCreateArgs>(args: SelectSubset<T, ProjectCreateArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Projects.
     * @param {ProjectCreateManyArgs} args - Arguments to create many Projects.
     * @example
     * // Create many Projects
     * const project = await prisma.project.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProjectCreateManyArgs>(args?: SelectSubset<T, ProjectCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Project.
     * @param {ProjectDeleteArgs} args - Arguments to delete one Project.
     * @example
     * // Delete one Project
     * const Project = await prisma.project.delete({
     *   where: {
     *     // ... filter to delete one Project
     *   }
     * })
     * 
     */
    delete<T extends ProjectDeleteArgs>(args: SelectSubset<T, ProjectDeleteArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Project.
     * @param {ProjectUpdateArgs} args - Arguments to update one Project.
     * @example
     * // Update one Project
     * const project = await prisma.project.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProjectUpdateArgs>(args: SelectSubset<T, ProjectUpdateArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Projects.
     * @param {ProjectDeleteManyArgs} args - Arguments to filter Projects to delete.
     * @example
     * // Delete a few Projects
     * const { count } = await prisma.project.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProjectDeleteManyArgs>(args?: SelectSubset<T, ProjectDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Projects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Projects
     * const project = await prisma.project.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProjectUpdateManyArgs>(args: SelectSubset<T, ProjectUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Project.
     * @param {ProjectUpsertArgs} args - Arguments to update or create a Project.
     * @example
     * // Update or create a Project
     * const project = await prisma.project.upsert({
     *   create: {
     *     // ... data to create a Project
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Project we want to update
     *   }
     * })
     */
    upsert<T extends ProjectUpsertArgs>(args: SelectSubset<T, ProjectUpsertArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Projects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectCountArgs} args - Arguments to filter Projects to count.
     * @example
     * // Count the number of Projects
     * const count = await prisma.project.count({
     *   where: {
     *     // ... the filter for the Projects we want to count
     *   }
     * })
    **/
    count<T extends ProjectCountArgs>(
      args?: Subset<T, ProjectCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProjectCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Project.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProjectAggregateArgs>(args: Subset<T, ProjectAggregateArgs>): Prisma.PrismaPromise<GetProjectAggregateType<T>>

    /**
     * Group by Project.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProjectGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProjectGroupByArgs['orderBy'] }
        : { orderBy?: ProjectGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProjectGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProjectGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Project model
   */
  readonly fields: ProjectFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Project.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProjectClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    projectDetail<T extends Project$projectDetailArgs<ExtArgs> = {}>(args?: Subset<T, Project$projectDetailArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectDetailPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Project model
   */ 
  interface ProjectFieldRefs {
    readonly id: FieldRef<"Project", 'Int'>
    readonly pj_bluePrintNo: FieldRef<"Project", 'String'>
    readonly pj_serialNumber: FieldRef<"Project", 'String'>
    readonly pj_projectName: FieldRef<"Project", 'String'>
    readonly pj_startDate: FieldRef<"Project", 'DateTime'>
    readonly pj_endDate: FieldRef<"Project", 'DateTime'>
    readonly pj_amountProduct: FieldRef<"Project", 'Int'>
    readonly pj_totalDay: FieldRef<"Project", 'Int'>
    readonly pj_imageProduct: FieldRef<"Project", 'String'>
    readonly pj_remark: FieldRef<"Project", 'String'>
    readonly pj_status: FieldRef<"Project", 'String'>
    readonly pj_type: FieldRef<"Project", 'String'>
    readonly pj_userId: FieldRef<"Project", 'String'>
    readonly createdAt: FieldRef<"Project", 'DateTime'>
    readonly updatedAt: FieldRef<"Project", 'DateTime'>
    readonly deletedAt: FieldRef<"Project", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Project findUnique
   */
  export type ProjectFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter, which Project to fetch.
     */
    where: ProjectWhereUniqueInput
  }

  /**
   * Project findUniqueOrThrow
   */
  export type ProjectFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter, which Project to fetch.
     */
    where: ProjectWhereUniqueInput
  }

  /**
   * Project findFirst
   */
  export type ProjectFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter, which Project to fetch.
     */
    where?: ProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Projects to fetch.
     */
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Projects.
     */
    cursor?: ProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Projects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Projects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Projects.
     */
    distinct?: ProjectScalarFieldEnum | ProjectScalarFieldEnum[]
  }

  /**
   * Project findFirstOrThrow
   */
  export type ProjectFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter, which Project to fetch.
     */
    where?: ProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Projects to fetch.
     */
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Projects.
     */
    cursor?: ProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Projects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Projects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Projects.
     */
    distinct?: ProjectScalarFieldEnum | ProjectScalarFieldEnum[]
  }

  /**
   * Project findMany
   */
  export type ProjectFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter, which Projects to fetch.
     */
    where?: ProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Projects to fetch.
     */
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Projects.
     */
    cursor?: ProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Projects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Projects.
     */
    skip?: number
    distinct?: ProjectScalarFieldEnum | ProjectScalarFieldEnum[]
  }

  /**
   * Project create
   */
  export type ProjectCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * The data needed to create a Project.
     */
    data: XOR<ProjectCreateInput, ProjectUncheckedCreateInput>
  }

  /**
   * Project createMany
   */
  export type ProjectCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Projects.
     */
    data: ProjectCreateManyInput | ProjectCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Project update
   */
  export type ProjectUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * The data needed to update a Project.
     */
    data: XOR<ProjectUpdateInput, ProjectUncheckedUpdateInput>
    /**
     * Choose, which Project to update.
     */
    where: ProjectWhereUniqueInput
  }

  /**
   * Project updateMany
   */
  export type ProjectUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Projects.
     */
    data: XOR<ProjectUpdateManyMutationInput, ProjectUncheckedUpdateManyInput>
    /**
     * Filter which Projects to update
     */
    where?: ProjectWhereInput
  }

  /**
   * Project upsert
   */
  export type ProjectUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * The filter to search for the Project to update in case it exists.
     */
    where: ProjectWhereUniqueInput
    /**
     * In case the Project found by the `where` argument doesn't exist, create a new Project with this data.
     */
    create: XOR<ProjectCreateInput, ProjectUncheckedCreateInput>
    /**
     * In case the Project was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProjectUpdateInput, ProjectUncheckedUpdateInput>
  }

  /**
   * Project delete
   */
  export type ProjectDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter which Project to delete.
     */
    where: ProjectWhereUniqueInput
  }

  /**
   * Project deleteMany
   */
  export type ProjectDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Projects to delete
     */
    where?: ProjectWhereInput
  }

  /**
   * Project.projectDetail
   */
  export type Project$projectDetailArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectDetail
     */
    select?: ProjectDetailSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectDetailInclude<ExtArgs> | null
    where?: ProjectDetailWhereInput
    orderBy?: ProjectDetailOrderByWithRelationInput | ProjectDetailOrderByWithRelationInput[]
    cursor?: ProjectDetailWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProjectDetailScalarFieldEnum | ProjectDetailScalarFieldEnum[]
  }

  /**
   * Project without action
   */
  export type ProjectDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
  }


  /**
   * Model ProjectDetail
   */

  export type AggregateProjectDetail = {
    _count: ProjectDetailCountAggregateOutputType | null
    _avg: ProjectDetailAvgAggregateOutputType | null
    _sum: ProjectDetailSumAggregateOutputType | null
    _min: ProjectDetailMinAggregateOutputType | null
    _max: ProjectDetailMaxAggregateOutputType | null
  }

  export type ProjectDetailAvgAggregateOutputType = {
    id: number | null
    pj_projectId: number | null
    pj_amountDay: number | null
  }

  export type ProjectDetailSumAggregateOutputType = {
    id: number | null
    pj_projectId: number | null
    pj_amountDay: number | null
  }

  export type ProjectDetailMinAggregateOutputType = {
    id: number | null
    pj_projectId: number | null
    pj_bluePrintNo: string | null
    pj_serialNumber: string | null
    pj_processTitle: string | null
    pj_amountDay: number | null
    pj_reasonType: string | null
    pj_statusPc: string | null
  }

  export type ProjectDetailMaxAggregateOutputType = {
    id: number | null
    pj_projectId: number | null
    pj_bluePrintNo: string | null
    pj_serialNumber: string | null
    pj_processTitle: string | null
    pj_amountDay: number | null
    pj_reasonType: string | null
    pj_statusPc: string | null
  }

  export type ProjectDetailCountAggregateOutputType = {
    id: number
    pj_projectId: number
    pj_bluePrintNo: number
    pj_serialNumber: number
    pj_processTitle: number
    pj_amountDay: number
    pj_reasonType: number
    pj_statusPc: number
    _all: number
  }


  export type ProjectDetailAvgAggregateInputType = {
    id?: true
    pj_projectId?: true
    pj_amountDay?: true
  }

  export type ProjectDetailSumAggregateInputType = {
    id?: true
    pj_projectId?: true
    pj_amountDay?: true
  }

  export type ProjectDetailMinAggregateInputType = {
    id?: true
    pj_projectId?: true
    pj_bluePrintNo?: true
    pj_serialNumber?: true
    pj_processTitle?: true
    pj_amountDay?: true
    pj_reasonType?: true
    pj_statusPc?: true
  }

  export type ProjectDetailMaxAggregateInputType = {
    id?: true
    pj_projectId?: true
    pj_bluePrintNo?: true
    pj_serialNumber?: true
    pj_processTitle?: true
    pj_amountDay?: true
    pj_reasonType?: true
    pj_statusPc?: true
  }

  export type ProjectDetailCountAggregateInputType = {
    id?: true
    pj_projectId?: true
    pj_bluePrintNo?: true
    pj_serialNumber?: true
    pj_processTitle?: true
    pj_amountDay?: true
    pj_reasonType?: true
    pj_statusPc?: true
    _all?: true
  }

  export type ProjectDetailAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProjectDetail to aggregate.
     */
    where?: ProjectDetailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectDetails to fetch.
     */
    orderBy?: ProjectDetailOrderByWithRelationInput | ProjectDetailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProjectDetailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProjectDetails
    **/
    _count?: true | ProjectDetailCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProjectDetailAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProjectDetailSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProjectDetailMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProjectDetailMaxAggregateInputType
  }

  export type GetProjectDetailAggregateType<T extends ProjectDetailAggregateArgs> = {
        [P in keyof T & keyof AggregateProjectDetail]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProjectDetail[P]>
      : GetScalarType<T[P], AggregateProjectDetail[P]>
  }




  export type ProjectDetailGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectDetailWhereInput
    orderBy?: ProjectDetailOrderByWithAggregationInput | ProjectDetailOrderByWithAggregationInput[]
    by: ProjectDetailScalarFieldEnum[] | ProjectDetailScalarFieldEnum
    having?: ProjectDetailScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProjectDetailCountAggregateInputType | true
    _avg?: ProjectDetailAvgAggregateInputType
    _sum?: ProjectDetailSumAggregateInputType
    _min?: ProjectDetailMinAggregateInputType
    _max?: ProjectDetailMaxAggregateInputType
  }

  export type ProjectDetailGroupByOutputType = {
    id: number
    pj_projectId: number
    pj_bluePrintNo: string
    pj_serialNumber: string
    pj_processTitle: string
    pj_amountDay: number
    pj_reasonType: string
    pj_statusPc: string
    _count: ProjectDetailCountAggregateOutputType | null
    _avg: ProjectDetailAvgAggregateOutputType | null
    _sum: ProjectDetailSumAggregateOutputType | null
    _min: ProjectDetailMinAggregateOutputType | null
    _max: ProjectDetailMaxAggregateOutputType | null
  }

  type GetProjectDetailGroupByPayload<T extends ProjectDetailGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProjectDetailGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProjectDetailGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProjectDetailGroupByOutputType[P]>
            : GetScalarType<T[P], ProjectDetailGroupByOutputType[P]>
        }
      >
    >


  export type ProjectDetailSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    pj_projectId?: boolean
    pj_bluePrintNo?: boolean
    pj_serialNumber?: boolean
    pj_processTitle?: boolean
    pj_amountDay?: boolean
    pj_reasonType?: boolean
    pj_statusPc?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    projectBranch?: boolean | ProjectDetail$projectBranchArgs<ExtArgs>
    projectMat?: boolean | ProjectDetail$projectMatArgs<ExtArgs>
    projectBom?: boolean | ProjectDetail$projectBomArgs<ExtArgs>
    ProjectResUser?: boolean | ProjectDetail$ProjectResUserArgs<ExtArgs>
    _count?: boolean | ProjectDetailCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["projectDetail"]>


  export type ProjectDetailSelectScalar = {
    id?: boolean
    pj_projectId?: boolean
    pj_bluePrintNo?: boolean
    pj_serialNumber?: boolean
    pj_processTitle?: boolean
    pj_amountDay?: boolean
    pj_reasonType?: boolean
    pj_statusPc?: boolean
  }

  export type ProjectDetailInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    projectBranch?: boolean | ProjectDetail$projectBranchArgs<ExtArgs>
    projectMat?: boolean | ProjectDetail$projectMatArgs<ExtArgs>
    projectBom?: boolean | ProjectDetail$projectBomArgs<ExtArgs>
    ProjectResUser?: boolean | ProjectDetail$ProjectResUserArgs<ExtArgs>
    _count?: boolean | ProjectDetailCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $ProjectDetailPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProjectDetail"
    objects: {
      project: Prisma.$ProjectPayload<ExtArgs>
      projectBranch: Prisma.$ProjectBranchPayload<ExtArgs>[]
      projectMat: Prisma.$ProjectMatPayload<ExtArgs>[]
      projectBom: Prisma.$ProjectBomPayload<ExtArgs>[]
      ProjectResUser: Prisma.$ProjectResUserPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      pj_projectId: number
      pj_bluePrintNo: string
      pj_serialNumber: string
      pj_processTitle: string
      pj_amountDay: number
      pj_reasonType: string
      pj_statusPc: string
    }, ExtArgs["result"]["projectDetail"]>
    composites: {}
  }

  type ProjectDetailGetPayload<S extends boolean | null | undefined | ProjectDetailDefaultArgs> = $Result.GetResult<Prisma.$ProjectDetailPayload, S>

  type ProjectDetailCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ProjectDetailFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ProjectDetailCountAggregateInputType | true
    }

  export interface ProjectDetailDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProjectDetail'], meta: { name: 'ProjectDetail' } }
    /**
     * Find zero or one ProjectDetail that matches the filter.
     * @param {ProjectDetailFindUniqueArgs} args - Arguments to find a ProjectDetail
     * @example
     * // Get one ProjectDetail
     * const projectDetail = await prisma.projectDetail.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProjectDetailFindUniqueArgs>(args: SelectSubset<T, ProjectDetailFindUniqueArgs<ExtArgs>>): Prisma__ProjectDetailClient<$Result.GetResult<Prisma.$ProjectDetailPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ProjectDetail that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ProjectDetailFindUniqueOrThrowArgs} args - Arguments to find a ProjectDetail
     * @example
     * // Get one ProjectDetail
     * const projectDetail = await prisma.projectDetail.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProjectDetailFindUniqueOrThrowArgs>(args: SelectSubset<T, ProjectDetailFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProjectDetailClient<$Result.GetResult<Prisma.$ProjectDetailPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ProjectDetail that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectDetailFindFirstArgs} args - Arguments to find a ProjectDetail
     * @example
     * // Get one ProjectDetail
     * const projectDetail = await prisma.projectDetail.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProjectDetailFindFirstArgs>(args?: SelectSubset<T, ProjectDetailFindFirstArgs<ExtArgs>>): Prisma__ProjectDetailClient<$Result.GetResult<Prisma.$ProjectDetailPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ProjectDetail that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectDetailFindFirstOrThrowArgs} args - Arguments to find a ProjectDetail
     * @example
     * // Get one ProjectDetail
     * const projectDetail = await prisma.projectDetail.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProjectDetailFindFirstOrThrowArgs>(args?: SelectSubset<T, ProjectDetailFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProjectDetailClient<$Result.GetResult<Prisma.$ProjectDetailPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ProjectDetails that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectDetailFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProjectDetails
     * const projectDetails = await prisma.projectDetail.findMany()
     * 
     * // Get first 10 ProjectDetails
     * const projectDetails = await prisma.projectDetail.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const projectDetailWithIdOnly = await prisma.projectDetail.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProjectDetailFindManyArgs>(args?: SelectSubset<T, ProjectDetailFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectDetailPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ProjectDetail.
     * @param {ProjectDetailCreateArgs} args - Arguments to create a ProjectDetail.
     * @example
     * // Create one ProjectDetail
     * const ProjectDetail = await prisma.projectDetail.create({
     *   data: {
     *     // ... data to create a ProjectDetail
     *   }
     * })
     * 
     */
    create<T extends ProjectDetailCreateArgs>(args: SelectSubset<T, ProjectDetailCreateArgs<ExtArgs>>): Prisma__ProjectDetailClient<$Result.GetResult<Prisma.$ProjectDetailPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ProjectDetails.
     * @param {ProjectDetailCreateManyArgs} args - Arguments to create many ProjectDetails.
     * @example
     * // Create many ProjectDetails
     * const projectDetail = await prisma.projectDetail.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProjectDetailCreateManyArgs>(args?: SelectSubset<T, ProjectDetailCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ProjectDetail.
     * @param {ProjectDetailDeleteArgs} args - Arguments to delete one ProjectDetail.
     * @example
     * // Delete one ProjectDetail
     * const ProjectDetail = await prisma.projectDetail.delete({
     *   where: {
     *     // ... filter to delete one ProjectDetail
     *   }
     * })
     * 
     */
    delete<T extends ProjectDetailDeleteArgs>(args: SelectSubset<T, ProjectDetailDeleteArgs<ExtArgs>>): Prisma__ProjectDetailClient<$Result.GetResult<Prisma.$ProjectDetailPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ProjectDetail.
     * @param {ProjectDetailUpdateArgs} args - Arguments to update one ProjectDetail.
     * @example
     * // Update one ProjectDetail
     * const projectDetail = await prisma.projectDetail.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProjectDetailUpdateArgs>(args: SelectSubset<T, ProjectDetailUpdateArgs<ExtArgs>>): Prisma__ProjectDetailClient<$Result.GetResult<Prisma.$ProjectDetailPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ProjectDetails.
     * @param {ProjectDetailDeleteManyArgs} args - Arguments to filter ProjectDetails to delete.
     * @example
     * // Delete a few ProjectDetails
     * const { count } = await prisma.projectDetail.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProjectDetailDeleteManyArgs>(args?: SelectSubset<T, ProjectDetailDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProjectDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectDetailUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProjectDetails
     * const projectDetail = await prisma.projectDetail.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProjectDetailUpdateManyArgs>(args: SelectSubset<T, ProjectDetailUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ProjectDetail.
     * @param {ProjectDetailUpsertArgs} args - Arguments to update or create a ProjectDetail.
     * @example
     * // Update or create a ProjectDetail
     * const projectDetail = await prisma.projectDetail.upsert({
     *   create: {
     *     // ... data to create a ProjectDetail
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProjectDetail we want to update
     *   }
     * })
     */
    upsert<T extends ProjectDetailUpsertArgs>(args: SelectSubset<T, ProjectDetailUpsertArgs<ExtArgs>>): Prisma__ProjectDetailClient<$Result.GetResult<Prisma.$ProjectDetailPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ProjectDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectDetailCountArgs} args - Arguments to filter ProjectDetails to count.
     * @example
     * // Count the number of ProjectDetails
     * const count = await prisma.projectDetail.count({
     *   where: {
     *     // ... the filter for the ProjectDetails we want to count
     *   }
     * })
    **/
    count<T extends ProjectDetailCountArgs>(
      args?: Subset<T, ProjectDetailCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProjectDetailCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProjectDetail.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectDetailAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProjectDetailAggregateArgs>(args: Subset<T, ProjectDetailAggregateArgs>): Prisma.PrismaPromise<GetProjectDetailAggregateType<T>>

    /**
     * Group by ProjectDetail.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectDetailGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProjectDetailGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProjectDetailGroupByArgs['orderBy'] }
        : { orderBy?: ProjectDetailGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProjectDetailGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProjectDetailGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProjectDetail model
   */
  readonly fields: ProjectDetailFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProjectDetail.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProjectDetailClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    project<T extends ProjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProjectDefaultArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    projectBranch<T extends ProjectDetail$projectBranchArgs<ExtArgs> = {}>(args?: Subset<T, ProjectDetail$projectBranchArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectBranchPayload<ExtArgs>, T, "findMany"> | Null>
    projectMat<T extends ProjectDetail$projectMatArgs<ExtArgs> = {}>(args?: Subset<T, ProjectDetail$projectMatArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectMatPayload<ExtArgs>, T, "findMany"> | Null>
    projectBom<T extends ProjectDetail$projectBomArgs<ExtArgs> = {}>(args?: Subset<T, ProjectDetail$projectBomArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectBomPayload<ExtArgs>, T, "findMany"> | Null>
    ProjectResUser<T extends ProjectDetail$ProjectResUserArgs<ExtArgs> = {}>(args?: Subset<T, ProjectDetail$ProjectResUserArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectResUserPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProjectDetail model
   */ 
  interface ProjectDetailFieldRefs {
    readonly id: FieldRef<"ProjectDetail", 'Int'>
    readonly pj_projectId: FieldRef<"ProjectDetail", 'Int'>
    readonly pj_bluePrintNo: FieldRef<"ProjectDetail", 'String'>
    readonly pj_serialNumber: FieldRef<"ProjectDetail", 'String'>
    readonly pj_processTitle: FieldRef<"ProjectDetail", 'String'>
    readonly pj_amountDay: FieldRef<"ProjectDetail", 'Int'>
    readonly pj_reasonType: FieldRef<"ProjectDetail", 'String'>
    readonly pj_statusPc: FieldRef<"ProjectDetail", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ProjectDetail findUnique
   */
  export type ProjectDetailFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectDetail
     */
    select?: ProjectDetailSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectDetailInclude<ExtArgs> | null
    /**
     * Filter, which ProjectDetail to fetch.
     */
    where: ProjectDetailWhereUniqueInput
  }

  /**
   * ProjectDetail findUniqueOrThrow
   */
  export type ProjectDetailFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectDetail
     */
    select?: ProjectDetailSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectDetailInclude<ExtArgs> | null
    /**
     * Filter, which ProjectDetail to fetch.
     */
    where: ProjectDetailWhereUniqueInput
  }

  /**
   * ProjectDetail findFirst
   */
  export type ProjectDetailFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectDetail
     */
    select?: ProjectDetailSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectDetailInclude<ExtArgs> | null
    /**
     * Filter, which ProjectDetail to fetch.
     */
    where?: ProjectDetailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectDetails to fetch.
     */
    orderBy?: ProjectDetailOrderByWithRelationInput | ProjectDetailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProjectDetails.
     */
    cursor?: ProjectDetailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProjectDetails.
     */
    distinct?: ProjectDetailScalarFieldEnum | ProjectDetailScalarFieldEnum[]
  }

  /**
   * ProjectDetail findFirstOrThrow
   */
  export type ProjectDetailFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectDetail
     */
    select?: ProjectDetailSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectDetailInclude<ExtArgs> | null
    /**
     * Filter, which ProjectDetail to fetch.
     */
    where?: ProjectDetailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectDetails to fetch.
     */
    orderBy?: ProjectDetailOrderByWithRelationInput | ProjectDetailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProjectDetails.
     */
    cursor?: ProjectDetailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProjectDetails.
     */
    distinct?: ProjectDetailScalarFieldEnum | ProjectDetailScalarFieldEnum[]
  }

  /**
   * ProjectDetail findMany
   */
  export type ProjectDetailFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectDetail
     */
    select?: ProjectDetailSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectDetailInclude<ExtArgs> | null
    /**
     * Filter, which ProjectDetails to fetch.
     */
    where?: ProjectDetailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectDetails to fetch.
     */
    orderBy?: ProjectDetailOrderByWithRelationInput | ProjectDetailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProjectDetails.
     */
    cursor?: ProjectDetailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectDetails.
     */
    skip?: number
    distinct?: ProjectDetailScalarFieldEnum | ProjectDetailScalarFieldEnum[]
  }

  /**
   * ProjectDetail create
   */
  export type ProjectDetailCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectDetail
     */
    select?: ProjectDetailSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectDetailInclude<ExtArgs> | null
    /**
     * The data needed to create a ProjectDetail.
     */
    data: XOR<ProjectDetailCreateInput, ProjectDetailUncheckedCreateInput>
  }

  /**
   * ProjectDetail createMany
   */
  export type ProjectDetailCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProjectDetails.
     */
    data: ProjectDetailCreateManyInput | ProjectDetailCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProjectDetail update
   */
  export type ProjectDetailUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectDetail
     */
    select?: ProjectDetailSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectDetailInclude<ExtArgs> | null
    /**
     * The data needed to update a ProjectDetail.
     */
    data: XOR<ProjectDetailUpdateInput, ProjectDetailUncheckedUpdateInput>
    /**
     * Choose, which ProjectDetail to update.
     */
    where: ProjectDetailWhereUniqueInput
  }

  /**
   * ProjectDetail updateMany
   */
  export type ProjectDetailUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProjectDetails.
     */
    data: XOR<ProjectDetailUpdateManyMutationInput, ProjectDetailUncheckedUpdateManyInput>
    /**
     * Filter which ProjectDetails to update
     */
    where?: ProjectDetailWhereInput
  }

  /**
   * ProjectDetail upsert
   */
  export type ProjectDetailUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectDetail
     */
    select?: ProjectDetailSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectDetailInclude<ExtArgs> | null
    /**
     * The filter to search for the ProjectDetail to update in case it exists.
     */
    where: ProjectDetailWhereUniqueInput
    /**
     * In case the ProjectDetail found by the `where` argument doesn't exist, create a new ProjectDetail with this data.
     */
    create: XOR<ProjectDetailCreateInput, ProjectDetailUncheckedCreateInput>
    /**
     * In case the ProjectDetail was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProjectDetailUpdateInput, ProjectDetailUncheckedUpdateInput>
  }

  /**
   * ProjectDetail delete
   */
  export type ProjectDetailDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectDetail
     */
    select?: ProjectDetailSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectDetailInclude<ExtArgs> | null
    /**
     * Filter which ProjectDetail to delete.
     */
    where: ProjectDetailWhereUniqueInput
  }

  /**
   * ProjectDetail deleteMany
   */
  export type ProjectDetailDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProjectDetails to delete
     */
    where?: ProjectDetailWhereInput
  }

  /**
   * ProjectDetail.projectBranch
   */
  export type ProjectDetail$projectBranchArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectBranch
     */
    select?: ProjectBranchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectBranchInclude<ExtArgs> | null
    where?: ProjectBranchWhereInput
    orderBy?: ProjectBranchOrderByWithRelationInput | ProjectBranchOrderByWithRelationInput[]
    cursor?: ProjectBranchWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProjectBranchScalarFieldEnum | ProjectBranchScalarFieldEnum[]
  }

  /**
   * ProjectDetail.projectMat
   */
  export type ProjectDetail$projectMatArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectMat
     */
    select?: ProjectMatSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectMatInclude<ExtArgs> | null
    where?: ProjectMatWhereInput
    orderBy?: ProjectMatOrderByWithRelationInput | ProjectMatOrderByWithRelationInput[]
    cursor?: ProjectMatWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProjectMatScalarFieldEnum | ProjectMatScalarFieldEnum[]
  }

  /**
   * ProjectDetail.projectBom
   */
  export type ProjectDetail$projectBomArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectBom
     */
    select?: ProjectBomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectBomInclude<ExtArgs> | null
    where?: ProjectBomWhereInput
    orderBy?: ProjectBomOrderByWithRelationInput | ProjectBomOrderByWithRelationInput[]
    cursor?: ProjectBomWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProjectBomScalarFieldEnum | ProjectBomScalarFieldEnum[]
  }

  /**
   * ProjectDetail.ProjectResUser
   */
  export type ProjectDetail$ProjectResUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectResUser
     */
    select?: ProjectResUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectResUserInclude<ExtArgs> | null
    where?: ProjectResUserWhereInput
    orderBy?: ProjectResUserOrderByWithRelationInput | ProjectResUserOrderByWithRelationInput[]
    cursor?: ProjectResUserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProjectResUserScalarFieldEnum | ProjectResUserScalarFieldEnum[]
  }

  /**
   * ProjectDetail without action
   */
  export type ProjectDetailDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectDetail
     */
    select?: ProjectDetailSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectDetailInclude<ExtArgs> | null
  }


  /**
   * Model ProjectBranch
   */

  export type AggregateProjectBranch = {
    _count: ProjectBranchCountAggregateOutputType | null
    _avg: ProjectBranchAvgAggregateOutputType | null
    _sum: ProjectBranchSumAggregateOutputType | null
    _min: ProjectBranchMinAggregateOutputType | null
    _max: ProjectBranchMaxAggregateOutputType | null
  }

  export type ProjectBranchAvgAggregateOutputType = {
    id: number | null
    pj_projectDetailId: number | null
  }

  export type ProjectBranchSumAggregateOutputType = {
    id: number | null
    pj_projectDetailId: number | null
  }

  export type ProjectBranchMinAggregateOutputType = {
    id: number | null
    pj_projectDetailId: number | null
    pj_remark: string | null
  }

  export type ProjectBranchMaxAggregateOutputType = {
    id: number | null
    pj_projectDetailId: number | null
    pj_remark: string | null
  }

  export type ProjectBranchCountAggregateOutputType = {
    id: number
    pj_projectDetailId: number
    pj_remark: number
    _all: number
  }


  export type ProjectBranchAvgAggregateInputType = {
    id?: true
    pj_projectDetailId?: true
  }

  export type ProjectBranchSumAggregateInputType = {
    id?: true
    pj_projectDetailId?: true
  }

  export type ProjectBranchMinAggregateInputType = {
    id?: true
    pj_projectDetailId?: true
    pj_remark?: true
  }

  export type ProjectBranchMaxAggregateInputType = {
    id?: true
    pj_projectDetailId?: true
    pj_remark?: true
  }

  export type ProjectBranchCountAggregateInputType = {
    id?: true
    pj_projectDetailId?: true
    pj_remark?: true
    _all?: true
  }

  export type ProjectBranchAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProjectBranch to aggregate.
     */
    where?: ProjectBranchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectBranches to fetch.
     */
    orderBy?: ProjectBranchOrderByWithRelationInput | ProjectBranchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProjectBranchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectBranches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectBranches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProjectBranches
    **/
    _count?: true | ProjectBranchCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProjectBranchAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProjectBranchSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProjectBranchMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProjectBranchMaxAggregateInputType
  }

  export type GetProjectBranchAggregateType<T extends ProjectBranchAggregateArgs> = {
        [P in keyof T & keyof AggregateProjectBranch]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProjectBranch[P]>
      : GetScalarType<T[P], AggregateProjectBranch[P]>
  }




  export type ProjectBranchGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectBranchWhereInput
    orderBy?: ProjectBranchOrderByWithAggregationInput | ProjectBranchOrderByWithAggregationInput[]
    by: ProjectBranchScalarFieldEnum[] | ProjectBranchScalarFieldEnum
    having?: ProjectBranchScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProjectBranchCountAggregateInputType | true
    _avg?: ProjectBranchAvgAggregateInputType
    _sum?: ProjectBranchSumAggregateInputType
    _min?: ProjectBranchMinAggregateInputType
    _max?: ProjectBranchMaxAggregateInputType
  }

  export type ProjectBranchGroupByOutputType = {
    id: number
    pj_projectDetailId: number
    pj_remark: string
    _count: ProjectBranchCountAggregateOutputType | null
    _avg: ProjectBranchAvgAggregateOutputType | null
    _sum: ProjectBranchSumAggregateOutputType | null
    _min: ProjectBranchMinAggregateOutputType | null
    _max: ProjectBranchMaxAggregateOutputType | null
  }

  type GetProjectBranchGroupByPayload<T extends ProjectBranchGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProjectBranchGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProjectBranchGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProjectBranchGroupByOutputType[P]>
            : GetScalarType<T[P], ProjectBranchGroupByOutputType[P]>
        }
      >
    >


  export type ProjectBranchSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    pj_projectDetailId?: boolean
    pj_remark?: boolean
    projectDetail?: boolean | ProjectDetailDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["projectBranch"]>


  export type ProjectBranchSelectScalar = {
    id?: boolean
    pj_projectDetailId?: boolean
    pj_remark?: boolean
  }

  export type ProjectBranchInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    projectDetail?: boolean | ProjectDetailDefaultArgs<ExtArgs>
  }

  export type $ProjectBranchPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProjectBranch"
    objects: {
      projectDetail: Prisma.$ProjectDetailPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      pj_projectDetailId: number
      pj_remark: string
    }, ExtArgs["result"]["projectBranch"]>
    composites: {}
  }

  type ProjectBranchGetPayload<S extends boolean | null | undefined | ProjectBranchDefaultArgs> = $Result.GetResult<Prisma.$ProjectBranchPayload, S>

  type ProjectBranchCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ProjectBranchFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ProjectBranchCountAggregateInputType | true
    }

  export interface ProjectBranchDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProjectBranch'], meta: { name: 'ProjectBranch' } }
    /**
     * Find zero or one ProjectBranch that matches the filter.
     * @param {ProjectBranchFindUniqueArgs} args - Arguments to find a ProjectBranch
     * @example
     * // Get one ProjectBranch
     * const projectBranch = await prisma.projectBranch.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProjectBranchFindUniqueArgs>(args: SelectSubset<T, ProjectBranchFindUniqueArgs<ExtArgs>>): Prisma__ProjectBranchClient<$Result.GetResult<Prisma.$ProjectBranchPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ProjectBranch that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ProjectBranchFindUniqueOrThrowArgs} args - Arguments to find a ProjectBranch
     * @example
     * // Get one ProjectBranch
     * const projectBranch = await prisma.projectBranch.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProjectBranchFindUniqueOrThrowArgs>(args: SelectSubset<T, ProjectBranchFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProjectBranchClient<$Result.GetResult<Prisma.$ProjectBranchPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ProjectBranch that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectBranchFindFirstArgs} args - Arguments to find a ProjectBranch
     * @example
     * // Get one ProjectBranch
     * const projectBranch = await prisma.projectBranch.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProjectBranchFindFirstArgs>(args?: SelectSubset<T, ProjectBranchFindFirstArgs<ExtArgs>>): Prisma__ProjectBranchClient<$Result.GetResult<Prisma.$ProjectBranchPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ProjectBranch that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectBranchFindFirstOrThrowArgs} args - Arguments to find a ProjectBranch
     * @example
     * // Get one ProjectBranch
     * const projectBranch = await prisma.projectBranch.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProjectBranchFindFirstOrThrowArgs>(args?: SelectSubset<T, ProjectBranchFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProjectBranchClient<$Result.GetResult<Prisma.$ProjectBranchPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ProjectBranches that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectBranchFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProjectBranches
     * const projectBranches = await prisma.projectBranch.findMany()
     * 
     * // Get first 10 ProjectBranches
     * const projectBranches = await prisma.projectBranch.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const projectBranchWithIdOnly = await prisma.projectBranch.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProjectBranchFindManyArgs>(args?: SelectSubset<T, ProjectBranchFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectBranchPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ProjectBranch.
     * @param {ProjectBranchCreateArgs} args - Arguments to create a ProjectBranch.
     * @example
     * // Create one ProjectBranch
     * const ProjectBranch = await prisma.projectBranch.create({
     *   data: {
     *     // ... data to create a ProjectBranch
     *   }
     * })
     * 
     */
    create<T extends ProjectBranchCreateArgs>(args: SelectSubset<T, ProjectBranchCreateArgs<ExtArgs>>): Prisma__ProjectBranchClient<$Result.GetResult<Prisma.$ProjectBranchPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ProjectBranches.
     * @param {ProjectBranchCreateManyArgs} args - Arguments to create many ProjectBranches.
     * @example
     * // Create many ProjectBranches
     * const projectBranch = await prisma.projectBranch.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProjectBranchCreateManyArgs>(args?: SelectSubset<T, ProjectBranchCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ProjectBranch.
     * @param {ProjectBranchDeleteArgs} args - Arguments to delete one ProjectBranch.
     * @example
     * // Delete one ProjectBranch
     * const ProjectBranch = await prisma.projectBranch.delete({
     *   where: {
     *     // ... filter to delete one ProjectBranch
     *   }
     * })
     * 
     */
    delete<T extends ProjectBranchDeleteArgs>(args: SelectSubset<T, ProjectBranchDeleteArgs<ExtArgs>>): Prisma__ProjectBranchClient<$Result.GetResult<Prisma.$ProjectBranchPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ProjectBranch.
     * @param {ProjectBranchUpdateArgs} args - Arguments to update one ProjectBranch.
     * @example
     * // Update one ProjectBranch
     * const projectBranch = await prisma.projectBranch.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProjectBranchUpdateArgs>(args: SelectSubset<T, ProjectBranchUpdateArgs<ExtArgs>>): Prisma__ProjectBranchClient<$Result.GetResult<Prisma.$ProjectBranchPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ProjectBranches.
     * @param {ProjectBranchDeleteManyArgs} args - Arguments to filter ProjectBranches to delete.
     * @example
     * // Delete a few ProjectBranches
     * const { count } = await prisma.projectBranch.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProjectBranchDeleteManyArgs>(args?: SelectSubset<T, ProjectBranchDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProjectBranches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectBranchUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProjectBranches
     * const projectBranch = await prisma.projectBranch.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProjectBranchUpdateManyArgs>(args: SelectSubset<T, ProjectBranchUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ProjectBranch.
     * @param {ProjectBranchUpsertArgs} args - Arguments to update or create a ProjectBranch.
     * @example
     * // Update or create a ProjectBranch
     * const projectBranch = await prisma.projectBranch.upsert({
     *   create: {
     *     // ... data to create a ProjectBranch
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProjectBranch we want to update
     *   }
     * })
     */
    upsert<T extends ProjectBranchUpsertArgs>(args: SelectSubset<T, ProjectBranchUpsertArgs<ExtArgs>>): Prisma__ProjectBranchClient<$Result.GetResult<Prisma.$ProjectBranchPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ProjectBranches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectBranchCountArgs} args - Arguments to filter ProjectBranches to count.
     * @example
     * // Count the number of ProjectBranches
     * const count = await prisma.projectBranch.count({
     *   where: {
     *     // ... the filter for the ProjectBranches we want to count
     *   }
     * })
    **/
    count<T extends ProjectBranchCountArgs>(
      args?: Subset<T, ProjectBranchCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProjectBranchCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProjectBranch.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectBranchAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProjectBranchAggregateArgs>(args: Subset<T, ProjectBranchAggregateArgs>): Prisma.PrismaPromise<GetProjectBranchAggregateType<T>>

    /**
     * Group by ProjectBranch.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectBranchGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProjectBranchGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProjectBranchGroupByArgs['orderBy'] }
        : { orderBy?: ProjectBranchGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProjectBranchGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProjectBranchGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProjectBranch model
   */
  readonly fields: ProjectBranchFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProjectBranch.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProjectBranchClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    projectDetail<T extends ProjectDetailDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProjectDetailDefaultArgs<ExtArgs>>): Prisma__ProjectDetailClient<$Result.GetResult<Prisma.$ProjectDetailPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProjectBranch model
   */ 
  interface ProjectBranchFieldRefs {
    readonly id: FieldRef<"ProjectBranch", 'Int'>
    readonly pj_projectDetailId: FieldRef<"ProjectBranch", 'Int'>
    readonly pj_remark: FieldRef<"ProjectBranch", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ProjectBranch findUnique
   */
  export type ProjectBranchFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectBranch
     */
    select?: ProjectBranchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectBranchInclude<ExtArgs> | null
    /**
     * Filter, which ProjectBranch to fetch.
     */
    where: ProjectBranchWhereUniqueInput
  }

  /**
   * ProjectBranch findUniqueOrThrow
   */
  export type ProjectBranchFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectBranch
     */
    select?: ProjectBranchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectBranchInclude<ExtArgs> | null
    /**
     * Filter, which ProjectBranch to fetch.
     */
    where: ProjectBranchWhereUniqueInput
  }

  /**
   * ProjectBranch findFirst
   */
  export type ProjectBranchFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectBranch
     */
    select?: ProjectBranchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectBranchInclude<ExtArgs> | null
    /**
     * Filter, which ProjectBranch to fetch.
     */
    where?: ProjectBranchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectBranches to fetch.
     */
    orderBy?: ProjectBranchOrderByWithRelationInput | ProjectBranchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProjectBranches.
     */
    cursor?: ProjectBranchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectBranches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectBranches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProjectBranches.
     */
    distinct?: ProjectBranchScalarFieldEnum | ProjectBranchScalarFieldEnum[]
  }

  /**
   * ProjectBranch findFirstOrThrow
   */
  export type ProjectBranchFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectBranch
     */
    select?: ProjectBranchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectBranchInclude<ExtArgs> | null
    /**
     * Filter, which ProjectBranch to fetch.
     */
    where?: ProjectBranchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectBranches to fetch.
     */
    orderBy?: ProjectBranchOrderByWithRelationInput | ProjectBranchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProjectBranches.
     */
    cursor?: ProjectBranchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectBranches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectBranches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProjectBranches.
     */
    distinct?: ProjectBranchScalarFieldEnum | ProjectBranchScalarFieldEnum[]
  }

  /**
   * ProjectBranch findMany
   */
  export type ProjectBranchFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectBranch
     */
    select?: ProjectBranchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectBranchInclude<ExtArgs> | null
    /**
     * Filter, which ProjectBranches to fetch.
     */
    where?: ProjectBranchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectBranches to fetch.
     */
    orderBy?: ProjectBranchOrderByWithRelationInput | ProjectBranchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProjectBranches.
     */
    cursor?: ProjectBranchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectBranches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectBranches.
     */
    skip?: number
    distinct?: ProjectBranchScalarFieldEnum | ProjectBranchScalarFieldEnum[]
  }

  /**
   * ProjectBranch create
   */
  export type ProjectBranchCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectBranch
     */
    select?: ProjectBranchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectBranchInclude<ExtArgs> | null
    /**
     * The data needed to create a ProjectBranch.
     */
    data: XOR<ProjectBranchCreateInput, ProjectBranchUncheckedCreateInput>
  }

  /**
   * ProjectBranch createMany
   */
  export type ProjectBranchCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProjectBranches.
     */
    data: ProjectBranchCreateManyInput | ProjectBranchCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProjectBranch update
   */
  export type ProjectBranchUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectBranch
     */
    select?: ProjectBranchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectBranchInclude<ExtArgs> | null
    /**
     * The data needed to update a ProjectBranch.
     */
    data: XOR<ProjectBranchUpdateInput, ProjectBranchUncheckedUpdateInput>
    /**
     * Choose, which ProjectBranch to update.
     */
    where: ProjectBranchWhereUniqueInput
  }

  /**
   * ProjectBranch updateMany
   */
  export type ProjectBranchUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProjectBranches.
     */
    data: XOR<ProjectBranchUpdateManyMutationInput, ProjectBranchUncheckedUpdateManyInput>
    /**
     * Filter which ProjectBranches to update
     */
    where?: ProjectBranchWhereInput
  }

  /**
   * ProjectBranch upsert
   */
  export type ProjectBranchUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectBranch
     */
    select?: ProjectBranchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectBranchInclude<ExtArgs> | null
    /**
     * The filter to search for the ProjectBranch to update in case it exists.
     */
    where: ProjectBranchWhereUniqueInput
    /**
     * In case the ProjectBranch found by the `where` argument doesn't exist, create a new ProjectBranch with this data.
     */
    create: XOR<ProjectBranchCreateInput, ProjectBranchUncheckedCreateInput>
    /**
     * In case the ProjectBranch was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProjectBranchUpdateInput, ProjectBranchUncheckedUpdateInput>
  }

  /**
   * ProjectBranch delete
   */
  export type ProjectBranchDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectBranch
     */
    select?: ProjectBranchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectBranchInclude<ExtArgs> | null
    /**
     * Filter which ProjectBranch to delete.
     */
    where: ProjectBranchWhereUniqueInput
  }

  /**
   * ProjectBranch deleteMany
   */
  export type ProjectBranchDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProjectBranches to delete
     */
    where?: ProjectBranchWhereInput
  }

  /**
   * ProjectBranch without action
   */
  export type ProjectBranchDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectBranch
     */
    select?: ProjectBranchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectBranchInclude<ExtArgs> | null
  }


  /**
   * Model ProjectMat
   */

  export type AggregateProjectMat = {
    _count: ProjectMatCountAggregateOutputType | null
    _avg: ProjectMatAvgAggregateOutputType | null
    _sum: ProjectMatSumAggregateOutputType | null
    _min: ProjectMatMinAggregateOutputType | null
    _max: ProjectMatMaxAggregateOutputType | null
  }

  export type ProjectMatAvgAggregateOutputType = {
    id: number | null
    pj_projectDetailId: number | null
    pj_matamount: number | null
    pj_matTatal: number | null
  }

  export type ProjectMatSumAggregateOutputType = {
    id: number | null
    pj_projectDetailId: number | null
    pj_matamount: number | null
    pj_matTatal: number | null
  }

  export type ProjectMatMinAggregateOutputType = {
    id: number | null
    pj_projectDetailId: number | null
    pj_matId: string | null
    pj_matamount: number | null
    pj_matTatal: number | null
  }

  export type ProjectMatMaxAggregateOutputType = {
    id: number | null
    pj_projectDetailId: number | null
    pj_matId: string | null
    pj_matamount: number | null
    pj_matTatal: number | null
  }

  export type ProjectMatCountAggregateOutputType = {
    id: number
    pj_projectDetailId: number
    pj_matId: number
    pj_matamount: number
    pj_matTatal: number
    _all: number
  }


  export type ProjectMatAvgAggregateInputType = {
    id?: true
    pj_projectDetailId?: true
    pj_matamount?: true
    pj_matTatal?: true
  }

  export type ProjectMatSumAggregateInputType = {
    id?: true
    pj_projectDetailId?: true
    pj_matamount?: true
    pj_matTatal?: true
  }

  export type ProjectMatMinAggregateInputType = {
    id?: true
    pj_projectDetailId?: true
    pj_matId?: true
    pj_matamount?: true
    pj_matTatal?: true
  }

  export type ProjectMatMaxAggregateInputType = {
    id?: true
    pj_projectDetailId?: true
    pj_matId?: true
    pj_matamount?: true
    pj_matTatal?: true
  }

  export type ProjectMatCountAggregateInputType = {
    id?: true
    pj_projectDetailId?: true
    pj_matId?: true
    pj_matamount?: true
    pj_matTatal?: true
    _all?: true
  }

  export type ProjectMatAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProjectMat to aggregate.
     */
    where?: ProjectMatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectMats to fetch.
     */
    orderBy?: ProjectMatOrderByWithRelationInput | ProjectMatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProjectMatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectMats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectMats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProjectMats
    **/
    _count?: true | ProjectMatCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProjectMatAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProjectMatSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProjectMatMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProjectMatMaxAggregateInputType
  }

  export type GetProjectMatAggregateType<T extends ProjectMatAggregateArgs> = {
        [P in keyof T & keyof AggregateProjectMat]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProjectMat[P]>
      : GetScalarType<T[P], AggregateProjectMat[P]>
  }




  export type ProjectMatGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectMatWhereInput
    orderBy?: ProjectMatOrderByWithAggregationInput | ProjectMatOrderByWithAggregationInput[]
    by: ProjectMatScalarFieldEnum[] | ProjectMatScalarFieldEnum
    having?: ProjectMatScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProjectMatCountAggregateInputType | true
    _avg?: ProjectMatAvgAggregateInputType
    _sum?: ProjectMatSumAggregateInputType
    _min?: ProjectMatMinAggregateInputType
    _max?: ProjectMatMaxAggregateInputType
  }

  export type ProjectMatGroupByOutputType = {
    id: number
    pj_projectDetailId: number
    pj_matId: string
    pj_matamount: number
    pj_matTatal: number
    _count: ProjectMatCountAggregateOutputType | null
    _avg: ProjectMatAvgAggregateOutputType | null
    _sum: ProjectMatSumAggregateOutputType | null
    _min: ProjectMatMinAggregateOutputType | null
    _max: ProjectMatMaxAggregateOutputType | null
  }

  type GetProjectMatGroupByPayload<T extends ProjectMatGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProjectMatGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProjectMatGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProjectMatGroupByOutputType[P]>
            : GetScalarType<T[P], ProjectMatGroupByOutputType[P]>
        }
      >
    >


  export type ProjectMatSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    pj_projectDetailId?: boolean
    pj_matId?: boolean
    pj_matamount?: boolean
    pj_matTatal?: boolean
    stock?: boolean | StockDefaultArgs<ExtArgs>
    projectDetail?: boolean | ProjectDetailDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["projectMat"]>


  export type ProjectMatSelectScalar = {
    id?: boolean
    pj_projectDetailId?: boolean
    pj_matId?: boolean
    pj_matamount?: boolean
    pj_matTatal?: boolean
  }

  export type ProjectMatInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    stock?: boolean | StockDefaultArgs<ExtArgs>
    projectDetail?: boolean | ProjectDetailDefaultArgs<ExtArgs>
  }

  export type $ProjectMatPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProjectMat"
    objects: {
      stock: Prisma.$StockPayload<ExtArgs>
      projectDetail: Prisma.$ProjectDetailPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      pj_projectDetailId: number
      pj_matId: string
      pj_matamount: number
      pj_matTatal: number
    }, ExtArgs["result"]["projectMat"]>
    composites: {}
  }

  type ProjectMatGetPayload<S extends boolean | null | undefined | ProjectMatDefaultArgs> = $Result.GetResult<Prisma.$ProjectMatPayload, S>

  type ProjectMatCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ProjectMatFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ProjectMatCountAggregateInputType | true
    }

  export interface ProjectMatDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProjectMat'], meta: { name: 'ProjectMat' } }
    /**
     * Find zero or one ProjectMat that matches the filter.
     * @param {ProjectMatFindUniqueArgs} args - Arguments to find a ProjectMat
     * @example
     * // Get one ProjectMat
     * const projectMat = await prisma.projectMat.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProjectMatFindUniqueArgs>(args: SelectSubset<T, ProjectMatFindUniqueArgs<ExtArgs>>): Prisma__ProjectMatClient<$Result.GetResult<Prisma.$ProjectMatPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ProjectMat that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ProjectMatFindUniqueOrThrowArgs} args - Arguments to find a ProjectMat
     * @example
     * // Get one ProjectMat
     * const projectMat = await prisma.projectMat.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProjectMatFindUniqueOrThrowArgs>(args: SelectSubset<T, ProjectMatFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProjectMatClient<$Result.GetResult<Prisma.$ProjectMatPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ProjectMat that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectMatFindFirstArgs} args - Arguments to find a ProjectMat
     * @example
     * // Get one ProjectMat
     * const projectMat = await prisma.projectMat.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProjectMatFindFirstArgs>(args?: SelectSubset<T, ProjectMatFindFirstArgs<ExtArgs>>): Prisma__ProjectMatClient<$Result.GetResult<Prisma.$ProjectMatPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ProjectMat that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectMatFindFirstOrThrowArgs} args - Arguments to find a ProjectMat
     * @example
     * // Get one ProjectMat
     * const projectMat = await prisma.projectMat.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProjectMatFindFirstOrThrowArgs>(args?: SelectSubset<T, ProjectMatFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProjectMatClient<$Result.GetResult<Prisma.$ProjectMatPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ProjectMats that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectMatFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProjectMats
     * const projectMats = await prisma.projectMat.findMany()
     * 
     * // Get first 10 ProjectMats
     * const projectMats = await prisma.projectMat.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const projectMatWithIdOnly = await prisma.projectMat.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProjectMatFindManyArgs>(args?: SelectSubset<T, ProjectMatFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectMatPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ProjectMat.
     * @param {ProjectMatCreateArgs} args - Arguments to create a ProjectMat.
     * @example
     * // Create one ProjectMat
     * const ProjectMat = await prisma.projectMat.create({
     *   data: {
     *     // ... data to create a ProjectMat
     *   }
     * })
     * 
     */
    create<T extends ProjectMatCreateArgs>(args: SelectSubset<T, ProjectMatCreateArgs<ExtArgs>>): Prisma__ProjectMatClient<$Result.GetResult<Prisma.$ProjectMatPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ProjectMats.
     * @param {ProjectMatCreateManyArgs} args - Arguments to create many ProjectMats.
     * @example
     * // Create many ProjectMats
     * const projectMat = await prisma.projectMat.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProjectMatCreateManyArgs>(args?: SelectSubset<T, ProjectMatCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ProjectMat.
     * @param {ProjectMatDeleteArgs} args - Arguments to delete one ProjectMat.
     * @example
     * // Delete one ProjectMat
     * const ProjectMat = await prisma.projectMat.delete({
     *   where: {
     *     // ... filter to delete one ProjectMat
     *   }
     * })
     * 
     */
    delete<T extends ProjectMatDeleteArgs>(args: SelectSubset<T, ProjectMatDeleteArgs<ExtArgs>>): Prisma__ProjectMatClient<$Result.GetResult<Prisma.$ProjectMatPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ProjectMat.
     * @param {ProjectMatUpdateArgs} args - Arguments to update one ProjectMat.
     * @example
     * // Update one ProjectMat
     * const projectMat = await prisma.projectMat.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProjectMatUpdateArgs>(args: SelectSubset<T, ProjectMatUpdateArgs<ExtArgs>>): Prisma__ProjectMatClient<$Result.GetResult<Prisma.$ProjectMatPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ProjectMats.
     * @param {ProjectMatDeleteManyArgs} args - Arguments to filter ProjectMats to delete.
     * @example
     * // Delete a few ProjectMats
     * const { count } = await prisma.projectMat.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProjectMatDeleteManyArgs>(args?: SelectSubset<T, ProjectMatDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProjectMats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectMatUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProjectMats
     * const projectMat = await prisma.projectMat.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProjectMatUpdateManyArgs>(args: SelectSubset<T, ProjectMatUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ProjectMat.
     * @param {ProjectMatUpsertArgs} args - Arguments to update or create a ProjectMat.
     * @example
     * // Update or create a ProjectMat
     * const projectMat = await prisma.projectMat.upsert({
     *   create: {
     *     // ... data to create a ProjectMat
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProjectMat we want to update
     *   }
     * })
     */
    upsert<T extends ProjectMatUpsertArgs>(args: SelectSubset<T, ProjectMatUpsertArgs<ExtArgs>>): Prisma__ProjectMatClient<$Result.GetResult<Prisma.$ProjectMatPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ProjectMats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectMatCountArgs} args - Arguments to filter ProjectMats to count.
     * @example
     * // Count the number of ProjectMats
     * const count = await prisma.projectMat.count({
     *   where: {
     *     // ... the filter for the ProjectMats we want to count
     *   }
     * })
    **/
    count<T extends ProjectMatCountArgs>(
      args?: Subset<T, ProjectMatCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProjectMatCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProjectMat.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectMatAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProjectMatAggregateArgs>(args: Subset<T, ProjectMatAggregateArgs>): Prisma.PrismaPromise<GetProjectMatAggregateType<T>>

    /**
     * Group by ProjectMat.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectMatGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProjectMatGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProjectMatGroupByArgs['orderBy'] }
        : { orderBy?: ProjectMatGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProjectMatGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProjectMatGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProjectMat model
   */
  readonly fields: ProjectMatFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProjectMat.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProjectMatClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    stock<T extends StockDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StockDefaultArgs<ExtArgs>>): Prisma__StockClient<$Result.GetResult<Prisma.$StockPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    projectDetail<T extends ProjectDetailDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProjectDetailDefaultArgs<ExtArgs>>): Prisma__ProjectDetailClient<$Result.GetResult<Prisma.$ProjectDetailPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProjectMat model
   */ 
  interface ProjectMatFieldRefs {
    readonly id: FieldRef<"ProjectMat", 'Int'>
    readonly pj_projectDetailId: FieldRef<"ProjectMat", 'Int'>
    readonly pj_matId: FieldRef<"ProjectMat", 'String'>
    readonly pj_matamount: FieldRef<"ProjectMat", 'Int'>
    readonly pj_matTatal: FieldRef<"ProjectMat", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * ProjectMat findUnique
   */
  export type ProjectMatFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectMat
     */
    select?: ProjectMatSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectMatInclude<ExtArgs> | null
    /**
     * Filter, which ProjectMat to fetch.
     */
    where: ProjectMatWhereUniqueInput
  }

  /**
   * ProjectMat findUniqueOrThrow
   */
  export type ProjectMatFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectMat
     */
    select?: ProjectMatSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectMatInclude<ExtArgs> | null
    /**
     * Filter, which ProjectMat to fetch.
     */
    where: ProjectMatWhereUniqueInput
  }

  /**
   * ProjectMat findFirst
   */
  export type ProjectMatFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectMat
     */
    select?: ProjectMatSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectMatInclude<ExtArgs> | null
    /**
     * Filter, which ProjectMat to fetch.
     */
    where?: ProjectMatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectMats to fetch.
     */
    orderBy?: ProjectMatOrderByWithRelationInput | ProjectMatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProjectMats.
     */
    cursor?: ProjectMatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectMats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectMats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProjectMats.
     */
    distinct?: ProjectMatScalarFieldEnum | ProjectMatScalarFieldEnum[]
  }

  /**
   * ProjectMat findFirstOrThrow
   */
  export type ProjectMatFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectMat
     */
    select?: ProjectMatSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectMatInclude<ExtArgs> | null
    /**
     * Filter, which ProjectMat to fetch.
     */
    where?: ProjectMatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectMats to fetch.
     */
    orderBy?: ProjectMatOrderByWithRelationInput | ProjectMatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProjectMats.
     */
    cursor?: ProjectMatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectMats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectMats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProjectMats.
     */
    distinct?: ProjectMatScalarFieldEnum | ProjectMatScalarFieldEnum[]
  }

  /**
   * ProjectMat findMany
   */
  export type ProjectMatFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectMat
     */
    select?: ProjectMatSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectMatInclude<ExtArgs> | null
    /**
     * Filter, which ProjectMats to fetch.
     */
    where?: ProjectMatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectMats to fetch.
     */
    orderBy?: ProjectMatOrderByWithRelationInput | ProjectMatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProjectMats.
     */
    cursor?: ProjectMatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectMats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectMats.
     */
    skip?: number
    distinct?: ProjectMatScalarFieldEnum | ProjectMatScalarFieldEnum[]
  }

  /**
   * ProjectMat create
   */
  export type ProjectMatCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectMat
     */
    select?: ProjectMatSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectMatInclude<ExtArgs> | null
    /**
     * The data needed to create a ProjectMat.
     */
    data: XOR<ProjectMatCreateInput, ProjectMatUncheckedCreateInput>
  }

  /**
   * ProjectMat createMany
   */
  export type ProjectMatCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProjectMats.
     */
    data: ProjectMatCreateManyInput | ProjectMatCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProjectMat update
   */
  export type ProjectMatUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectMat
     */
    select?: ProjectMatSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectMatInclude<ExtArgs> | null
    /**
     * The data needed to update a ProjectMat.
     */
    data: XOR<ProjectMatUpdateInput, ProjectMatUncheckedUpdateInput>
    /**
     * Choose, which ProjectMat to update.
     */
    where: ProjectMatWhereUniqueInput
  }

  /**
   * ProjectMat updateMany
   */
  export type ProjectMatUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProjectMats.
     */
    data: XOR<ProjectMatUpdateManyMutationInput, ProjectMatUncheckedUpdateManyInput>
    /**
     * Filter which ProjectMats to update
     */
    where?: ProjectMatWhereInput
  }

  /**
   * ProjectMat upsert
   */
  export type ProjectMatUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectMat
     */
    select?: ProjectMatSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectMatInclude<ExtArgs> | null
    /**
     * The filter to search for the ProjectMat to update in case it exists.
     */
    where: ProjectMatWhereUniqueInput
    /**
     * In case the ProjectMat found by the `where` argument doesn't exist, create a new ProjectMat with this data.
     */
    create: XOR<ProjectMatCreateInput, ProjectMatUncheckedCreateInput>
    /**
     * In case the ProjectMat was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProjectMatUpdateInput, ProjectMatUncheckedUpdateInput>
  }

  /**
   * ProjectMat delete
   */
  export type ProjectMatDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectMat
     */
    select?: ProjectMatSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectMatInclude<ExtArgs> | null
    /**
     * Filter which ProjectMat to delete.
     */
    where: ProjectMatWhereUniqueInput
  }

  /**
   * ProjectMat deleteMany
   */
  export type ProjectMatDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProjectMats to delete
     */
    where?: ProjectMatWhereInput
  }

  /**
   * ProjectMat without action
   */
  export type ProjectMatDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectMat
     */
    select?: ProjectMatSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectMatInclude<ExtArgs> | null
  }


  /**
   * Model ProjectBom
   */

  export type AggregateProjectBom = {
    _count: ProjectBomCountAggregateOutputType | null
    _avg: ProjectBomAvgAggregateOutputType | null
    _sum: ProjectBomSumAggregateOutputType | null
    _min: ProjectBomMinAggregateOutputType | null
    _max: ProjectBomMaxAggregateOutputType | null
  }

  export type ProjectBomAvgAggregateOutputType = {
    id: number | null
    pj_projectDetailId: number | null
    pj_bomamount: number | null
    pj_bomTatal: number | null
  }

  export type ProjectBomSumAggregateOutputType = {
    id: number | null
    pj_projectDetailId: number | null
    pj_bomamount: number | null
    pj_bomTatal: number | null
  }

  export type ProjectBomMinAggregateOutputType = {
    id: number | null
    pj_projectDetailId: number | null
    pj_bomId: string | null
    pj_bomamount: number | null
    pj_bomTatal: number | null
  }

  export type ProjectBomMaxAggregateOutputType = {
    id: number | null
    pj_projectDetailId: number | null
    pj_bomId: string | null
    pj_bomamount: number | null
    pj_bomTatal: number | null
  }

  export type ProjectBomCountAggregateOutputType = {
    id: number
    pj_projectDetailId: number
    pj_bomId: number
    pj_bomamount: number
    pj_bomTatal: number
    _all: number
  }


  export type ProjectBomAvgAggregateInputType = {
    id?: true
    pj_projectDetailId?: true
    pj_bomamount?: true
    pj_bomTatal?: true
  }

  export type ProjectBomSumAggregateInputType = {
    id?: true
    pj_projectDetailId?: true
    pj_bomamount?: true
    pj_bomTatal?: true
  }

  export type ProjectBomMinAggregateInputType = {
    id?: true
    pj_projectDetailId?: true
    pj_bomId?: true
    pj_bomamount?: true
    pj_bomTatal?: true
  }

  export type ProjectBomMaxAggregateInputType = {
    id?: true
    pj_projectDetailId?: true
    pj_bomId?: true
    pj_bomamount?: true
    pj_bomTatal?: true
  }

  export type ProjectBomCountAggregateInputType = {
    id?: true
    pj_projectDetailId?: true
    pj_bomId?: true
    pj_bomamount?: true
    pj_bomTatal?: true
    _all?: true
  }

  export type ProjectBomAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProjectBom to aggregate.
     */
    where?: ProjectBomWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectBoms to fetch.
     */
    orderBy?: ProjectBomOrderByWithRelationInput | ProjectBomOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProjectBomWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectBoms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectBoms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProjectBoms
    **/
    _count?: true | ProjectBomCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProjectBomAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProjectBomSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProjectBomMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProjectBomMaxAggregateInputType
  }

  export type GetProjectBomAggregateType<T extends ProjectBomAggregateArgs> = {
        [P in keyof T & keyof AggregateProjectBom]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProjectBom[P]>
      : GetScalarType<T[P], AggregateProjectBom[P]>
  }




  export type ProjectBomGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectBomWhereInput
    orderBy?: ProjectBomOrderByWithAggregationInput | ProjectBomOrderByWithAggregationInput[]
    by: ProjectBomScalarFieldEnum[] | ProjectBomScalarFieldEnum
    having?: ProjectBomScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProjectBomCountAggregateInputType | true
    _avg?: ProjectBomAvgAggregateInputType
    _sum?: ProjectBomSumAggregateInputType
    _min?: ProjectBomMinAggregateInputType
    _max?: ProjectBomMaxAggregateInputType
  }

  export type ProjectBomGroupByOutputType = {
    id: number
    pj_projectDetailId: number
    pj_bomId: string
    pj_bomamount: number
    pj_bomTatal: number
    _count: ProjectBomCountAggregateOutputType | null
    _avg: ProjectBomAvgAggregateOutputType | null
    _sum: ProjectBomSumAggregateOutputType | null
    _min: ProjectBomMinAggregateOutputType | null
    _max: ProjectBomMaxAggregateOutputType | null
  }

  type GetProjectBomGroupByPayload<T extends ProjectBomGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProjectBomGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProjectBomGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProjectBomGroupByOutputType[P]>
            : GetScalarType<T[P], ProjectBomGroupByOutputType[P]>
        }
      >
    >


  export type ProjectBomSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    pj_projectDetailId?: boolean
    pj_bomId?: boolean
    pj_bomamount?: boolean
    pj_bomTatal?: boolean
    stock?: boolean | StockDefaultArgs<ExtArgs>
    projectDetail?: boolean | ProjectDetailDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["projectBom"]>


  export type ProjectBomSelectScalar = {
    id?: boolean
    pj_projectDetailId?: boolean
    pj_bomId?: boolean
    pj_bomamount?: boolean
    pj_bomTatal?: boolean
  }

  export type ProjectBomInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    stock?: boolean | StockDefaultArgs<ExtArgs>
    projectDetail?: boolean | ProjectDetailDefaultArgs<ExtArgs>
  }

  export type $ProjectBomPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProjectBom"
    objects: {
      stock: Prisma.$StockPayload<ExtArgs>
      projectDetail: Prisma.$ProjectDetailPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      pj_projectDetailId: number
      pj_bomId: string
      pj_bomamount: number
      pj_bomTatal: number
    }, ExtArgs["result"]["projectBom"]>
    composites: {}
  }

  type ProjectBomGetPayload<S extends boolean | null | undefined | ProjectBomDefaultArgs> = $Result.GetResult<Prisma.$ProjectBomPayload, S>

  type ProjectBomCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ProjectBomFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ProjectBomCountAggregateInputType | true
    }

  export interface ProjectBomDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProjectBom'], meta: { name: 'ProjectBom' } }
    /**
     * Find zero or one ProjectBom that matches the filter.
     * @param {ProjectBomFindUniqueArgs} args - Arguments to find a ProjectBom
     * @example
     * // Get one ProjectBom
     * const projectBom = await prisma.projectBom.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProjectBomFindUniqueArgs>(args: SelectSubset<T, ProjectBomFindUniqueArgs<ExtArgs>>): Prisma__ProjectBomClient<$Result.GetResult<Prisma.$ProjectBomPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ProjectBom that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ProjectBomFindUniqueOrThrowArgs} args - Arguments to find a ProjectBom
     * @example
     * // Get one ProjectBom
     * const projectBom = await prisma.projectBom.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProjectBomFindUniqueOrThrowArgs>(args: SelectSubset<T, ProjectBomFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProjectBomClient<$Result.GetResult<Prisma.$ProjectBomPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ProjectBom that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectBomFindFirstArgs} args - Arguments to find a ProjectBom
     * @example
     * // Get one ProjectBom
     * const projectBom = await prisma.projectBom.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProjectBomFindFirstArgs>(args?: SelectSubset<T, ProjectBomFindFirstArgs<ExtArgs>>): Prisma__ProjectBomClient<$Result.GetResult<Prisma.$ProjectBomPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ProjectBom that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectBomFindFirstOrThrowArgs} args - Arguments to find a ProjectBom
     * @example
     * // Get one ProjectBom
     * const projectBom = await prisma.projectBom.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProjectBomFindFirstOrThrowArgs>(args?: SelectSubset<T, ProjectBomFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProjectBomClient<$Result.GetResult<Prisma.$ProjectBomPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ProjectBoms that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectBomFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProjectBoms
     * const projectBoms = await prisma.projectBom.findMany()
     * 
     * // Get first 10 ProjectBoms
     * const projectBoms = await prisma.projectBom.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const projectBomWithIdOnly = await prisma.projectBom.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProjectBomFindManyArgs>(args?: SelectSubset<T, ProjectBomFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectBomPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ProjectBom.
     * @param {ProjectBomCreateArgs} args - Arguments to create a ProjectBom.
     * @example
     * // Create one ProjectBom
     * const ProjectBom = await prisma.projectBom.create({
     *   data: {
     *     // ... data to create a ProjectBom
     *   }
     * })
     * 
     */
    create<T extends ProjectBomCreateArgs>(args: SelectSubset<T, ProjectBomCreateArgs<ExtArgs>>): Prisma__ProjectBomClient<$Result.GetResult<Prisma.$ProjectBomPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ProjectBoms.
     * @param {ProjectBomCreateManyArgs} args - Arguments to create many ProjectBoms.
     * @example
     * // Create many ProjectBoms
     * const projectBom = await prisma.projectBom.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProjectBomCreateManyArgs>(args?: SelectSubset<T, ProjectBomCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ProjectBom.
     * @param {ProjectBomDeleteArgs} args - Arguments to delete one ProjectBom.
     * @example
     * // Delete one ProjectBom
     * const ProjectBom = await prisma.projectBom.delete({
     *   where: {
     *     // ... filter to delete one ProjectBom
     *   }
     * })
     * 
     */
    delete<T extends ProjectBomDeleteArgs>(args: SelectSubset<T, ProjectBomDeleteArgs<ExtArgs>>): Prisma__ProjectBomClient<$Result.GetResult<Prisma.$ProjectBomPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ProjectBom.
     * @param {ProjectBomUpdateArgs} args - Arguments to update one ProjectBom.
     * @example
     * // Update one ProjectBom
     * const projectBom = await prisma.projectBom.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProjectBomUpdateArgs>(args: SelectSubset<T, ProjectBomUpdateArgs<ExtArgs>>): Prisma__ProjectBomClient<$Result.GetResult<Prisma.$ProjectBomPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ProjectBoms.
     * @param {ProjectBomDeleteManyArgs} args - Arguments to filter ProjectBoms to delete.
     * @example
     * // Delete a few ProjectBoms
     * const { count } = await prisma.projectBom.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProjectBomDeleteManyArgs>(args?: SelectSubset<T, ProjectBomDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProjectBoms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectBomUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProjectBoms
     * const projectBom = await prisma.projectBom.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProjectBomUpdateManyArgs>(args: SelectSubset<T, ProjectBomUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ProjectBom.
     * @param {ProjectBomUpsertArgs} args - Arguments to update or create a ProjectBom.
     * @example
     * // Update or create a ProjectBom
     * const projectBom = await prisma.projectBom.upsert({
     *   create: {
     *     // ... data to create a ProjectBom
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProjectBom we want to update
     *   }
     * })
     */
    upsert<T extends ProjectBomUpsertArgs>(args: SelectSubset<T, ProjectBomUpsertArgs<ExtArgs>>): Prisma__ProjectBomClient<$Result.GetResult<Prisma.$ProjectBomPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ProjectBoms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectBomCountArgs} args - Arguments to filter ProjectBoms to count.
     * @example
     * // Count the number of ProjectBoms
     * const count = await prisma.projectBom.count({
     *   where: {
     *     // ... the filter for the ProjectBoms we want to count
     *   }
     * })
    **/
    count<T extends ProjectBomCountArgs>(
      args?: Subset<T, ProjectBomCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProjectBomCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProjectBom.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectBomAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProjectBomAggregateArgs>(args: Subset<T, ProjectBomAggregateArgs>): Prisma.PrismaPromise<GetProjectBomAggregateType<T>>

    /**
     * Group by ProjectBom.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectBomGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProjectBomGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProjectBomGroupByArgs['orderBy'] }
        : { orderBy?: ProjectBomGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProjectBomGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProjectBomGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProjectBom model
   */
  readonly fields: ProjectBomFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProjectBom.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProjectBomClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    stock<T extends StockDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StockDefaultArgs<ExtArgs>>): Prisma__StockClient<$Result.GetResult<Prisma.$StockPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    projectDetail<T extends ProjectDetailDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProjectDetailDefaultArgs<ExtArgs>>): Prisma__ProjectDetailClient<$Result.GetResult<Prisma.$ProjectDetailPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProjectBom model
   */ 
  interface ProjectBomFieldRefs {
    readonly id: FieldRef<"ProjectBom", 'Int'>
    readonly pj_projectDetailId: FieldRef<"ProjectBom", 'Int'>
    readonly pj_bomId: FieldRef<"ProjectBom", 'String'>
    readonly pj_bomamount: FieldRef<"ProjectBom", 'Int'>
    readonly pj_bomTatal: FieldRef<"ProjectBom", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * ProjectBom findUnique
   */
  export type ProjectBomFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectBom
     */
    select?: ProjectBomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectBomInclude<ExtArgs> | null
    /**
     * Filter, which ProjectBom to fetch.
     */
    where: ProjectBomWhereUniqueInput
  }

  /**
   * ProjectBom findUniqueOrThrow
   */
  export type ProjectBomFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectBom
     */
    select?: ProjectBomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectBomInclude<ExtArgs> | null
    /**
     * Filter, which ProjectBom to fetch.
     */
    where: ProjectBomWhereUniqueInput
  }

  /**
   * ProjectBom findFirst
   */
  export type ProjectBomFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectBom
     */
    select?: ProjectBomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectBomInclude<ExtArgs> | null
    /**
     * Filter, which ProjectBom to fetch.
     */
    where?: ProjectBomWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectBoms to fetch.
     */
    orderBy?: ProjectBomOrderByWithRelationInput | ProjectBomOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProjectBoms.
     */
    cursor?: ProjectBomWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectBoms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectBoms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProjectBoms.
     */
    distinct?: ProjectBomScalarFieldEnum | ProjectBomScalarFieldEnum[]
  }

  /**
   * ProjectBom findFirstOrThrow
   */
  export type ProjectBomFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectBom
     */
    select?: ProjectBomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectBomInclude<ExtArgs> | null
    /**
     * Filter, which ProjectBom to fetch.
     */
    where?: ProjectBomWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectBoms to fetch.
     */
    orderBy?: ProjectBomOrderByWithRelationInput | ProjectBomOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProjectBoms.
     */
    cursor?: ProjectBomWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectBoms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectBoms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProjectBoms.
     */
    distinct?: ProjectBomScalarFieldEnum | ProjectBomScalarFieldEnum[]
  }

  /**
   * ProjectBom findMany
   */
  export type ProjectBomFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectBom
     */
    select?: ProjectBomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectBomInclude<ExtArgs> | null
    /**
     * Filter, which ProjectBoms to fetch.
     */
    where?: ProjectBomWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectBoms to fetch.
     */
    orderBy?: ProjectBomOrderByWithRelationInput | ProjectBomOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProjectBoms.
     */
    cursor?: ProjectBomWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectBoms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectBoms.
     */
    skip?: number
    distinct?: ProjectBomScalarFieldEnum | ProjectBomScalarFieldEnum[]
  }

  /**
   * ProjectBom create
   */
  export type ProjectBomCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectBom
     */
    select?: ProjectBomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectBomInclude<ExtArgs> | null
    /**
     * The data needed to create a ProjectBom.
     */
    data: XOR<ProjectBomCreateInput, ProjectBomUncheckedCreateInput>
  }

  /**
   * ProjectBom createMany
   */
  export type ProjectBomCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProjectBoms.
     */
    data: ProjectBomCreateManyInput | ProjectBomCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProjectBom update
   */
  export type ProjectBomUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectBom
     */
    select?: ProjectBomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectBomInclude<ExtArgs> | null
    /**
     * The data needed to update a ProjectBom.
     */
    data: XOR<ProjectBomUpdateInput, ProjectBomUncheckedUpdateInput>
    /**
     * Choose, which ProjectBom to update.
     */
    where: ProjectBomWhereUniqueInput
  }

  /**
   * ProjectBom updateMany
   */
  export type ProjectBomUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProjectBoms.
     */
    data: XOR<ProjectBomUpdateManyMutationInput, ProjectBomUncheckedUpdateManyInput>
    /**
     * Filter which ProjectBoms to update
     */
    where?: ProjectBomWhereInput
  }

  /**
   * ProjectBom upsert
   */
  export type ProjectBomUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectBom
     */
    select?: ProjectBomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectBomInclude<ExtArgs> | null
    /**
     * The filter to search for the ProjectBom to update in case it exists.
     */
    where: ProjectBomWhereUniqueInput
    /**
     * In case the ProjectBom found by the `where` argument doesn't exist, create a new ProjectBom with this data.
     */
    create: XOR<ProjectBomCreateInput, ProjectBomUncheckedCreateInput>
    /**
     * In case the ProjectBom was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProjectBomUpdateInput, ProjectBomUncheckedUpdateInput>
  }

  /**
   * ProjectBom delete
   */
  export type ProjectBomDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectBom
     */
    select?: ProjectBomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectBomInclude<ExtArgs> | null
    /**
     * Filter which ProjectBom to delete.
     */
    where: ProjectBomWhereUniqueInput
  }

  /**
   * ProjectBom deleteMany
   */
  export type ProjectBomDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProjectBoms to delete
     */
    where?: ProjectBomWhereInput
  }

  /**
   * ProjectBom without action
   */
  export type ProjectBomDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectBom
     */
    select?: ProjectBomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectBomInclude<ExtArgs> | null
  }


  /**
   * Model ProjectResUser
   */

  export type AggregateProjectResUser = {
    _count: ProjectResUserCountAggregateOutputType | null
    _avg: ProjectResUserAvgAggregateOutputType | null
    _sum: ProjectResUserSumAggregateOutputType | null
    _min: ProjectResUserMinAggregateOutputType | null
    _max: ProjectResUserMaxAggregateOutputType | null
  }

  export type ProjectResUserAvgAggregateOutputType = {
    id: number | null
    pj_projectDetailId: number | null
  }

  export type ProjectResUserSumAggregateOutputType = {
    id: number | null
    pj_projectDetailId: number | null
  }

  export type ProjectResUserMinAggregateOutputType = {
    id: number | null
    pj_projectDetailId: number | null
    pj_userId: string | null
  }

  export type ProjectResUserMaxAggregateOutputType = {
    id: number | null
    pj_projectDetailId: number | null
    pj_userId: string | null
  }

  export type ProjectResUserCountAggregateOutputType = {
    id: number
    pj_projectDetailId: number
    pj_userId: number
    _all: number
  }


  export type ProjectResUserAvgAggregateInputType = {
    id?: true
    pj_projectDetailId?: true
  }

  export type ProjectResUserSumAggregateInputType = {
    id?: true
    pj_projectDetailId?: true
  }

  export type ProjectResUserMinAggregateInputType = {
    id?: true
    pj_projectDetailId?: true
    pj_userId?: true
  }

  export type ProjectResUserMaxAggregateInputType = {
    id?: true
    pj_projectDetailId?: true
    pj_userId?: true
  }

  export type ProjectResUserCountAggregateInputType = {
    id?: true
    pj_projectDetailId?: true
    pj_userId?: true
    _all?: true
  }

  export type ProjectResUserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProjectResUser to aggregate.
     */
    where?: ProjectResUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectResUsers to fetch.
     */
    orderBy?: ProjectResUserOrderByWithRelationInput | ProjectResUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProjectResUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectResUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectResUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProjectResUsers
    **/
    _count?: true | ProjectResUserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProjectResUserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProjectResUserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProjectResUserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProjectResUserMaxAggregateInputType
  }

  export type GetProjectResUserAggregateType<T extends ProjectResUserAggregateArgs> = {
        [P in keyof T & keyof AggregateProjectResUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProjectResUser[P]>
      : GetScalarType<T[P], AggregateProjectResUser[P]>
  }




  export type ProjectResUserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectResUserWhereInput
    orderBy?: ProjectResUserOrderByWithAggregationInput | ProjectResUserOrderByWithAggregationInput[]
    by: ProjectResUserScalarFieldEnum[] | ProjectResUserScalarFieldEnum
    having?: ProjectResUserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProjectResUserCountAggregateInputType | true
    _avg?: ProjectResUserAvgAggregateInputType
    _sum?: ProjectResUserSumAggregateInputType
    _min?: ProjectResUserMinAggregateInputType
    _max?: ProjectResUserMaxAggregateInputType
  }

  export type ProjectResUserGroupByOutputType = {
    id: number
    pj_projectDetailId: number
    pj_userId: string
    _count: ProjectResUserCountAggregateOutputType | null
    _avg: ProjectResUserAvgAggregateOutputType | null
    _sum: ProjectResUserSumAggregateOutputType | null
    _min: ProjectResUserMinAggregateOutputType | null
    _max: ProjectResUserMaxAggregateOutputType | null
  }

  type GetProjectResUserGroupByPayload<T extends ProjectResUserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProjectResUserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProjectResUserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProjectResUserGroupByOutputType[P]>
            : GetScalarType<T[P], ProjectResUserGroupByOutputType[P]>
        }
      >
    >


  export type ProjectResUserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    pj_projectDetailId?: boolean
    pj_userId?: boolean
    projectDetail?: boolean | ProjectDetailDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["projectResUser"]>


  export type ProjectResUserSelectScalar = {
    id?: boolean
    pj_projectDetailId?: boolean
    pj_userId?: boolean
  }

  export type ProjectResUserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    projectDetail?: boolean | ProjectDetailDefaultArgs<ExtArgs>
  }

  export type $ProjectResUserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProjectResUser"
    objects: {
      projectDetail: Prisma.$ProjectDetailPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      pj_projectDetailId: number
      pj_userId: string
    }, ExtArgs["result"]["projectResUser"]>
    composites: {}
  }

  type ProjectResUserGetPayload<S extends boolean | null | undefined | ProjectResUserDefaultArgs> = $Result.GetResult<Prisma.$ProjectResUserPayload, S>

  type ProjectResUserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ProjectResUserFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ProjectResUserCountAggregateInputType | true
    }

  export interface ProjectResUserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProjectResUser'], meta: { name: 'ProjectResUser' } }
    /**
     * Find zero or one ProjectResUser that matches the filter.
     * @param {ProjectResUserFindUniqueArgs} args - Arguments to find a ProjectResUser
     * @example
     * // Get one ProjectResUser
     * const projectResUser = await prisma.projectResUser.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProjectResUserFindUniqueArgs>(args: SelectSubset<T, ProjectResUserFindUniqueArgs<ExtArgs>>): Prisma__ProjectResUserClient<$Result.GetResult<Prisma.$ProjectResUserPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ProjectResUser that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ProjectResUserFindUniqueOrThrowArgs} args - Arguments to find a ProjectResUser
     * @example
     * // Get one ProjectResUser
     * const projectResUser = await prisma.projectResUser.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProjectResUserFindUniqueOrThrowArgs>(args: SelectSubset<T, ProjectResUserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProjectResUserClient<$Result.GetResult<Prisma.$ProjectResUserPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ProjectResUser that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectResUserFindFirstArgs} args - Arguments to find a ProjectResUser
     * @example
     * // Get one ProjectResUser
     * const projectResUser = await prisma.projectResUser.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProjectResUserFindFirstArgs>(args?: SelectSubset<T, ProjectResUserFindFirstArgs<ExtArgs>>): Prisma__ProjectResUserClient<$Result.GetResult<Prisma.$ProjectResUserPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ProjectResUser that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectResUserFindFirstOrThrowArgs} args - Arguments to find a ProjectResUser
     * @example
     * // Get one ProjectResUser
     * const projectResUser = await prisma.projectResUser.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProjectResUserFindFirstOrThrowArgs>(args?: SelectSubset<T, ProjectResUserFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProjectResUserClient<$Result.GetResult<Prisma.$ProjectResUserPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ProjectResUsers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectResUserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProjectResUsers
     * const projectResUsers = await prisma.projectResUser.findMany()
     * 
     * // Get first 10 ProjectResUsers
     * const projectResUsers = await prisma.projectResUser.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const projectResUserWithIdOnly = await prisma.projectResUser.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProjectResUserFindManyArgs>(args?: SelectSubset<T, ProjectResUserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectResUserPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ProjectResUser.
     * @param {ProjectResUserCreateArgs} args - Arguments to create a ProjectResUser.
     * @example
     * // Create one ProjectResUser
     * const ProjectResUser = await prisma.projectResUser.create({
     *   data: {
     *     // ... data to create a ProjectResUser
     *   }
     * })
     * 
     */
    create<T extends ProjectResUserCreateArgs>(args: SelectSubset<T, ProjectResUserCreateArgs<ExtArgs>>): Prisma__ProjectResUserClient<$Result.GetResult<Prisma.$ProjectResUserPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ProjectResUsers.
     * @param {ProjectResUserCreateManyArgs} args - Arguments to create many ProjectResUsers.
     * @example
     * // Create many ProjectResUsers
     * const projectResUser = await prisma.projectResUser.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProjectResUserCreateManyArgs>(args?: SelectSubset<T, ProjectResUserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ProjectResUser.
     * @param {ProjectResUserDeleteArgs} args - Arguments to delete one ProjectResUser.
     * @example
     * // Delete one ProjectResUser
     * const ProjectResUser = await prisma.projectResUser.delete({
     *   where: {
     *     // ... filter to delete one ProjectResUser
     *   }
     * })
     * 
     */
    delete<T extends ProjectResUserDeleteArgs>(args: SelectSubset<T, ProjectResUserDeleteArgs<ExtArgs>>): Prisma__ProjectResUserClient<$Result.GetResult<Prisma.$ProjectResUserPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ProjectResUser.
     * @param {ProjectResUserUpdateArgs} args - Arguments to update one ProjectResUser.
     * @example
     * // Update one ProjectResUser
     * const projectResUser = await prisma.projectResUser.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProjectResUserUpdateArgs>(args: SelectSubset<T, ProjectResUserUpdateArgs<ExtArgs>>): Prisma__ProjectResUserClient<$Result.GetResult<Prisma.$ProjectResUserPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ProjectResUsers.
     * @param {ProjectResUserDeleteManyArgs} args - Arguments to filter ProjectResUsers to delete.
     * @example
     * // Delete a few ProjectResUsers
     * const { count } = await prisma.projectResUser.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProjectResUserDeleteManyArgs>(args?: SelectSubset<T, ProjectResUserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProjectResUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectResUserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProjectResUsers
     * const projectResUser = await prisma.projectResUser.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProjectResUserUpdateManyArgs>(args: SelectSubset<T, ProjectResUserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ProjectResUser.
     * @param {ProjectResUserUpsertArgs} args - Arguments to update or create a ProjectResUser.
     * @example
     * // Update or create a ProjectResUser
     * const projectResUser = await prisma.projectResUser.upsert({
     *   create: {
     *     // ... data to create a ProjectResUser
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProjectResUser we want to update
     *   }
     * })
     */
    upsert<T extends ProjectResUserUpsertArgs>(args: SelectSubset<T, ProjectResUserUpsertArgs<ExtArgs>>): Prisma__ProjectResUserClient<$Result.GetResult<Prisma.$ProjectResUserPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ProjectResUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectResUserCountArgs} args - Arguments to filter ProjectResUsers to count.
     * @example
     * // Count the number of ProjectResUsers
     * const count = await prisma.projectResUser.count({
     *   where: {
     *     // ... the filter for the ProjectResUsers we want to count
     *   }
     * })
    **/
    count<T extends ProjectResUserCountArgs>(
      args?: Subset<T, ProjectResUserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProjectResUserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProjectResUser.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectResUserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProjectResUserAggregateArgs>(args: Subset<T, ProjectResUserAggregateArgs>): Prisma.PrismaPromise<GetProjectResUserAggregateType<T>>

    /**
     * Group by ProjectResUser.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectResUserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProjectResUserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProjectResUserGroupByArgs['orderBy'] }
        : { orderBy?: ProjectResUserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProjectResUserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProjectResUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProjectResUser model
   */
  readonly fields: ProjectResUserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProjectResUser.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProjectResUserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    projectDetail<T extends ProjectDetailDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProjectDetailDefaultArgs<ExtArgs>>): Prisma__ProjectDetailClient<$Result.GetResult<Prisma.$ProjectDetailPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProjectResUser model
   */ 
  interface ProjectResUserFieldRefs {
    readonly id: FieldRef<"ProjectResUser", 'Int'>
    readonly pj_projectDetailId: FieldRef<"ProjectResUser", 'Int'>
    readonly pj_userId: FieldRef<"ProjectResUser", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ProjectResUser findUnique
   */
  export type ProjectResUserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectResUser
     */
    select?: ProjectResUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectResUserInclude<ExtArgs> | null
    /**
     * Filter, which ProjectResUser to fetch.
     */
    where: ProjectResUserWhereUniqueInput
  }

  /**
   * ProjectResUser findUniqueOrThrow
   */
  export type ProjectResUserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectResUser
     */
    select?: ProjectResUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectResUserInclude<ExtArgs> | null
    /**
     * Filter, which ProjectResUser to fetch.
     */
    where: ProjectResUserWhereUniqueInput
  }

  /**
   * ProjectResUser findFirst
   */
  export type ProjectResUserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectResUser
     */
    select?: ProjectResUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectResUserInclude<ExtArgs> | null
    /**
     * Filter, which ProjectResUser to fetch.
     */
    where?: ProjectResUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectResUsers to fetch.
     */
    orderBy?: ProjectResUserOrderByWithRelationInput | ProjectResUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProjectResUsers.
     */
    cursor?: ProjectResUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectResUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectResUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProjectResUsers.
     */
    distinct?: ProjectResUserScalarFieldEnum | ProjectResUserScalarFieldEnum[]
  }

  /**
   * ProjectResUser findFirstOrThrow
   */
  export type ProjectResUserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectResUser
     */
    select?: ProjectResUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectResUserInclude<ExtArgs> | null
    /**
     * Filter, which ProjectResUser to fetch.
     */
    where?: ProjectResUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectResUsers to fetch.
     */
    orderBy?: ProjectResUserOrderByWithRelationInput | ProjectResUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProjectResUsers.
     */
    cursor?: ProjectResUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectResUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectResUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProjectResUsers.
     */
    distinct?: ProjectResUserScalarFieldEnum | ProjectResUserScalarFieldEnum[]
  }

  /**
   * ProjectResUser findMany
   */
  export type ProjectResUserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectResUser
     */
    select?: ProjectResUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectResUserInclude<ExtArgs> | null
    /**
     * Filter, which ProjectResUsers to fetch.
     */
    where?: ProjectResUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectResUsers to fetch.
     */
    orderBy?: ProjectResUserOrderByWithRelationInput | ProjectResUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProjectResUsers.
     */
    cursor?: ProjectResUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectResUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectResUsers.
     */
    skip?: number
    distinct?: ProjectResUserScalarFieldEnum | ProjectResUserScalarFieldEnum[]
  }

  /**
   * ProjectResUser create
   */
  export type ProjectResUserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectResUser
     */
    select?: ProjectResUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectResUserInclude<ExtArgs> | null
    /**
     * The data needed to create a ProjectResUser.
     */
    data: XOR<ProjectResUserCreateInput, ProjectResUserUncheckedCreateInput>
  }

  /**
   * ProjectResUser createMany
   */
  export type ProjectResUserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProjectResUsers.
     */
    data: ProjectResUserCreateManyInput | ProjectResUserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProjectResUser update
   */
  export type ProjectResUserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectResUser
     */
    select?: ProjectResUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectResUserInclude<ExtArgs> | null
    /**
     * The data needed to update a ProjectResUser.
     */
    data: XOR<ProjectResUserUpdateInput, ProjectResUserUncheckedUpdateInput>
    /**
     * Choose, which ProjectResUser to update.
     */
    where: ProjectResUserWhereUniqueInput
  }

  /**
   * ProjectResUser updateMany
   */
  export type ProjectResUserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProjectResUsers.
     */
    data: XOR<ProjectResUserUpdateManyMutationInput, ProjectResUserUncheckedUpdateManyInput>
    /**
     * Filter which ProjectResUsers to update
     */
    where?: ProjectResUserWhereInput
  }

  /**
   * ProjectResUser upsert
   */
  export type ProjectResUserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectResUser
     */
    select?: ProjectResUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectResUserInclude<ExtArgs> | null
    /**
     * The filter to search for the ProjectResUser to update in case it exists.
     */
    where: ProjectResUserWhereUniqueInput
    /**
     * In case the ProjectResUser found by the `where` argument doesn't exist, create a new ProjectResUser with this data.
     */
    create: XOR<ProjectResUserCreateInput, ProjectResUserUncheckedCreateInput>
    /**
     * In case the ProjectResUser was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProjectResUserUpdateInput, ProjectResUserUncheckedUpdateInput>
  }

  /**
   * ProjectResUser delete
   */
  export type ProjectResUserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectResUser
     */
    select?: ProjectResUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectResUserInclude<ExtArgs> | null
    /**
     * Filter which ProjectResUser to delete.
     */
    where: ProjectResUserWhereUniqueInput
  }

  /**
   * ProjectResUser deleteMany
   */
  export type ProjectResUserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProjectResUsers to delete
     */
    where?: ProjectResUserWhereInput
  }

  /**
   * ProjectResUser without action
   */
  export type ProjectResUserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectResUser
     */
    select?: ProjectResUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectResUserInclude<ExtArgs> | null
  }


  /**
   * Model CompanyHour
   */

  export type AggregateCompanyHour = {
    _count: CompanyHourCountAggregateOutputType | null
    _avg: CompanyHourAvgAggregateOutputType | null
    _sum: CompanyHourSumAggregateOutputType | null
    _min: CompanyHourMinAggregateOutputType | null
    _max: CompanyHourMaxAggregateOutputType | null
  }

  export type CompanyHourAvgAggregateOutputType = {
    id: number | null
    hour: number | null
  }

  export type CompanyHourSumAggregateOutputType = {
    id: number | null
    hour: number | null
  }

  export type CompanyHourMinAggregateOutputType = {
    id: number | null
    hour: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CompanyHourMaxAggregateOutputType = {
    id: number | null
    hour: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CompanyHourCountAggregateOutputType = {
    id: number
    hour: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CompanyHourAvgAggregateInputType = {
    id?: true
    hour?: true
  }

  export type CompanyHourSumAggregateInputType = {
    id?: true
    hour?: true
  }

  export type CompanyHourMinAggregateInputType = {
    id?: true
    hour?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CompanyHourMaxAggregateInputType = {
    id?: true
    hour?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CompanyHourCountAggregateInputType = {
    id?: true
    hour?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CompanyHourAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CompanyHour to aggregate.
     */
    where?: CompanyHourWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CompanyHours to fetch.
     */
    orderBy?: CompanyHourOrderByWithRelationInput | CompanyHourOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CompanyHourWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CompanyHours from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CompanyHours.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CompanyHours
    **/
    _count?: true | CompanyHourCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CompanyHourAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CompanyHourSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CompanyHourMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CompanyHourMaxAggregateInputType
  }

  export type GetCompanyHourAggregateType<T extends CompanyHourAggregateArgs> = {
        [P in keyof T & keyof AggregateCompanyHour]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCompanyHour[P]>
      : GetScalarType<T[P], AggregateCompanyHour[P]>
  }




  export type CompanyHourGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CompanyHourWhereInput
    orderBy?: CompanyHourOrderByWithAggregationInput | CompanyHourOrderByWithAggregationInput[]
    by: CompanyHourScalarFieldEnum[] | CompanyHourScalarFieldEnum
    having?: CompanyHourScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CompanyHourCountAggregateInputType | true
    _avg?: CompanyHourAvgAggregateInputType
    _sum?: CompanyHourSumAggregateInputType
    _min?: CompanyHourMinAggregateInputType
    _max?: CompanyHourMaxAggregateInputType
  }

  export type CompanyHourGroupByOutputType = {
    id: number
    hour: number
    createdAt: Date
    updatedAt: Date
    _count: CompanyHourCountAggregateOutputType | null
    _avg: CompanyHourAvgAggregateOutputType | null
    _sum: CompanyHourSumAggregateOutputType | null
    _min: CompanyHourMinAggregateOutputType | null
    _max: CompanyHourMaxAggregateOutputType | null
  }

  type GetCompanyHourGroupByPayload<T extends CompanyHourGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CompanyHourGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CompanyHourGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CompanyHourGroupByOutputType[P]>
            : GetScalarType<T[P], CompanyHourGroupByOutputType[P]>
        }
      >
    >


  export type CompanyHourSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    hour?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["companyHour"]>


  export type CompanyHourSelectScalar = {
    id?: boolean
    hour?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type $CompanyHourPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CompanyHour"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      hour: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["companyHour"]>
    composites: {}
  }

  type CompanyHourGetPayload<S extends boolean | null | undefined | CompanyHourDefaultArgs> = $Result.GetResult<Prisma.$CompanyHourPayload, S>

  type CompanyHourCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CompanyHourFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CompanyHourCountAggregateInputType | true
    }

  export interface CompanyHourDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CompanyHour'], meta: { name: 'CompanyHour' } }
    /**
     * Find zero or one CompanyHour that matches the filter.
     * @param {CompanyHourFindUniqueArgs} args - Arguments to find a CompanyHour
     * @example
     * // Get one CompanyHour
     * const companyHour = await prisma.companyHour.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CompanyHourFindUniqueArgs>(args: SelectSubset<T, CompanyHourFindUniqueArgs<ExtArgs>>): Prisma__CompanyHourClient<$Result.GetResult<Prisma.$CompanyHourPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one CompanyHour that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CompanyHourFindUniqueOrThrowArgs} args - Arguments to find a CompanyHour
     * @example
     * // Get one CompanyHour
     * const companyHour = await prisma.companyHour.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CompanyHourFindUniqueOrThrowArgs>(args: SelectSubset<T, CompanyHourFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CompanyHourClient<$Result.GetResult<Prisma.$CompanyHourPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first CompanyHour that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyHourFindFirstArgs} args - Arguments to find a CompanyHour
     * @example
     * // Get one CompanyHour
     * const companyHour = await prisma.companyHour.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CompanyHourFindFirstArgs>(args?: SelectSubset<T, CompanyHourFindFirstArgs<ExtArgs>>): Prisma__CompanyHourClient<$Result.GetResult<Prisma.$CompanyHourPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first CompanyHour that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyHourFindFirstOrThrowArgs} args - Arguments to find a CompanyHour
     * @example
     * // Get one CompanyHour
     * const companyHour = await prisma.companyHour.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CompanyHourFindFirstOrThrowArgs>(args?: SelectSubset<T, CompanyHourFindFirstOrThrowArgs<ExtArgs>>): Prisma__CompanyHourClient<$Result.GetResult<Prisma.$CompanyHourPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more CompanyHours that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyHourFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CompanyHours
     * const companyHours = await prisma.companyHour.findMany()
     * 
     * // Get first 10 CompanyHours
     * const companyHours = await prisma.companyHour.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const companyHourWithIdOnly = await prisma.companyHour.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CompanyHourFindManyArgs>(args?: SelectSubset<T, CompanyHourFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompanyHourPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a CompanyHour.
     * @param {CompanyHourCreateArgs} args - Arguments to create a CompanyHour.
     * @example
     * // Create one CompanyHour
     * const CompanyHour = await prisma.companyHour.create({
     *   data: {
     *     // ... data to create a CompanyHour
     *   }
     * })
     * 
     */
    create<T extends CompanyHourCreateArgs>(args: SelectSubset<T, CompanyHourCreateArgs<ExtArgs>>): Prisma__CompanyHourClient<$Result.GetResult<Prisma.$CompanyHourPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many CompanyHours.
     * @param {CompanyHourCreateManyArgs} args - Arguments to create many CompanyHours.
     * @example
     * // Create many CompanyHours
     * const companyHour = await prisma.companyHour.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CompanyHourCreateManyArgs>(args?: SelectSubset<T, CompanyHourCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a CompanyHour.
     * @param {CompanyHourDeleteArgs} args - Arguments to delete one CompanyHour.
     * @example
     * // Delete one CompanyHour
     * const CompanyHour = await prisma.companyHour.delete({
     *   where: {
     *     // ... filter to delete one CompanyHour
     *   }
     * })
     * 
     */
    delete<T extends CompanyHourDeleteArgs>(args: SelectSubset<T, CompanyHourDeleteArgs<ExtArgs>>): Prisma__CompanyHourClient<$Result.GetResult<Prisma.$CompanyHourPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one CompanyHour.
     * @param {CompanyHourUpdateArgs} args - Arguments to update one CompanyHour.
     * @example
     * // Update one CompanyHour
     * const companyHour = await prisma.companyHour.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CompanyHourUpdateArgs>(args: SelectSubset<T, CompanyHourUpdateArgs<ExtArgs>>): Prisma__CompanyHourClient<$Result.GetResult<Prisma.$CompanyHourPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more CompanyHours.
     * @param {CompanyHourDeleteManyArgs} args - Arguments to filter CompanyHours to delete.
     * @example
     * // Delete a few CompanyHours
     * const { count } = await prisma.companyHour.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CompanyHourDeleteManyArgs>(args?: SelectSubset<T, CompanyHourDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CompanyHours.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyHourUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CompanyHours
     * const companyHour = await prisma.companyHour.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CompanyHourUpdateManyArgs>(args: SelectSubset<T, CompanyHourUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CompanyHour.
     * @param {CompanyHourUpsertArgs} args - Arguments to update or create a CompanyHour.
     * @example
     * // Update or create a CompanyHour
     * const companyHour = await prisma.companyHour.upsert({
     *   create: {
     *     // ... data to create a CompanyHour
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CompanyHour we want to update
     *   }
     * })
     */
    upsert<T extends CompanyHourUpsertArgs>(args: SelectSubset<T, CompanyHourUpsertArgs<ExtArgs>>): Prisma__CompanyHourClient<$Result.GetResult<Prisma.$CompanyHourPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of CompanyHours.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyHourCountArgs} args - Arguments to filter CompanyHours to count.
     * @example
     * // Count the number of CompanyHours
     * const count = await prisma.companyHour.count({
     *   where: {
     *     // ... the filter for the CompanyHours we want to count
     *   }
     * })
    **/
    count<T extends CompanyHourCountArgs>(
      args?: Subset<T, CompanyHourCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CompanyHourCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CompanyHour.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyHourAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CompanyHourAggregateArgs>(args: Subset<T, CompanyHourAggregateArgs>): Prisma.PrismaPromise<GetCompanyHourAggregateType<T>>

    /**
     * Group by CompanyHour.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyHourGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CompanyHourGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CompanyHourGroupByArgs['orderBy'] }
        : { orderBy?: CompanyHourGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CompanyHourGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCompanyHourGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CompanyHour model
   */
  readonly fields: CompanyHourFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CompanyHour.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CompanyHourClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CompanyHour model
   */ 
  interface CompanyHourFieldRefs {
    readonly id: FieldRef<"CompanyHour", 'Int'>
    readonly hour: FieldRef<"CompanyHour", 'Int'>
    readonly createdAt: FieldRef<"CompanyHour", 'DateTime'>
    readonly updatedAt: FieldRef<"CompanyHour", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CompanyHour findUnique
   */
  export type CompanyHourFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyHour
     */
    select?: CompanyHourSelect<ExtArgs> | null
    /**
     * Filter, which CompanyHour to fetch.
     */
    where: CompanyHourWhereUniqueInput
  }

  /**
   * CompanyHour findUniqueOrThrow
   */
  export type CompanyHourFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyHour
     */
    select?: CompanyHourSelect<ExtArgs> | null
    /**
     * Filter, which CompanyHour to fetch.
     */
    where: CompanyHourWhereUniqueInput
  }

  /**
   * CompanyHour findFirst
   */
  export type CompanyHourFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyHour
     */
    select?: CompanyHourSelect<ExtArgs> | null
    /**
     * Filter, which CompanyHour to fetch.
     */
    where?: CompanyHourWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CompanyHours to fetch.
     */
    orderBy?: CompanyHourOrderByWithRelationInput | CompanyHourOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CompanyHours.
     */
    cursor?: CompanyHourWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CompanyHours from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CompanyHours.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CompanyHours.
     */
    distinct?: CompanyHourScalarFieldEnum | CompanyHourScalarFieldEnum[]
  }

  /**
   * CompanyHour findFirstOrThrow
   */
  export type CompanyHourFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyHour
     */
    select?: CompanyHourSelect<ExtArgs> | null
    /**
     * Filter, which CompanyHour to fetch.
     */
    where?: CompanyHourWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CompanyHours to fetch.
     */
    orderBy?: CompanyHourOrderByWithRelationInput | CompanyHourOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CompanyHours.
     */
    cursor?: CompanyHourWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CompanyHours from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CompanyHours.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CompanyHours.
     */
    distinct?: CompanyHourScalarFieldEnum | CompanyHourScalarFieldEnum[]
  }

  /**
   * CompanyHour findMany
   */
  export type CompanyHourFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyHour
     */
    select?: CompanyHourSelect<ExtArgs> | null
    /**
     * Filter, which CompanyHours to fetch.
     */
    where?: CompanyHourWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CompanyHours to fetch.
     */
    orderBy?: CompanyHourOrderByWithRelationInput | CompanyHourOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CompanyHours.
     */
    cursor?: CompanyHourWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CompanyHours from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CompanyHours.
     */
    skip?: number
    distinct?: CompanyHourScalarFieldEnum | CompanyHourScalarFieldEnum[]
  }

  /**
   * CompanyHour create
   */
  export type CompanyHourCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyHour
     */
    select?: CompanyHourSelect<ExtArgs> | null
    /**
     * The data needed to create a CompanyHour.
     */
    data: XOR<CompanyHourCreateInput, CompanyHourUncheckedCreateInput>
  }

  /**
   * CompanyHour createMany
   */
  export type CompanyHourCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CompanyHours.
     */
    data: CompanyHourCreateManyInput | CompanyHourCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CompanyHour update
   */
  export type CompanyHourUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyHour
     */
    select?: CompanyHourSelect<ExtArgs> | null
    /**
     * The data needed to update a CompanyHour.
     */
    data: XOR<CompanyHourUpdateInput, CompanyHourUncheckedUpdateInput>
    /**
     * Choose, which CompanyHour to update.
     */
    where: CompanyHourWhereUniqueInput
  }

  /**
   * CompanyHour updateMany
   */
  export type CompanyHourUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CompanyHours.
     */
    data: XOR<CompanyHourUpdateManyMutationInput, CompanyHourUncheckedUpdateManyInput>
    /**
     * Filter which CompanyHours to update
     */
    where?: CompanyHourWhereInput
  }

  /**
   * CompanyHour upsert
   */
  export type CompanyHourUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyHour
     */
    select?: CompanyHourSelect<ExtArgs> | null
    /**
     * The filter to search for the CompanyHour to update in case it exists.
     */
    where: CompanyHourWhereUniqueInput
    /**
     * In case the CompanyHour found by the `where` argument doesn't exist, create a new CompanyHour with this data.
     */
    create: XOR<CompanyHourCreateInput, CompanyHourUncheckedCreateInput>
    /**
     * In case the CompanyHour was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CompanyHourUpdateInput, CompanyHourUncheckedUpdateInput>
  }

  /**
   * CompanyHour delete
   */
  export type CompanyHourDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyHour
     */
    select?: CompanyHourSelect<ExtArgs> | null
    /**
     * Filter which CompanyHour to delete.
     */
    where: CompanyHourWhereUniqueInput
  }

  /**
   * CompanyHour deleteMany
   */
  export type CompanyHourDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CompanyHours to delete
     */
    where?: CompanyHourWhereInput
  }

  /**
   * CompanyHour without action
   */
  export type CompanyHourDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyHour
     */
    select?: CompanyHourSelect<ExtArgs> | null
  }


  /**
   * Model Stock
   */

  export type AggregateStock = {
    _count: StockCountAggregateOutputType | null
    _avg: StockAvgAggregateOutputType | null
    _sum: StockSumAggregateOutputType | null
    _min: StockMinAggregateOutputType | null
    _max: StockMaxAggregateOutputType | null
  }

  export type StockAvgAggregateOutputType = {
    id: number | null
    stockQuantity: number | null
    stockTypeId: number | null
  }

  export type StockSumAggregateOutputType = {
    id: number | null
    stockQuantity: number | null
    stockTypeId: number | null
  }

  export type StockMinAggregateOutputType = {
    id: number | null
    stockId: string | null
    stockName: string | null
    stockQuantity: number | null
    stockType: string | null
    stockTypeId: number | null
    stockImage: string | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type StockMaxAggregateOutputType = {
    id: number | null
    stockId: string | null
    stockName: string | null
    stockQuantity: number | null
    stockType: string | null
    stockTypeId: number | null
    stockImage: string | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type StockCountAggregateOutputType = {
    id: number
    stockId: number
    stockName: number
    stockQuantity: number
    stockType: number
    stockTypeId: number
    stockImage: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    _all: number
  }


  export type StockAvgAggregateInputType = {
    id?: true
    stockQuantity?: true
    stockTypeId?: true
  }

  export type StockSumAggregateInputType = {
    id?: true
    stockQuantity?: true
    stockTypeId?: true
  }

  export type StockMinAggregateInputType = {
    id?: true
    stockId?: true
    stockName?: true
    stockQuantity?: true
    stockType?: true
    stockTypeId?: true
    stockImage?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type StockMaxAggregateInputType = {
    id?: true
    stockId?: true
    stockName?: true
    stockQuantity?: true
    stockType?: true
    stockTypeId?: true
    stockImage?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type StockCountAggregateInputType = {
    id?: true
    stockId?: true
    stockName?: true
    stockQuantity?: true
    stockType?: true
    stockTypeId?: true
    stockImage?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    _all?: true
  }

  export type StockAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Stock to aggregate.
     */
    where?: StockWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Stocks to fetch.
     */
    orderBy?: StockOrderByWithRelationInput | StockOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StockWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Stocks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Stocks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Stocks
    **/
    _count?: true | StockCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StockAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StockSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StockMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StockMaxAggregateInputType
  }

  export type GetStockAggregateType<T extends StockAggregateArgs> = {
        [P in keyof T & keyof AggregateStock]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStock[P]>
      : GetScalarType<T[P], AggregateStock[P]>
  }




  export type StockGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StockWhereInput
    orderBy?: StockOrderByWithAggregationInput | StockOrderByWithAggregationInput[]
    by: StockScalarFieldEnum[] | StockScalarFieldEnum
    having?: StockScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StockCountAggregateInputType | true
    _avg?: StockAvgAggregateInputType
    _sum?: StockSumAggregateInputType
    _min?: StockMinAggregateInputType
    _max?: StockMaxAggregateInputType
  }

  export type StockGroupByOutputType = {
    id: number
    stockId: string
    stockName: string
    stockQuantity: number
    stockType: string
    stockTypeId: number
    stockImage: string | null
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
    _count: StockCountAggregateOutputType | null
    _avg: StockAvgAggregateOutputType | null
    _sum: StockSumAggregateOutputType | null
    _min: StockMinAggregateOutputType | null
    _max: StockMaxAggregateOutputType | null
  }

  type GetStockGroupByPayload<T extends StockGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StockGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StockGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StockGroupByOutputType[P]>
            : GetScalarType<T[P], StockGroupByOutputType[P]>
        }
      >
    >


  export type StockSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    stockId?: boolean
    stockName?: boolean
    stockQuantity?: boolean
    stockType?: boolean
    stockTypeId?: boolean
    stockImage?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    processMat?: boolean | Stock$processMatArgs<ExtArgs>
    processBom?: boolean | Stock$processBomArgs<ExtArgs>
    projectMat?: boolean | Stock$projectMatArgs<ExtArgs>
    projectBom?: boolean | Stock$projectBomArgs<ExtArgs>
    _count?: boolean | StockCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["stock"]>


  export type StockSelectScalar = {
    id?: boolean
    stockId?: boolean
    stockName?: boolean
    stockQuantity?: boolean
    stockType?: boolean
    stockTypeId?: boolean
    stockImage?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }

  export type StockInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    processMat?: boolean | Stock$processMatArgs<ExtArgs>
    processBom?: boolean | Stock$processBomArgs<ExtArgs>
    projectMat?: boolean | Stock$projectMatArgs<ExtArgs>
    projectBom?: boolean | Stock$projectBomArgs<ExtArgs>
    _count?: boolean | StockCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $StockPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Stock"
    objects: {
      processMat: Prisma.$ProcessMatPayload<ExtArgs>[]
      processBom: Prisma.$ProcessBomPayload<ExtArgs>[]
      projectMat: Prisma.$ProjectMatPayload<ExtArgs>[]
      projectBom: Prisma.$ProjectBomPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      stockId: string
      stockName: string
      stockQuantity: number
      stockType: string
      stockTypeId: number
      stockImage: string | null
      createdAt: Date
      updatedAt: Date
      deletedAt: Date | null
    }, ExtArgs["result"]["stock"]>
    composites: {}
  }

  type StockGetPayload<S extends boolean | null | undefined | StockDefaultArgs> = $Result.GetResult<Prisma.$StockPayload, S>

  type StockCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<StockFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: StockCountAggregateInputType | true
    }

  export interface StockDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Stock'], meta: { name: 'Stock' } }
    /**
     * Find zero or one Stock that matches the filter.
     * @param {StockFindUniqueArgs} args - Arguments to find a Stock
     * @example
     * // Get one Stock
     * const stock = await prisma.stock.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StockFindUniqueArgs>(args: SelectSubset<T, StockFindUniqueArgs<ExtArgs>>): Prisma__StockClient<$Result.GetResult<Prisma.$StockPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Stock that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {StockFindUniqueOrThrowArgs} args - Arguments to find a Stock
     * @example
     * // Get one Stock
     * const stock = await prisma.stock.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StockFindUniqueOrThrowArgs>(args: SelectSubset<T, StockFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StockClient<$Result.GetResult<Prisma.$StockPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Stock that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockFindFirstArgs} args - Arguments to find a Stock
     * @example
     * // Get one Stock
     * const stock = await prisma.stock.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StockFindFirstArgs>(args?: SelectSubset<T, StockFindFirstArgs<ExtArgs>>): Prisma__StockClient<$Result.GetResult<Prisma.$StockPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Stock that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockFindFirstOrThrowArgs} args - Arguments to find a Stock
     * @example
     * // Get one Stock
     * const stock = await prisma.stock.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StockFindFirstOrThrowArgs>(args?: SelectSubset<T, StockFindFirstOrThrowArgs<ExtArgs>>): Prisma__StockClient<$Result.GetResult<Prisma.$StockPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Stocks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Stocks
     * const stocks = await prisma.stock.findMany()
     * 
     * // Get first 10 Stocks
     * const stocks = await prisma.stock.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const stockWithIdOnly = await prisma.stock.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StockFindManyArgs>(args?: SelectSubset<T, StockFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StockPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Stock.
     * @param {StockCreateArgs} args - Arguments to create a Stock.
     * @example
     * // Create one Stock
     * const Stock = await prisma.stock.create({
     *   data: {
     *     // ... data to create a Stock
     *   }
     * })
     * 
     */
    create<T extends StockCreateArgs>(args: SelectSubset<T, StockCreateArgs<ExtArgs>>): Prisma__StockClient<$Result.GetResult<Prisma.$StockPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Stocks.
     * @param {StockCreateManyArgs} args - Arguments to create many Stocks.
     * @example
     * // Create many Stocks
     * const stock = await prisma.stock.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StockCreateManyArgs>(args?: SelectSubset<T, StockCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Stock.
     * @param {StockDeleteArgs} args - Arguments to delete one Stock.
     * @example
     * // Delete one Stock
     * const Stock = await prisma.stock.delete({
     *   where: {
     *     // ... filter to delete one Stock
     *   }
     * })
     * 
     */
    delete<T extends StockDeleteArgs>(args: SelectSubset<T, StockDeleteArgs<ExtArgs>>): Prisma__StockClient<$Result.GetResult<Prisma.$StockPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Stock.
     * @param {StockUpdateArgs} args - Arguments to update one Stock.
     * @example
     * // Update one Stock
     * const stock = await prisma.stock.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StockUpdateArgs>(args: SelectSubset<T, StockUpdateArgs<ExtArgs>>): Prisma__StockClient<$Result.GetResult<Prisma.$StockPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Stocks.
     * @param {StockDeleteManyArgs} args - Arguments to filter Stocks to delete.
     * @example
     * // Delete a few Stocks
     * const { count } = await prisma.stock.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StockDeleteManyArgs>(args?: SelectSubset<T, StockDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Stocks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Stocks
     * const stock = await prisma.stock.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StockUpdateManyArgs>(args: SelectSubset<T, StockUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Stock.
     * @param {StockUpsertArgs} args - Arguments to update or create a Stock.
     * @example
     * // Update or create a Stock
     * const stock = await prisma.stock.upsert({
     *   create: {
     *     // ... data to create a Stock
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Stock we want to update
     *   }
     * })
     */
    upsert<T extends StockUpsertArgs>(args: SelectSubset<T, StockUpsertArgs<ExtArgs>>): Prisma__StockClient<$Result.GetResult<Prisma.$StockPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Stocks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockCountArgs} args - Arguments to filter Stocks to count.
     * @example
     * // Count the number of Stocks
     * const count = await prisma.stock.count({
     *   where: {
     *     // ... the filter for the Stocks we want to count
     *   }
     * })
    **/
    count<T extends StockCountArgs>(
      args?: Subset<T, StockCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StockCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Stock.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StockAggregateArgs>(args: Subset<T, StockAggregateArgs>): Prisma.PrismaPromise<GetStockAggregateType<T>>

    /**
     * Group by Stock.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StockGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StockGroupByArgs['orderBy'] }
        : { orderBy?: StockGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StockGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStockGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Stock model
   */
  readonly fields: StockFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Stock.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StockClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    processMat<T extends Stock$processMatArgs<ExtArgs> = {}>(args?: Subset<T, Stock$processMatArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProcessMatPayload<ExtArgs>, T, "findMany"> | Null>
    processBom<T extends Stock$processBomArgs<ExtArgs> = {}>(args?: Subset<T, Stock$processBomArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProcessBomPayload<ExtArgs>, T, "findMany"> | Null>
    projectMat<T extends Stock$projectMatArgs<ExtArgs> = {}>(args?: Subset<T, Stock$projectMatArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectMatPayload<ExtArgs>, T, "findMany"> | Null>
    projectBom<T extends Stock$projectBomArgs<ExtArgs> = {}>(args?: Subset<T, Stock$projectBomArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectBomPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Stock model
   */ 
  interface StockFieldRefs {
    readonly id: FieldRef<"Stock", 'Int'>
    readonly stockId: FieldRef<"Stock", 'String'>
    readonly stockName: FieldRef<"Stock", 'String'>
    readonly stockQuantity: FieldRef<"Stock", 'Int'>
    readonly stockType: FieldRef<"Stock", 'String'>
    readonly stockTypeId: FieldRef<"Stock", 'Int'>
    readonly stockImage: FieldRef<"Stock", 'String'>
    readonly createdAt: FieldRef<"Stock", 'DateTime'>
    readonly updatedAt: FieldRef<"Stock", 'DateTime'>
    readonly deletedAt: FieldRef<"Stock", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Stock findUnique
   */
  export type StockFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stock
     */
    select?: StockSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockInclude<ExtArgs> | null
    /**
     * Filter, which Stock to fetch.
     */
    where: StockWhereUniqueInput
  }

  /**
   * Stock findUniqueOrThrow
   */
  export type StockFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stock
     */
    select?: StockSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockInclude<ExtArgs> | null
    /**
     * Filter, which Stock to fetch.
     */
    where: StockWhereUniqueInput
  }

  /**
   * Stock findFirst
   */
  export type StockFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stock
     */
    select?: StockSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockInclude<ExtArgs> | null
    /**
     * Filter, which Stock to fetch.
     */
    where?: StockWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Stocks to fetch.
     */
    orderBy?: StockOrderByWithRelationInput | StockOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Stocks.
     */
    cursor?: StockWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Stocks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Stocks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Stocks.
     */
    distinct?: StockScalarFieldEnum | StockScalarFieldEnum[]
  }

  /**
   * Stock findFirstOrThrow
   */
  export type StockFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stock
     */
    select?: StockSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockInclude<ExtArgs> | null
    /**
     * Filter, which Stock to fetch.
     */
    where?: StockWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Stocks to fetch.
     */
    orderBy?: StockOrderByWithRelationInput | StockOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Stocks.
     */
    cursor?: StockWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Stocks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Stocks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Stocks.
     */
    distinct?: StockScalarFieldEnum | StockScalarFieldEnum[]
  }

  /**
   * Stock findMany
   */
  export type StockFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stock
     */
    select?: StockSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockInclude<ExtArgs> | null
    /**
     * Filter, which Stocks to fetch.
     */
    where?: StockWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Stocks to fetch.
     */
    orderBy?: StockOrderByWithRelationInput | StockOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Stocks.
     */
    cursor?: StockWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Stocks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Stocks.
     */
    skip?: number
    distinct?: StockScalarFieldEnum | StockScalarFieldEnum[]
  }

  /**
   * Stock create
   */
  export type StockCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stock
     */
    select?: StockSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockInclude<ExtArgs> | null
    /**
     * The data needed to create a Stock.
     */
    data: XOR<StockCreateInput, StockUncheckedCreateInput>
  }

  /**
   * Stock createMany
   */
  export type StockCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Stocks.
     */
    data: StockCreateManyInput | StockCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Stock update
   */
  export type StockUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stock
     */
    select?: StockSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockInclude<ExtArgs> | null
    /**
     * The data needed to update a Stock.
     */
    data: XOR<StockUpdateInput, StockUncheckedUpdateInput>
    /**
     * Choose, which Stock to update.
     */
    where: StockWhereUniqueInput
  }

  /**
   * Stock updateMany
   */
  export type StockUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Stocks.
     */
    data: XOR<StockUpdateManyMutationInput, StockUncheckedUpdateManyInput>
    /**
     * Filter which Stocks to update
     */
    where?: StockWhereInput
  }

  /**
   * Stock upsert
   */
  export type StockUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stock
     */
    select?: StockSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockInclude<ExtArgs> | null
    /**
     * The filter to search for the Stock to update in case it exists.
     */
    where: StockWhereUniqueInput
    /**
     * In case the Stock found by the `where` argument doesn't exist, create a new Stock with this data.
     */
    create: XOR<StockCreateInput, StockUncheckedCreateInput>
    /**
     * In case the Stock was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StockUpdateInput, StockUncheckedUpdateInput>
  }

  /**
   * Stock delete
   */
  export type StockDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stock
     */
    select?: StockSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockInclude<ExtArgs> | null
    /**
     * Filter which Stock to delete.
     */
    where: StockWhereUniqueInput
  }

  /**
   * Stock deleteMany
   */
  export type StockDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Stocks to delete
     */
    where?: StockWhereInput
  }

  /**
   * Stock.processMat
   */
  export type Stock$processMatArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcessMat
     */
    select?: ProcessMatSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessMatInclude<ExtArgs> | null
    where?: ProcessMatWhereInput
    orderBy?: ProcessMatOrderByWithRelationInput | ProcessMatOrderByWithRelationInput[]
    cursor?: ProcessMatWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProcessMatScalarFieldEnum | ProcessMatScalarFieldEnum[]
  }

  /**
   * Stock.processBom
   */
  export type Stock$processBomArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcessBom
     */
    select?: ProcessBomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessBomInclude<ExtArgs> | null
    where?: ProcessBomWhereInput
    orderBy?: ProcessBomOrderByWithRelationInput | ProcessBomOrderByWithRelationInput[]
    cursor?: ProcessBomWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProcessBomScalarFieldEnum | ProcessBomScalarFieldEnum[]
  }

  /**
   * Stock.projectMat
   */
  export type Stock$projectMatArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectMat
     */
    select?: ProjectMatSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectMatInclude<ExtArgs> | null
    where?: ProjectMatWhereInput
    orderBy?: ProjectMatOrderByWithRelationInput | ProjectMatOrderByWithRelationInput[]
    cursor?: ProjectMatWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProjectMatScalarFieldEnum | ProjectMatScalarFieldEnum[]
  }

  /**
   * Stock.projectBom
   */
  export type Stock$projectBomArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectBom
     */
    select?: ProjectBomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectBomInclude<ExtArgs> | null
    where?: ProjectBomWhereInput
    orderBy?: ProjectBomOrderByWithRelationInput | ProjectBomOrderByWithRelationInput[]
    cursor?: ProjectBomWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProjectBomScalarFieldEnum | ProjectBomScalarFieldEnum[]
  }

  /**
   * Stock without action
   */
  export type StockDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stock
     */
    select?: StockSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockInclude<ExtArgs> | null
  }


  /**
   * Model ReasonStockNG
   */

  export type AggregateReasonStockNG = {
    _count: ReasonStockNGCountAggregateOutputType | null
    _avg: ReasonStockNGAvgAggregateOutputType | null
    _sum: ReasonStockNGSumAggregateOutputType | null
    _min: ReasonStockNGMinAggregateOutputType | null
    _max: ReasonStockNGMaxAggregateOutputType | null
  }

  export type ReasonStockNGAvgAggregateOutputType = {
    id: number | null
  }

  export type ReasonStockNGSumAggregateOutputType = {
    id: number | null
  }

  export type ReasonStockNGMinAggregateOutputType = {
    id: number | null
    reasonstockName: string | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type ReasonStockNGMaxAggregateOutputType = {
    id: number | null
    reasonstockName: string | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type ReasonStockNGCountAggregateOutputType = {
    id: number
    reasonstockName: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    _all: number
  }


  export type ReasonStockNGAvgAggregateInputType = {
    id?: true
  }

  export type ReasonStockNGSumAggregateInputType = {
    id?: true
  }

  export type ReasonStockNGMinAggregateInputType = {
    id?: true
    reasonstockName?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type ReasonStockNGMaxAggregateInputType = {
    id?: true
    reasonstockName?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type ReasonStockNGCountAggregateInputType = {
    id?: true
    reasonstockName?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    _all?: true
  }

  export type ReasonStockNGAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ReasonStockNG to aggregate.
     */
    where?: ReasonStockNGWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReasonStockNGS to fetch.
     */
    orderBy?: ReasonStockNGOrderByWithRelationInput | ReasonStockNGOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ReasonStockNGWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReasonStockNGS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReasonStockNGS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ReasonStockNGS
    **/
    _count?: true | ReasonStockNGCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ReasonStockNGAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ReasonStockNGSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReasonStockNGMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReasonStockNGMaxAggregateInputType
  }

  export type GetReasonStockNGAggregateType<T extends ReasonStockNGAggregateArgs> = {
        [P in keyof T & keyof AggregateReasonStockNG]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReasonStockNG[P]>
      : GetScalarType<T[P], AggregateReasonStockNG[P]>
  }




  export type ReasonStockNGGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReasonStockNGWhereInput
    orderBy?: ReasonStockNGOrderByWithAggregationInput | ReasonStockNGOrderByWithAggregationInput[]
    by: ReasonStockNGScalarFieldEnum[] | ReasonStockNGScalarFieldEnum
    having?: ReasonStockNGScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReasonStockNGCountAggregateInputType | true
    _avg?: ReasonStockNGAvgAggregateInputType
    _sum?: ReasonStockNGSumAggregateInputType
    _min?: ReasonStockNGMinAggregateInputType
    _max?: ReasonStockNGMaxAggregateInputType
  }

  export type ReasonStockNGGroupByOutputType = {
    id: number
    reasonstockName: string
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
    _count: ReasonStockNGCountAggregateOutputType | null
    _avg: ReasonStockNGAvgAggregateOutputType | null
    _sum: ReasonStockNGSumAggregateOutputType | null
    _min: ReasonStockNGMinAggregateOutputType | null
    _max: ReasonStockNGMaxAggregateOutputType | null
  }

  type GetReasonStockNGGroupByPayload<T extends ReasonStockNGGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReasonStockNGGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReasonStockNGGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReasonStockNGGroupByOutputType[P]>
            : GetScalarType<T[P], ReasonStockNGGroupByOutputType[P]>
        }
      >
    >


  export type ReasonStockNGSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    reasonstockName?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }, ExtArgs["result"]["reasonStockNG"]>


  export type ReasonStockNGSelectScalar = {
    id?: boolean
    reasonstockName?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }


  export type $ReasonStockNGPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ReasonStockNG"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      reasonstockName: string
      createdAt: Date
      updatedAt: Date
      deletedAt: Date | null
    }, ExtArgs["result"]["reasonStockNG"]>
    composites: {}
  }

  type ReasonStockNGGetPayload<S extends boolean | null | undefined | ReasonStockNGDefaultArgs> = $Result.GetResult<Prisma.$ReasonStockNGPayload, S>

  type ReasonStockNGCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ReasonStockNGFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ReasonStockNGCountAggregateInputType | true
    }

  export interface ReasonStockNGDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ReasonStockNG'], meta: { name: 'ReasonStockNG' } }
    /**
     * Find zero or one ReasonStockNG that matches the filter.
     * @param {ReasonStockNGFindUniqueArgs} args - Arguments to find a ReasonStockNG
     * @example
     * // Get one ReasonStockNG
     * const reasonStockNG = await prisma.reasonStockNG.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ReasonStockNGFindUniqueArgs>(args: SelectSubset<T, ReasonStockNGFindUniqueArgs<ExtArgs>>): Prisma__ReasonStockNGClient<$Result.GetResult<Prisma.$ReasonStockNGPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ReasonStockNG that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ReasonStockNGFindUniqueOrThrowArgs} args - Arguments to find a ReasonStockNG
     * @example
     * // Get one ReasonStockNG
     * const reasonStockNG = await prisma.reasonStockNG.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ReasonStockNGFindUniqueOrThrowArgs>(args: SelectSubset<T, ReasonStockNGFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ReasonStockNGClient<$Result.GetResult<Prisma.$ReasonStockNGPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ReasonStockNG that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReasonStockNGFindFirstArgs} args - Arguments to find a ReasonStockNG
     * @example
     * // Get one ReasonStockNG
     * const reasonStockNG = await prisma.reasonStockNG.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ReasonStockNGFindFirstArgs>(args?: SelectSubset<T, ReasonStockNGFindFirstArgs<ExtArgs>>): Prisma__ReasonStockNGClient<$Result.GetResult<Prisma.$ReasonStockNGPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ReasonStockNG that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReasonStockNGFindFirstOrThrowArgs} args - Arguments to find a ReasonStockNG
     * @example
     * // Get one ReasonStockNG
     * const reasonStockNG = await prisma.reasonStockNG.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ReasonStockNGFindFirstOrThrowArgs>(args?: SelectSubset<T, ReasonStockNGFindFirstOrThrowArgs<ExtArgs>>): Prisma__ReasonStockNGClient<$Result.GetResult<Prisma.$ReasonStockNGPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ReasonStockNGS that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReasonStockNGFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ReasonStockNGS
     * const reasonStockNGS = await prisma.reasonStockNG.findMany()
     * 
     * // Get first 10 ReasonStockNGS
     * const reasonStockNGS = await prisma.reasonStockNG.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const reasonStockNGWithIdOnly = await prisma.reasonStockNG.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ReasonStockNGFindManyArgs>(args?: SelectSubset<T, ReasonStockNGFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReasonStockNGPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ReasonStockNG.
     * @param {ReasonStockNGCreateArgs} args - Arguments to create a ReasonStockNG.
     * @example
     * // Create one ReasonStockNG
     * const ReasonStockNG = await prisma.reasonStockNG.create({
     *   data: {
     *     // ... data to create a ReasonStockNG
     *   }
     * })
     * 
     */
    create<T extends ReasonStockNGCreateArgs>(args: SelectSubset<T, ReasonStockNGCreateArgs<ExtArgs>>): Prisma__ReasonStockNGClient<$Result.GetResult<Prisma.$ReasonStockNGPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ReasonStockNGS.
     * @param {ReasonStockNGCreateManyArgs} args - Arguments to create many ReasonStockNGS.
     * @example
     * // Create many ReasonStockNGS
     * const reasonStockNG = await prisma.reasonStockNG.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ReasonStockNGCreateManyArgs>(args?: SelectSubset<T, ReasonStockNGCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ReasonStockNG.
     * @param {ReasonStockNGDeleteArgs} args - Arguments to delete one ReasonStockNG.
     * @example
     * // Delete one ReasonStockNG
     * const ReasonStockNG = await prisma.reasonStockNG.delete({
     *   where: {
     *     // ... filter to delete one ReasonStockNG
     *   }
     * })
     * 
     */
    delete<T extends ReasonStockNGDeleteArgs>(args: SelectSubset<T, ReasonStockNGDeleteArgs<ExtArgs>>): Prisma__ReasonStockNGClient<$Result.GetResult<Prisma.$ReasonStockNGPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ReasonStockNG.
     * @param {ReasonStockNGUpdateArgs} args - Arguments to update one ReasonStockNG.
     * @example
     * // Update one ReasonStockNG
     * const reasonStockNG = await prisma.reasonStockNG.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ReasonStockNGUpdateArgs>(args: SelectSubset<T, ReasonStockNGUpdateArgs<ExtArgs>>): Prisma__ReasonStockNGClient<$Result.GetResult<Prisma.$ReasonStockNGPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ReasonStockNGS.
     * @param {ReasonStockNGDeleteManyArgs} args - Arguments to filter ReasonStockNGS to delete.
     * @example
     * // Delete a few ReasonStockNGS
     * const { count } = await prisma.reasonStockNG.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ReasonStockNGDeleteManyArgs>(args?: SelectSubset<T, ReasonStockNGDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ReasonStockNGS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReasonStockNGUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ReasonStockNGS
     * const reasonStockNG = await prisma.reasonStockNG.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ReasonStockNGUpdateManyArgs>(args: SelectSubset<T, ReasonStockNGUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ReasonStockNG.
     * @param {ReasonStockNGUpsertArgs} args - Arguments to update or create a ReasonStockNG.
     * @example
     * // Update or create a ReasonStockNG
     * const reasonStockNG = await prisma.reasonStockNG.upsert({
     *   create: {
     *     // ... data to create a ReasonStockNG
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ReasonStockNG we want to update
     *   }
     * })
     */
    upsert<T extends ReasonStockNGUpsertArgs>(args: SelectSubset<T, ReasonStockNGUpsertArgs<ExtArgs>>): Prisma__ReasonStockNGClient<$Result.GetResult<Prisma.$ReasonStockNGPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ReasonStockNGS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReasonStockNGCountArgs} args - Arguments to filter ReasonStockNGS to count.
     * @example
     * // Count the number of ReasonStockNGS
     * const count = await prisma.reasonStockNG.count({
     *   where: {
     *     // ... the filter for the ReasonStockNGS we want to count
     *   }
     * })
    **/
    count<T extends ReasonStockNGCountArgs>(
      args?: Subset<T, ReasonStockNGCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReasonStockNGCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ReasonStockNG.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReasonStockNGAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReasonStockNGAggregateArgs>(args: Subset<T, ReasonStockNGAggregateArgs>): Prisma.PrismaPromise<GetReasonStockNGAggregateType<T>>

    /**
     * Group by ReasonStockNG.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReasonStockNGGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReasonStockNGGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReasonStockNGGroupByArgs['orderBy'] }
        : { orderBy?: ReasonStockNGGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReasonStockNGGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReasonStockNGGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ReasonStockNG model
   */
  readonly fields: ReasonStockNGFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ReasonStockNG.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ReasonStockNGClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ReasonStockNG model
   */ 
  interface ReasonStockNGFieldRefs {
    readonly id: FieldRef<"ReasonStockNG", 'Int'>
    readonly reasonstockName: FieldRef<"ReasonStockNG", 'String'>
    readonly createdAt: FieldRef<"ReasonStockNG", 'DateTime'>
    readonly updatedAt: FieldRef<"ReasonStockNG", 'DateTime'>
    readonly deletedAt: FieldRef<"ReasonStockNG", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ReasonStockNG findUnique
   */
  export type ReasonStockNGFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReasonStockNG
     */
    select?: ReasonStockNGSelect<ExtArgs> | null
    /**
     * Filter, which ReasonStockNG to fetch.
     */
    where: ReasonStockNGWhereUniqueInput
  }

  /**
   * ReasonStockNG findUniqueOrThrow
   */
  export type ReasonStockNGFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReasonStockNG
     */
    select?: ReasonStockNGSelect<ExtArgs> | null
    /**
     * Filter, which ReasonStockNG to fetch.
     */
    where: ReasonStockNGWhereUniqueInput
  }

  /**
   * ReasonStockNG findFirst
   */
  export type ReasonStockNGFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReasonStockNG
     */
    select?: ReasonStockNGSelect<ExtArgs> | null
    /**
     * Filter, which ReasonStockNG to fetch.
     */
    where?: ReasonStockNGWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReasonStockNGS to fetch.
     */
    orderBy?: ReasonStockNGOrderByWithRelationInput | ReasonStockNGOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ReasonStockNGS.
     */
    cursor?: ReasonStockNGWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReasonStockNGS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReasonStockNGS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ReasonStockNGS.
     */
    distinct?: ReasonStockNGScalarFieldEnum | ReasonStockNGScalarFieldEnum[]
  }

  /**
   * ReasonStockNG findFirstOrThrow
   */
  export type ReasonStockNGFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReasonStockNG
     */
    select?: ReasonStockNGSelect<ExtArgs> | null
    /**
     * Filter, which ReasonStockNG to fetch.
     */
    where?: ReasonStockNGWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReasonStockNGS to fetch.
     */
    orderBy?: ReasonStockNGOrderByWithRelationInput | ReasonStockNGOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ReasonStockNGS.
     */
    cursor?: ReasonStockNGWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReasonStockNGS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReasonStockNGS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ReasonStockNGS.
     */
    distinct?: ReasonStockNGScalarFieldEnum | ReasonStockNGScalarFieldEnum[]
  }

  /**
   * ReasonStockNG findMany
   */
  export type ReasonStockNGFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReasonStockNG
     */
    select?: ReasonStockNGSelect<ExtArgs> | null
    /**
     * Filter, which ReasonStockNGS to fetch.
     */
    where?: ReasonStockNGWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReasonStockNGS to fetch.
     */
    orderBy?: ReasonStockNGOrderByWithRelationInput | ReasonStockNGOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ReasonStockNGS.
     */
    cursor?: ReasonStockNGWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReasonStockNGS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReasonStockNGS.
     */
    skip?: number
    distinct?: ReasonStockNGScalarFieldEnum | ReasonStockNGScalarFieldEnum[]
  }

  /**
   * ReasonStockNG create
   */
  export type ReasonStockNGCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReasonStockNG
     */
    select?: ReasonStockNGSelect<ExtArgs> | null
    /**
     * The data needed to create a ReasonStockNG.
     */
    data: XOR<ReasonStockNGCreateInput, ReasonStockNGUncheckedCreateInput>
  }

  /**
   * ReasonStockNG createMany
   */
  export type ReasonStockNGCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ReasonStockNGS.
     */
    data: ReasonStockNGCreateManyInput | ReasonStockNGCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ReasonStockNG update
   */
  export type ReasonStockNGUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReasonStockNG
     */
    select?: ReasonStockNGSelect<ExtArgs> | null
    /**
     * The data needed to update a ReasonStockNG.
     */
    data: XOR<ReasonStockNGUpdateInput, ReasonStockNGUncheckedUpdateInput>
    /**
     * Choose, which ReasonStockNG to update.
     */
    where: ReasonStockNGWhereUniqueInput
  }

  /**
   * ReasonStockNG updateMany
   */
  export type ReasonStockNGUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ReasonStockNGS.
     */
    data: XOR<ReasonStockNGUpdateManyMutationInput, ReasonStockNGUncheckedUpdateManyInput>
    /**
     * Filter which ReasonStockNGS to update
     */
    where?: ReasonStockNGWhereInput
  }

  /**
   * ReasonStockNG upsert
   */
  export type ReasonStockNGUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReasonStockNG
     */
    select?: ReasonStockNGSelect<ExtArgs> | null
    /**
     * The filter to search for the ReasonStockNG to update in case it exists.
     */
    where: ReasonStockNGWhereUniqueInput
    /**
     * In case the ReasonStockNG found by the `where` argument doesn't exist, create a new ReasonStockNG with this data.
     */
    create: XOR<ReasonStockNGCreateInput, ReasonStockNGUncheckedCreateInput>
    /**
     * In case the ReasonStockNG was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ReasonStockNGUpdateInput, ReasonStockNGUncheckedUpdateInput>
  }

  /**
   * ReasonStockNG delete
   */
  export type ReasonStockNGDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReasonStockNG
     */
    select?: ReasonStockNGSelect<ExtArgs> | null
    /**
     * Filter which ReasonStockNG to delete.
     */
    where: ReasonStockNGWhereUniqueInput
  }

  /**
   * ReasonStockNG deleteMany
   */
  export type ReasonStockNGDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ReasonStockNGS to delete
     */
    where?: ReasonStockNGWhereInput
  }

  /**
   * ReasonStockNG without action
   */
  export type ReasonStockNGDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReasonStockNG
     */
    select?: ReasonStockNGSelect<ExtArgs> | null
  }


  /**
   * Model ReasonTypeNG
   */

  export type AggregateReasonTypeNG = {
    _count: ReasonTypeNGCountAggregateOutputType | null
    _avg: ReasonTypeNGAvgAggregateOutputType | null
    _sum: ReasonTypeNGSumAggregateOutputType | null
    _min: ReasonTypeNGMinAggregateOutputType | null
    _max: ReasonTypeNGMaxAggregateOutputType | null
  }

  export type ReasonTypeNGAvgAggregateOutputType = {
    id: number | null
  }

  export type ReasonTypeNGSumAggregateOutputType = {
    id: number | null
  }

  export type ReasonTypeNGMinAggregateOutputType = {
    id: number | null
    reasontypeName: string | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type ReasonTypeNGMaxAggregateOutputType = {
    id: number | null
    reasontypeName: string | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type ReasonTypeNGCountAggregateOutputType = {
    id: number
    reasontypeName: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    _all: number
  }


  export type ReasonTypeNGAvgAggregateInputType = {
    id?: true
  }

  export type ReasonTypeNGSumAggregateInputType = {
    id?: true
  }

  export type ReasonTypeNGMinAggregateInputType = {
    id?: true
    reasontypeName?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type ReasonTypeNGMaxAggregateInputType = {
    id?: true
    reasontypeName?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type ReasonTypeNGCountAggregateInputType = {
    id?: true
    reasontypeName?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    _all?: true
  }

  export type ReasonTypeNGAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ReasonTypeNG to aggregate.
     */
    where?: ReasonTypeNGWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReasonTypeNGS to fetch.
     */
    orderBy?: ReasonTypeNGOrderByWithRelationInput | ReasonTypeNGOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ReasonTypeNGWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReasonTypeNGS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReasonTypeNGS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ReasonTypeNGS
    **/
    _count?: true | ReasonTypeNGCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ReasonTypeNGAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ReasonTypeNGSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReasonTypeNGMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReasonTypeNGMaxAggregateInputType
  }

  export type GetReasonTypeNGAggregateType<T extends ReasonTypeNGAggregateArgs> = {
        [P in keyof T & keyof AggregateReasonTypeNG]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReasonTypeNG[P]>
      : GetScalarType<T[P], AggregateReasonTypeNG[P]>
  }




  export type ReasonTypeNGGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReasonTypeNGWhereInput
    orderBy?: ReasonTypeNGOrderByWithAggregationInput | ReasonTypeNGOrderByWithAggregationInput[]
    by: ReasonTypeNGScalarFieldEnum[] | ReasonTypeNGScalarFieldEnum
    having?: ReasonTypeNGScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReasonTypeNGCountAggregateInputType | true
    _avg?: ReasonTypeNGAvgAggregateInputType
    _sum?: ReasonTypeNGSumAggregateInputType
    _min?: ReasonTypeNGMinAggregateInputType
    _max?: ReasonTypeNGMaxAggregateInputType
  }

  export type ReasonTypeNGGroupByOutputType = {
    id: number
    reasontypeName: string
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
    _count: ReasonTypeNGCountAggregateOutputType | null
    _avg: ReasonTypeNGAvgAggregateOutputType | null
    _sum: ReasonTypeNGSumAggregateOutputType | null
    _min: ReasonTypeNGMinAggregateOutputType | null
    _max: ReasonTypeNGMaxAggregateOutputType | null
  }

  type GetReasonTypeNGGroupByPayload<T extends ReasonTypeNGGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReasonTypeNGGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReasonTypeNGGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReasonTypeNGGroupByOutputType[P]>
            : GetScalarType<T[P], ReasonTypeNGGroupByOutputType[P]>
        }
      >
    >


  export type ReasonTypeNGSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    reasontypeName?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    reasondDetail?: boolean | ReasonTypeNG$reasondDetailArgs<ExtArgs>
    _count?: boolean | ReasonTypeNGCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["reasonTypeNG"]>


  export type ReasonTypeNGSelectScalar = {
    id?: boolean
    reasontypeName?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }

  export type ReasonTypeNGInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    reasondDetail?: boolean | ReasonTypeNG$reasondDetailArgs<ExtArgs>
    _count?: boolean | ReasonTypeNGCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $ReasonTypeNGPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ReasonTypeNG"
    objects: {
      reasondDetail: Prisma.$ReasonDetailPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      reasontypeName: string
      createdAt: Date
      updatedAt: Date
      deletedAt: Date | null
    }, ExtArgs["result"]["reasonTypeNG"]>
    composites: {}
  }

  type ReasonTypeNGGetPayload<S extends boolean | null | undefined | ReasonTypeNGDefaultArgs> = $Result.GetResult<Prisma.$ReasonTypeNGPayload, S>

  type ReasonTypeNGCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ReasonTypeNGFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ReasonTypeNGCountAggregateInputType | true
    }

  export interface ReasonTypeNGDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ReasonTypeNG'], meta: { name: 'ReasonTypeNG' } }
    /**
     * Find zero or one ReasonTypeNG that matches the filter.
     * @param {ReasonTypeNGFindUniqueArgs} args - Arguments to find a ReasonTypeNG
     * @example
     * // Get one ReasonTypeNG
     * const reasonTypeNG = await prisma.reasonTypeNG.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ReasonTypeNGFindUniqueArgs>(args: SelectSubset<T, ReasonTypeNGFindUniqueArgs<ExtArgs>>): Prisma__ReasonTypeNGClient<$Result.GetResult<Prisma.$ReasonTypeNGPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ReasonTypeNG that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ReasonTypeNGFindUniqueOrThrowArgs} args - Arguments to find a ReasonTypeNG
     * @example
     * // Get one ReasonTypeNG
     * const reasonTypeNG = await prisma.reasonTypeNG.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ReasonTypeNGFindUniqueOrThrowArgs>(args: SelectSubset<T, ReasonTypeNGFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ReasonTypeNGClient<$Result.GetResult<Prisma.$ReasonTypeNGPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ReasonTypeNG that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReasonTypeNGFindFirstArgs} args - Arguments to find a ReasonTypeNG
     * @example
     * // Get one ReasonTypeNG
     * const reasonTypeNG = await prisma.reasonTypeNG.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ReasonTypeNGFindFirstArgs>(args?: SelectSubset<T, ReasonTypeNGFindFirstArgs<ExtArgs>>): Prisma__ReasonTypeNGClient<$Result.GetResult<Prisma.$ReasonTypeNGPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ReasonTypeNG that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReasonTypeNGFindFirstOrThrowArgs} args - Arguments to find a ReasonTypeNG
     * @example
     * // Get one ReasonTypeNG
     * const reasonTypeNG = await prisma.reasonTypeNG.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ReasonTypeNGFindFirstOrThrowArgs>(args?: SelectSubset<T, ReasonTypeNGFindFirstOrThrowArgs<ExtArgs>>): Prisma__ReasonTypeNGClient<$Result.GetResult<Prisma.$ReasonTypeNGPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ReasonTypeNGS that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReasonTypeNGFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ReasonTypeNGS
     * const reasonTypeNGS = await prisma.reasonTypeNG.findMany()
     * 
     * // Get first 10 ReasonTypeNGS
     * const reasonTypeNGS = await prisma.reasonTypeNG.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const reasonTypeNGWithIdOnly = await prisma.reasonTypeNG.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ReasonTypeNGFindManyArgs>(args?: SelectSubset<T, ReasonTypeNGFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReasonTypeNGPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ReasonTypeNG.
     * @param {ReasonTypeNGCreateArgs} args - Arguments to create a ReasonTypeNG.
     * @example
     * // Create one ReasonTypeNG
     * const ReasonTypeNG = await prisma.reasonTypeNG.create({
     *   data: {
     *     // ... data to create a ReasonTypeNG
     *   }
     * })
     * 
     */
    create<T extends ReasonTypeNGCreateArgs>(args: SelectSubset<T, ReasonTypeNGCreateArgs<ExtArgs>>): Prisma__ReasonTypeNGClient<$Result.GetResult<Prisma.$ReasonTypeNGPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ReasonTypeNGS.
     * @param {ReasonTypeNGCreateManyArgs} args - Arguments to create many ReasonTypeNGS.
     * @example
     * // Create many ReasonTypeNGS
     * const reasonTypeNG = await prisma.reasonTypeNG.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ReasonTypeNGCreateManyArgs>(args?: SelectSubset<T, ReasonTypeNGCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ReasonTypeNG.
     * @param {ReasonTypeNGDeleteArgs} args - Arguments to delete one ReasonTypeNG.
     * @example
     * // Delete one ReasonTypeNG
     * const ReasonTypeNG = await prisma.reasonTypeNG.delete({
     *   where: {
     *     // ... filter to delete one ReasonTypeNG
     *   }
     * })
     * 
     */
    delete<T extends ReasonTypeNGDeleteArgs>(args: SelectSubset<T, ReasonTypeNGDeleteArgs<ExtArgs>>): Prisma__ReasonTypeNGClient<$Result.GetResult<Prisma.$ReasonTypeNGPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ReasonTypeNG.
     * @param {ReasonTypeNGUpdateArgs} args - Arguments to update one ReasonTypeNG.
     * @example
     * // Update one ReasonTypeNG
     * const reasonTypeNG = await prisma.reasonTypeNG.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ReasonTypeNGUpdateArgs>(args: SelectSubset<T, ReasonTypeNGUpdateArgs<ExtArgs>>): Prisma__ReasonTypeNGClient<$Result.GetResult<Prisma.$ReasonTypeNGPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ReasonTypeNGS.
     * @param {ReasonTypeNGDeleteManyArgs} args - Arguments to filter ReasonTypeNGS to delete.
     * @example
     * // Delete a few ReasonTypeNGS
     * const { count } = await prisma.reasonTypeNG.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ReasonTypeNGDeleteManyArgs>(args?: SelectSubset<T, ReasonTypeNGDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ReasonTypeNGS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReasonTypeNGUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ReasonTypeNGS
     * const reasonTypeNG = await prisma.reasonTypeNG.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ReasonTypeNGUpdateManyArgs>(args: SelectSubset<T, ReasonTypeNGUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ReasonTypeNG.
     * @param {ReasonTypeNGUpsertArgs} args - Arguments to update or create a ReasonTypeNG.
     * @example
     * // Update or create a ReasonTypeNG
     * const reasonTypeNG = await prisma.reasonTypeNG.upsert({
     *   create: {
     *     // ... data to create a ReasonTypeNG
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ReasonTypeNG we want to update
     *   }
     * })
     */
    upsert<T extends ReasonTypeNGUpsertArgs>(args: SelectSubset<T, ReasonTypeNGUpsertArgs<ExtArgs>>): Prisma__ReasonTypeNGClient<$Result.GetResult<Prisma.$ReasonTypeNGPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ReasonTypeNGS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReasonTypeNGCountArgs} args - Arguments to filter ReasonTypeNGS to count.
     * @example
     * // Count the number of ReasonTypeNGS
     * const count = await prisma.reasonTypeNG.count({
     *   where: {
     *     // ... the filter for the ReasonTypeNGS we want to count
     *   }
     * })
    **/
    count<T extends ReasonTypeNGCountArgs>(
      args?: Subset<T, ReasonTypeNGCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReasonTypeNGCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ReasonTypeNG.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReasonTypeNGAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReasonTypeNGAggregateArgs>(args: Subset<T, ReasonTypeNGAggregateArgs>): Prisma.PrismaPromise<GetReasonTypeNGAggregateType<T>>

    /**
     * Group by ReasonTypeNG.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReasonTypeNGGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReasonTypeNGGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReasonTypeNGGroupByArgs['orderBy'] }
        : { orderBy?: ReasonTypeNGGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReasonTypeNGGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReasonTypeNGGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ReasonTypeNG model
   */
  readonly fields: ReasonTypeNGFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ReasonTypeNG.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ReasonTypeNGClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    reasondDetail<T extends ReasonTypeNG$reasondDetailArgs<ExtArgs> = {}>(args?: Subset<T, ReasonTypeNG$reasondDetailArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReasonDetailPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ReasonTypeNG model
   */ 
  interface ReasonTypeNGFieldRefs {
    readonly id: FieldRef<"ReasonTypeNG", 'Int'>
    readonly reasontypeName: FieldRef<"ReasonTypeNG", 'String'>
    readonly createdAt: FieldRef<"ReasonTypeNG", 'DateTime'>
    readonly updatedAt: FieldRef<"ReasonTypeNG", 'DateTime'>
    readonly deletedAt: FieldRef<"ReasonTypeNG", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ReasonTypeNG findUnique
   */
  export type ReasonTypeNGFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReasonTypeNG
     */
    select?: ReasonTypeNGSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReasonTypeNGInclude<ExtArgs> | null
    /**
     * Filter, which ReasonTypeNG to fetch.
     */
    where: ReasonTypeNGWhereUniqueInput
  }

  /**
   * ReasonTypeNG findUniqueOrThrow
   */
  export type ReasonTypeNGFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReasonTypeNG
     */
    select?: ReasonTypeNGSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReasonTypeNGInclude<ExtArgs> | null
    /**
     * Filter, which ReasonTypeNG to fetch.
     */
    where: ReasonTypeNGWhereUniqueInput
  }

  /**
   * ReasonTypeNG findFirst
   */
  export type ReasonTypeNGFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReasonTypeNG
     */
    select?: ReasonTypeNGSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReasonTypeNGInclude<ExtArgs> | null
    /**
     * Filter, which ReasonTypeNG to fetch.
     */
    where?: ReasonTypeNGWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReasonTypeNGS to fetch.
     */
    orderBy?: ReasonTypeNGOrderByWithRelationInput | ReasonTypeNGOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ReasonTypeNGS.
     */
    cursor?: ReasonTypeNGWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReasonTypeNGS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReasonTypeNGS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ReasonTypeNGS.
     */
    distinct?: ReasonTypeNGScalarFieldEnum | ReasonTypeNGScalarFieldEnum[]
  }

  /**
   * ReasonTypeNG findFirstOrThrow
   */
  export type ReasonTypeNGFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReasonTypeNG
     */
    select?: ReasonTypeNGSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReasonTypeNGInclude<ExtArgs> | null
    /**
     * Filter, which ReasonTypeNG to fetch.
     */
    where?: ReasonTypeNGWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReasonTypeNGS to fetch.
     */
    orderBy?: ReasonTypeNGOrderByWithRelationInput | ReasonTypeNGOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ReasonTypeNGS.
     */
    cursor?: ReasonTypeNGWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReasonTypeNGS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReasonTypeNGS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ReasonTypeNGS.
     */
    distinct?: ReasonTypeNGScalarFieldEnum | ReasonTypeNGScalarFieldEnum[]
  }

  /**
   * ReasonTypeNG findMany
   */
  export type ReasonTypeNGFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReasonTypeNG
     */
    select?: ReasonTypeNGSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReasonTypeNGInclude<ExtArgs> | null
    /**
     * Filter, which ReasonTypeNGS to fetch.
     */
    where?: ReasonTypeNGWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReasonTypeNGS to fetch.
     */
    orderBy?: ReasonTypeNGOrderByWithRelationInput | ReasonTypeNGOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ReasonTypeNGS.
     */
    cursor?: ReasonTypeNGWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReasonTypeNGS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReasonTypeNGS.
     */
    skip?: number
    distinct?: ReasonTypeNGScalarFieldEnum | ReasonTypeNGScalarFieldEnum[]
  }

  /**
   * ReasonTypeNG create
   */
  export type ReasonTypeNGCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReasonTypeNG
     */
    select?: ReasonTypeNGSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReasonTypeNGInclude<ExtArgs> | null
    /**
     * The data needed to create a ReasonTypeNG.
     */
    data: XOR<ReasonTypeNGCreateInput, ReasonTypeNGUncheckedCreateInput>
  }

  /**
   * ReasonTypeNG createMany
   */
  export type ReasonTypeNGCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ReasonTypeNGS.
     */
    data: ReasonTypeNGCreateManyInput | ReasonTypeNGCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ReasonTypeNG update
   */
  export type ReasonTypeNGUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReasonTypeNG
     */
    select?: ReasonTypeNGSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReasonTypeNGInclude<ExtArgs> | null
    /**
     * The data needed to update a ReasonTypeNG.
     */
    data: XOR<ReasonTypeNGUpdateInput, ReasonTypeNGUncheckedUpdateInput>
    /**
     * Choose, which ReasonTypeNG to update.
     */
    where: ReasonTypeNGWhereUniqueInput
  }

  /**
   * ReasonTypeNG updateMany
   */
  export type ReasonTypeNGUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ReasonTypeNGS.
     */
    data: XOR<ReasonTypeNGUpdateManyMutationInput, ReasonTypeNGUncheckedUpdateManyInput>
    /**
     * Filter which ReasonTypeNGS to update
     */
    where?: ReasonTypeNGWhereInput
  }

  /**
   * ReasonTypeNG upsert
   */
  export type ReasonTypeNGUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReasonTypeNG
     */
    select?: ReasonTypeNGSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReasonTypeNGInclude<ExtArgs> | null
    /**
     * The filter to search for the ReasonTypeNG to update in case it exists.
     */
    where: ReasonTypeNGWhereUniqueInput
    /**
     * In case the ReasonTypeNG found by the `where` argument doesn't exist, create a new ReasonTypeNG with this data.
     */
    create: XOR<ReasonTypeNGCreateInput, ReasonTypeNGUncheckedCreateInput>
    /**
     * In case the ReasonTypeNG was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ReasonTypeNGUpdateInput, ReasonTypeNGUncheckedUpdateInput>
  }

  /**
   * ReasonTypeNG delete
   */
  export type ReasonTypeNGDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReasonTypeNG
     */
    select?: ReasonTypeNGSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReasonTypeNGInclude<ExtArgs> | null
    /**
     * Filter which ReasonTypeNG to delete.
     */
    where: ReasonTypeNGWhereUniqueInput
  }

  /**
   * ReasonTypeNG deleteMany
   */
  export type ReasonTypeNGDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ReasonTypeNGS to delete
     */
    where?: ReasonTypeNGWhereInput
  }

  /**
   * ReasonTypeNG.reasondDetail
   */
  export type ReasonTypeNG$reasondDetailArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReasonDetail
     */
    select?: ReasonDetailSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReasonDetailInclude<ExtArgs> | null
    where?: ReasonDetailWhereInput
    orderBy?: ReasonDetailOrderByWithRelationInput | ReasonDetailOrderByWithRelationInput[]
    cursor?: ReasonDetailWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReasonDetailScalarFieldEnum | ReasonDetailScalarFieldEnum[]
  }

  /**
   * ReasonTypeNG without action
   */
  export type ReasonTypeNGDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReasonTypeNG
     */
    select?: ReasonTypeNGSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReasonTypeNGInclude<ExtArgs> | null
  }


  /**
   * Model ReasonDetail
   */

  export type AggregateReasonDetail = {
    _count: ReasonDetailCountAggregateOutputType | null
    _avg: ReasonDetailAvgAggregateOutputType | null
    _sum: ReasonDetailSumAggregateOutputType | null
    _min: ReasonDetailMinAggregateOutputType | null
    _max: ReasonDetailMaxAggregateOutputType | null
  }

  export type ReasonDetailAvgAggregateOutputType = {
    id: number | null
    reasonTypeId: number | null
  }

  export type ReasonDetailSumAggregateOutputType = {
    id: number | null
    reasonTypeId: number | null
  }

  export type ReasonDetailMinAggregateOutputType = {
    id: number | null
    reasonTypeId: number | null
    reasondetailName: string | null
  }

  export type ReasonDetailMaxAggregateOutputType = {
    id: number | null
    reasonTypeId: number | null
    reasondetailName: string | null
  }

  export type ReasonDetailCountAggregateOutputType = {
    id: number
    reasonTypeId: number
    reasondetailName: number
    _all: number
  }


  export type ReasonDetailAvgAggregateInputType = {
    id?: true
    reasonTypeId?: true
  }

  export type ReasonDetailSumAggregateInputType = {
    id?: true
    reasonTypeId?: true
  }

  export type ReasonDetailMinAggregateInputType = {
    id?: true
    reasonTypeId?: true
    reasondetailName?: true
  }

  export type ReasonDetailMaxAggregateInputType = {
    id?: true
    reasonTypeId?: true
    reasondetailName?: true
  }

  export type ReasonDetailCountAggregateInputType = {
    id?: true
    reasonTypeId?: true
    reasondetailName?: true
    _all?: true
  }

  export type ReasonDetailAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ReasonDetail to aggregate.
     */
    where?: ReasonDetailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReasonDetails to fetch.
     */
    orderBy?: ReasonDetailOrderByWithRelationInput | ReasonDetailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ReasonDetailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReasonDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReasonDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ReasonDetails
    **/
    _count?: true | ReasonDetailCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ReasonDetailAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ReasonDetailSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReasonDetailMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReasonDetailMaxAggregateInputType
  }

  export type GetReasonDetailAggregateType<T extends ReasonDetailAggregateArgs> = {
        [P in keyof T & keyof AggregateReasonDetail]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReasonDetail[P]>
      : GetScalarType<T[P], AggregateReasonDetail[P]>
  }




  export type ReasonDetailGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReasonDetailWhereInput
    orderBy?: ReasonDetailOrderByWithAggregationInput | ReasonDetailOrderByWithAggregationInput[]
    by: ReasonDetailScalarFieldEnum[] | ReasonDetailScalarFieldEnum
    having?: ReasonDetailScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReasonDetailCountAggregateInputType | true
    _avg?: ReasonDetailAvgAggregateInputType
    _sum?: ReasonDetailSumAggregateInputType
    _min?: ReasonDetailMinAggregateInputType
    _max?: ReasonDetailMaxAggregateInputType
  }

  export type ReasonDetailGroupByOutputType = {
    id: number
    reasonTypeId: number
    reasondetailName: string
    _count: ReasonDetailCountAggregateOutputType | null
    _avg: ReasonDetailAvgAggregateOutputType | null
    _sum: ReasonDetailSumAggregateOutputType | null
    _min: ReasonDetailMinAggregateOutputType | null
    _max: ReasonDetailMaxAggregateOutputType | null
  }

  type GetReasonDetailGroupByPayload<T extends ReasonDetailGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReasonDetailGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReasonDetailGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReasonDetailGroupByOutputType[P]>
            : GetScalarType<T[P], ReasonDetailGroupByOutputType[P]>
        }
      >
    >


  export type ReasonDetailSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    reasonTypeId?: boolean
    reasondetailName?: boolean
    reasonTypeNG?: boolean | ReasonTypeNGDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["reasonDetail"]>


  export type ReasonDetailSelectScalar = {
    id?: boolean
    reasonTypeId?: boolean
    reasondetailName?: boolean
  }

  export type ReasonDetailInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    reasonTypeNG?: boolean | ReasonTypeNGDefaultArgs<ExtArgs>
  }

  export type $ReasonDetailPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ReasonDetail"
    objects: {
      reasonTypeNG: Prisma.$ReasonTypeNGPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      reasonTypeId: number
      reasondetailName: string
    }, ExtArgs["result"]["reasonDetail"]>
    composites: {}
  }

  type ReasonDetailGetPayload<S extends boolean | null | undefined | ReasonDetailDefaultArgs> = $Result.GetResult<Prisma.$ReasonDetailPayload, S>

  type ReasonDetailCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ReasonDetailFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ReasonDetailCountAggregateInputType | true
    }

  export interface ReasonDetailDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ReasonDetail'], meta: { name: 'ReasonDetail' } }
    /**
     * Find zero or one ReasonDetail that matches the filter.
     * @param {ReasonDetailFindUniqueArgs} args - Arguments to find a ReasonDetail
     * @example
     * // Get one ReasonDetail
     * const reasonDetail = await prisma.reasonDetail.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ReasonDetailFindUniqueArgs>(args: SelectSubset<T, ReasonDetailFindUniqueArgs<ExtArgs>>): Prisma__ReasonDetailClient<$Result.GetResult<Prisma.$ReasonDetailPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ReasonDetail that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ReasonDetailFindUniqueOrThrowArgs} args - Arguments to find a ReasonDetail
     * @example
     * // Get one ReasonDetail
     * const reasonDetail = await prisma.reasonDetail.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ReasonDetailFindUniqueOrThrowArgs>(args: SelectSubset<T, ReasonDetailFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ReasonDetailClient<$Result.GetResult<Prisma.$ReasonDetailPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ReasonDetail that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReasonDetailFindFirstArgs} args - Arguments to find a ReasonDetail
     * @example
     * // Get one ReasonDetail
     * const reasonDetail = await prisma.reasonDetail.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ReasonDetailFindFirstArgs>(args?: SelectSubset<T, ReasonDetailFindFirstArgs<ExtArgs>>): Prisma__ReasonDetailClient<$Result.GetResult<Prisma.$ReasonDetailPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ReasonDetail that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReasonDetailFindFirstOrThrowArgs} args - Arguments to find a ReasonDetail
     * @example
     * // Get one ReasonDetail
     * const reasonDetail = await prisma.reasonDetail.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ReasonDetailFindFirstOrThrowArgs>(args?: SelectSubset<T, ReasonDetailFindFirstOrThrowArgs<ExtArgs>>): Prisma__ReasonDetailClient<$Result.GetResult<Prisma.$ReasonDetailPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ReasonDetails that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReasonDetailFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ReasonDetails
     * const reasonDetails = await prisma.reasonDetail.findMany()
     * 
     * // Get first 10 ReasonDetails
     * const reasonDetails = await prisma.reasonDetail.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const reasonDetailWithIdOnly = await prisma.reasonDetail.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ReasonDetailFindManyArgs>(args?: SelectSubset<T, ReasonDetailFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReasonDetailPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ReasonDetail.
     * @param {ReasonDetailCreateArgs} args - Arguments to create a ReasonDetail.
     * @example
     * // Create one ReasonDetail
     * const ReasonDetail = await prisma.reasonDetail.create({
     *   data: {
     *     // ... data to create a ReasonDetail
     *   }
     * })
     * 
     */
    create<T extends ReasonDetailCreateArgs>(args: SelectSubset<T, ReasonDetailCreateArgs<ExtArgs>>): Prisma__ReasonDetailClient<$Result.GetResult<Prisma.$ReasonDetailPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ReasonDetails.
     * @param {ReasonDetailCreateManyArgs} args - Arguments to create many ReasonDetails.
     * @example
     * // Create many ReasonDetails
     * const reasonDetail = await prisma.reasonDetail.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ReasonDetailCreateManyArgs>(args?: SelectSubset<T, ReasonDetailCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ReasonDetail.
     * @param {ReasonDetailDeleteArgs} args - Arguments to delete one ReasonDetail.
     * @example
     * // Delete one ReasonDetail
     * const ReasonDetail = await prisma.reasonDetail.delete({
     *   where: {
     *     // ... filter to delete one ReasonDetail
     *   }
     * })
     * 
     */
    delete<T extends ReasonDetailDeleteArgs>(args: SelectSubset<T, ReasonDetailDeleteArgs<ExtArgs>>): Prisma__ReasonDetailClient<$Result.GetResult<Prisma.$ReasonDetailPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ReasonDetail.
     * @param {ReasonDetailUpdateArgs} args - Arguments to update one ReasonDetail.
     * @example
     * // Update one ReasonDetail
     * const reasonDetail = await prisma.reasonDetail.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ReasonDetailUpdateArgs>(args: SelectSubset<T, ReasonDetailUpdateArgs<ExtArgs>>): Prisma__ReasonDetailClient<$Result.GetResult<Prisma.$ReasonDetailPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ReasonDetails.
     * @param {ReasonDetailDeleteManyArgs} args - Arguments to filter ReasonDetails to delete.
     * @example
     * // Delete a few ReasonDetails
     * const { count } = await prisma.reasonDetail.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ReasonDetailDeleteManyArgs>(args?: SelectSubset<T, ReasonDetailDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ReasonDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReasonDetailUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ReasonDetails
     * const reasonDetail = await prisma.reasonDetail.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ReasonDetailUpdateManyArgs>(args: SelectSubset<T, ReasonDetailUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ReasonDetail.
     * @param {ReasonDetailUpsertArgs} args - Arguments to update or create a ReasonDetail.
     * @example
     * // Update or create a ReasonDetail
     * const reasonDetail = await prisma.reasonDetail.upsert({
     *   create: {
     *     // ... data to create a ReasonDetail
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ReasonDetail we want to update
     *   }
     * })
     */
    upsert<T extends ReasonDetailUpsertArgs>(args: SelectSubset<T, ReasonDetailUpsertArgs<ExtArgs>>): Prisma__ReasonDetailClient<$Result.GetResult<Prisma.$ReasonDetailPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ReasonDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReasonDetailCountArgs} args - Arguments to filter ReasonDetails to count.
     * @example
     * // Count the number of ReasonDetails
     * const count = await prisma.reasonDetail.count({
     *   where: {
     *     // ... the filter for the ReasonDetails we want to count
     *   }
     * })
    **/
    count<T extends ReasonDetailCountArgs>(
      args?: Subset<T, ReasonDetailCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReasonDetailCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ReasonDetail.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReasonDetailAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReasonDetailAggregateArgs>(args: Subset<T, ReasonDetailAggregateArgs>): Prisma.PrismaPromise<GetReasonDetailAggregateType<T>>

    /**
     * Group by ReasonDetail.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReasonDetailGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReasonDetailGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReasonDetailGroupByArgs['orderBy'] }
        : { orderBy?: ReasonDetailGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReasonDetailGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReasonDetailGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ReasonDetail model
   */
  readonly fields: ReasonDetailFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ReasonDetail.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ReasonDetailClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    reasonTypeNG<T extends ReasonTypeNGDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ReasonTypeNGDefaultArgs<ExtArgs>>): Prisma__ReasonTypeNGClient<$Result.GetResult<Prisma.$ReasonTypeNGPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ReasonDetail model
   */ 
  interface ReasonDetailFieldRefs {
    readonly id: FieldRef<"ReasonDetail", 'Int'>
    readonly reasonTypeId: FieldRef<"ReasonDetail", 'Int'>
    readonly reasondetailName: FieldRef<"ReasonDetail", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ReasonDetail findUnique
   */
  export type ReasonDetailFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReasonDetail
     */
    select?: ReasonDetailSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReasonDetailInclude<ExtArgs> | null
    /**
     * Filter, which ReasonDetail to fetch.
     */
    where: ReasonDetailWhereUniqueInput
  }

  /**
   * ReasonDetail findUniqueOrThrow
   */
  export type ReasonDetailFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReasonDetail
     */
    select?: ReasonDetailSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReasonDetailInclude<ExtArgs> | null
    /**
     * Filter, which ReasonDetail to fetch.
     */
    where: ReasonDetailWhereUniqueInput
  }

  /**
   * ReasonDetail findFirst
   */
  export type ReasonDetailFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReasonDetail
     */
    select?: ReasonDetailSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReasonDetailInclude<ExtArgs> | null
    /**
     * Filter, which ReasonDetail to fetch.
     */
    where?: ReasonDetailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReasonDetails to fetch.
     */
    orderBy?: ReasonDetailOrderByWithRelationInput | ReasonDetailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ReasonDetails.
     */
    cursor?: ReasonDetailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReasonDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReasonDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ReasonDetails.
     */
    distinct?: ReasonDetailScalarFieldEnum | ReasonDetailScalarFieldEnum[]
  }

  /**
   * ReasonDetail findFirstOrThrow
   */
  export type ReasonDetailFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReasonDetail
     */
    select?: ReasonDetailSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReasonDetailInclude<ExtArgs> | null
    /**
     * Filter, which ReasonDetail to fetch.
     */
    where?: ReasonDetailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReasonDetails to fetch.
     */
    orderBy?: ReasonDetailOrderByWithRelationInput | ReasonDetailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ReasonDetails.
     */
    cursor?: ReasonDetailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReasonDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReasonDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ReasonDetails.
     */
    distinct?: ReasonDetailScalarFieldEnum | ReasonDetailScalarFieldEnum[]
  }

  /**
   * ReasonDetail findMany
   */
  export type ReasonDetailFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReasonDetail
     */
    select?: ReasonDetailSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReasonDetailInclude<ExtArgs> | null
    /**
     * Filter, which ReasonDetails to fetch.
     */
    where?: ReasonDetailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReasonDetails to fetch.
     */
    orderBy?: ReasonDetailOrderByWithRelationInput | ReasonDetailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ReasonDetails.
     */
    cursor?: ReasonDetailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReasonDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReasonDetails.
     */
    skip?: number
    distinct?: ReasonDetailScalarFieldEnum | ReasonDetailScalarFieldEnum[]
  }

  /**
   * ReasonDetail create
   */
  export type ReasonDetailCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReasonDetail
     */
    select?: ReasonDetailSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReasonDetailInclude<ExtArgs> | null
    /**
     * The data needed to create a ReasonDetail.
     */
    data: XOR<ReasonDetailCreateInput, ReasonDetailUncheckedCreateInput>
  }

  /**
   * ReasonDetail createMany
   */
  export type ReasonDetailCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ReasonDetails.
     */
    data: ReasonDetailCreateManyInput | ReasonDetailCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ReasonDetail update
   */
  export type ReasonDetailUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReasonDetail
     */
    select?: ReasonDetailSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReasonDetailInclude<ExtArgs> | null
    /**
     * The data needed to update a ReasonDetail.
     */
    data: XOR<ReasonDetailUpdateInput, ReasonDetailUncheckedUpdateInput>
    /**
     * Choose, which ReasonDetail to update.
     */
    where: ReasonDetailWhereUniqueInput
  }

  /**
   * ReasonDetail updateMany
   */
  export type ReasonDetailUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ReasonDetails.
     */
    data: XOR<ReasonDetailUpdateManyMutationInput, ReasonDetailUncheckedUpdateManyInput>
    /**
     * Filter which ReasonDetails to update
     */
    where?: ReasonDetailWhereInput
  }

  /**
   * ReasonDetail upsert
   */
  export type ReasonDetailUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReasonDetail
     */
    select?: ReasonDetailSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReasonDetailInclude<ExtArgs> | null
    /**
     * The filter to search for the ReasonDetail to update in case it exists.
     */
    where: ReasonDetailWhereUniqueInput
    /**
     * In case the ReasonDetail found by the `where` argument doesn't exist, create a new ReasonDetail with this data.
     */
    create: XOR<ReasonDetailCreateInput, ReasonDetailUncheckedCreateInput>
    /**
     * In case the ReasonDetail was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ReasonDetailUpdateInput, ReasonDetailUncheckedUpdateInput>
  }

  /**
   * ReasonDetail delete
   */
  export type ReasonDetailDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReasonDetail
     */
    select?: ReasonDetailSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReasonDetailInclude<ExtArgs> | null
    /**
     * Filter which ReasonDetail to delete.
     */
    where: ReasonDetailWhereUniqueInput
  }

  /**
   * ReasonDetail deleteMany
   */
  export type ReasonDetailDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ReasonDetails to delete
     */
    where?: ReasonDetailWhereInput
  }

  /**
   * ReasonDetail without action
   */
  export type ReasonDetailDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReasonDetail
     */
    select?: ReasonDetailSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReasonDetailInclude<ExtArgs> | null
  }


  /**
   * Model Report
   */

  export type AggregateReport = {
    _count: ReportCountAggregateOutputType | null
    _avg: ReportAvgAggregateOutputType | null
    _sum: ReportSumAggregateOutputType | null
    _min: ReportMinAggregateOutputType | null
    _max: ReportMaxAggregateOutputType | null
  }

  export type ReportAvgAggregateOutputType = {
    id: number | null
    projectId: number | null
    amountComplete: number | null
    amountNG: number | null
    reasonId: number | null
  }

  export type ReportSumAggregateOutputType = {
    id: number | null
    projectId: number | null
    amountComplete: number | null
    amountNG: number | null
    reasonId: number | null
  }

  export type ReportMinAggregateOutputType = {
    id: number | null
    projectId: number | null
    blueprintNo: string | null
    serialId: string | null
    reportName: string | null
    amountComplete: number | null
    amountNG: number | null
    timeHour: string | null
    reportType: string | null
    status: string | null
    reasonType: string | null
    reasonDetail: string | null
    reasonId: number | null
    createdAt: Date | null
    createdBy: string | null
    updatedAt: Date | null
    updatedBy: string | null
    deletedAt: Date | null
    deletedBy: string | null
  }

  export type ReportMaxAggregateOutputType = {
    id: number | null
    projectId: number | null
    blueprintNo: string | null
    serialId: string | null
    reportName: string | null
    amountComplete: number | null
    amountNG: number | null
    timeHour: string | null
    reportType: string | null
    status: string | null
    reasonType: string | null
    reasonDetail: string | null
    reasonId: number | null
    createdAt: Date | null
    createdBy: string | null
    updatedAt: Date | null
    updatedBy: string | null
    deletedAt: Date | null
    deletedBy: string | null
  }

  export type ReportCountAggregateOutputType = {
    id: number
    projectId: number
    blueprintNo: number
    serialId: number
    reportName: number
    amountComplete: number
    amountNG: number
    timeHour: number
    reportType: number
    status: number
    reasonType: number
    reasonDetail: number
    reasonId: number
    createdAt: number
    createdBy: number
    updatedAt: number
    updatedBy: number
    deletedAt: number
    deletedBy: number
    _all: number
  }


  export type ReportAvgAggregateInputType = {
    id?: true
    projectId?: true
    amountComplete?: true
    amountNG?: true
    reasonId?: true
  }

  export type ReportSumAggregateInputType = {
    id?: true
    projectId?: true
    amountComplete?: true
    amountNG?: true
    reasonId?: true
  }

  export type ReportMinAggregateInputType = {
    id?: true
    projectId?: true
    blueprintNo?: true
    serialId?: true
    reportName?: true
    amountComplete?: true
    amountNG?: true
    timeHour?: true
    reportType?: true
    status?: true
    reasonType?: true
    reasonDetail?: true
    reasonId?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
    deletedAt?: true
    deletedBy?: true
  }

  export type ReportMaxAggregateInputType = {
    id?: true
    projectId?: true
    blueprintNo?: true
    serialId?: true
    reportName?: true
    amountComplete?: true
    amountNG?: true
    timeHour?: true
    reportType?: true
    status?: true
    reasonType?: true
    reasonDetail?: true
    reasonId?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
    deletedAt?: true
    deletedBy?: true
  }

  export type ReportCountAggregateInputType = {
    id?: true
    projectId?: true
    blueprintNo?: true
    serialId?: true
    reportName?: true
    amountComplete?: true
    amountNG?: true
    timeHour?: true
    reportType?: true
    status?: true
    reasonType?: true
    reasonDetail?: true
    reasonId?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
    deletedAt?: true
    deletedBy?: true
    _all?: true
  }

  export type ReportAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Report to aggregate.
     */
    where?: ReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reports to fetch.
     */
    orderBy?: ReportOrderByWithRelationInput | ReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Reports
    **/
    _count?: true | ReportCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ReportAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ReportSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReportMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReportMaxAggregateInputType
  }

  export type GetReportAggregateType<T extends ReportAggregateArgs> = {
        [P in keyof T & keyof AggregateReport]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReport[P]>
      : GetScalarType<T[P], AggregateReport[P]>
  }




  export type ReportGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReportWhereInput
    orderBy?: ReportOrderByWithAggregationInput | ReportOrderByWithAggregationInput[]
    by: ReportScalarFieldEnum[] | ReportScalarFieldEnum
    having?: ReportScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReportCountAggregateInputType | true
    _avg?: ReportAvgAggregateInputType
    _sum?: ReportSumAggregateInputType
    _min?: ReportMinAggregateInputType
    _max?: ReportMaxAggregateInputType
  }

  export type ReportGroupByOutputType = {
    id: number
    projectId: number
    blueprintNo: string
    serialId: string
    reportName: string
    amountComplete: number
    amountNG: number
    timeHour: string
    reportType: string
    status: string
    reasonType: string | null
    reasonDetail: string
    reasonId: number | null
    createdAt: Date
    createdBy: string
    updatedAt: Date
    updatedBy: string
    deletedAt: Date | null
    deletedBy: string
    _count: ReportCountAggregateOutputType | null
    _avg: ReportAvgAggregateOutputType | null
    _sum: ReportSumAggregateOutputType | null
    _min: ReportMinAggregateOutputType | null
    _max: ReportMaxAggregateOutputType | null
  }

  type GetReportGroupByPayload<T extends ReportGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReportGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReportGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReportGroupByOutputType[P]>
            : GetScalarType<T[P], ReportGroupByOutputType[P]>
        }
      >
    >


  export type ReportSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    blueprintNo?: boolean
    serialId?: boolean
    reportName?: boolean
    amountComplete?: boolean
    amountNG?: boolean
    timeHour?: boolean
    reportType?: boolean
    status?: boolean
    reasonType?: boolean
    reasonDetail?: boolean
    reasonId?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
    deletedAt?: boolean
    deletedBy?: boolean
    reportProcess?: boolean | Report$reportProcessArgs<ExtArgs>
    _count?: boolean | ReportCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["report"]>


  export type ReportSelectScalar = {
    id?: boolean
    projectId?: boolean
    blueprintNo?: boolean
    serialId?: boolean
    reportName?: boolean
    amountComplete?: boolean
    amountNG?: boolean
    timeHour?: boolean
    reportType?: boolean
    status?: boolean
    reasonType?: boolean
    reasonDetail?: boolean
    reasonId?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
    deletedAt?: boolean
    deletedBy?: boolean
  }

  export type ReportInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    reportProcess?: boolean | Report$reportProcessArgs<ExtArgs>
    _count?: boolean | ReportCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $ReportPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Report"
    objects: {
      reportProcess: Prisma.$ReportProcessPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      projectId: number
      blueprintNo: string
      serialId: string
      reportName: string
      amountComplete: number
      amountNG: number
      timeHour: string
      reportType: string
      status: string
      reasonType: string | null
      reasonDetail: string
      reasonId: number | null
      createdAt: Date
      createdBy: string
      updatedAt: Date
      updatedBy: string
      deletedAt: Date | null
      deletedBy: string
    }, ExtArgs["result"]["report"]>
    composites: {}
  }

  type ReportGetPayload<S extends boolean | null | undefined | ReportDefaultArgs> = $Result.GetResult<Prisma.$ReportPayload, S>

  type ReportCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ReportFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ReportCountAggregateInputType | true
    }

  export interface ReportDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Report'], meta: { name: 'Report' } }
    /**
     * Find zero or one Report that matches the filter.
     * @param {ReportFindUniqueArgs} args - Arguments to find a Report
     * @example
     * // Get one Report
     * const report = await prisma.report.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ReportFindUniqueArgs>(args: SelectSubset<T, ReportFindUniqueArgs<ExtArgs>>): Prisma__ReportClient<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Report that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ReportFindUniqueOrThrowArgs} args - Arguments to find a Report
     * @example
     * // Get one Report
     * const report = await prisma.report.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ReportFindUniqueOrThrowArgs>(args: SelectSubset<T, ReportFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ReportClient<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Report that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportFindFirstArgs} args - Arguments to find a Report
     * @example
     * // Get one Report
     * const report = await prisma.report.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ReportFindFirstArgs>(args?: SelectSubset<T, ReportFindFirstArgs<ExtArgs>>): Prisma__ReportClient<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Report that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportFindFirstOrThrowArgs} args - Arguments to find a Report
     * @example
     * // Get one Report
     * const report = await prisma.report.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ReportFindFirstOrThrowArgs>(args?: SelectSubset<T, ReportFindFirstOrThrowArgs<ExtArgs>>): Prisma__ReportClient<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Reports that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Reports
     * const reports = await prisma.report.findMany()
     * 
     * // Get first 10 Reports
     * const reports = await prisma.report.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const reportWithIdOnly = await prisma.report.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ReportFindManyArgs>(args?: SelectSubset<T, ReportFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Report.
     * @param {ReportCreateArgs} args - Arguments to create a Report.
     * @example
     * // Create one Report
     * const Report = await prisma.report.create({
     *   data: {
     *     // ... data to create a Report
     *   }
     * })
     * 
     */
    create<T extends ReportCreateArgs>(args: SelectSubset<T, ReportCreateArgs<ExtArgs>>): Prisma__ReportClient<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Reports.
     * @param {ReportCreateManyArgs} args - Arguments to create many Reports.
     * @example
     * // Create many Reports
     * const report = await prisma.report.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ReportCreateManyArgs>(args?: SelectSubset<T, ReportCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Report.
     * @param {ReportDeleteArgs} args - Arguments to delete one Report.
     * @example
     * // Delete one Report
     * const Report = await prisma.report.delete({
     *   where: {
     *     // ... filter to delete one Report
     *   }
     * })
     * 
     */
    delete<T extends ReportDeleteArgs>(args: SelectSubset<T, ReportDeleteArgs<ExtArgs>>): Prisma__ReportClient<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Report.
     * @param {ReportUpdateArgs} args - Arguments to update one Report.
     * @example
     * // Update one Report
     * const report = await prisma.report.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ReportUpdateArgs>(args: SelectSubset<T, ReportUpdateArgs<ExtArgs>>): Prisma__ReportClient<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Reports.
     * @param {ReportDeleteManyArgs} args - Arguments to filter Reports to delete.
     * @example
     * // Delete a few Reports
     * const { count } = await prisma.report.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ReportDeleteManyArgs>(args?: SelectSubset<T, ReportDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Reports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Reports
     * const report = await prisma.report.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ReportUpdateManyArgs>(args: SelectSubset<T, ReportUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Report.
     * @param {ReportUpsertArgs} args - Arguments to update or create a Report.
     * @example
     * // Update or create a Report
     * const report = await prisma.report.upsert({
     *   create: {
     *     // ... data to create a Report
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Report we want to update
     *   }
     * })
     */
    upsert<T extends ReportUpsertArgs>(args: SelectSubset<T, ReportUpsertArgs<ExtArgs>>): Prisma__ReportClient<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Reports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportCountArgs} args - Arguments to filter Reports to count.
     * @example
     * // Count the number of Reports
     * const count = await prisma.report.count({
     *   where: {
     *     // ... the filter for the Reports we want to count
     *   }
     * })
    **/
    count<T extends ReportCountArgs>(
      args?: Subset<T, ReportCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReportCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Report.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReportAggregateArgs>(args: Subset<T, ReportAggregateArgs>): Prisma.PrismaPromise<GetReportAggregateType<T>>

    /**
     * Group by Report.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReportGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReportGroupByArgs['orderBy'] }
        : { orderBy?: ReportGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReportGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReportGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Report model
   */
  readonly fields: ReportFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Report.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ReportClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    reportProcess<T extends Report$reportProcessArgs<ExtArgs> = {}>(args?: Subset<T, Report$reportProcessArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReportProcessPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Report model
   */ 
  interface ReportFieldRefs {
    readonly id: FieldRef<"Report", 'Int'>
    readonly projectId: FieldRef<"Report", 'Int'>
    readonly blueprintNo: FieldRef<"Report", 'String'>
    readonly serialId: FieldRef<"Report", 'String'>
    readonly reportName: FieldRef<"Report", 'String'>
    readonly amountComplete: FieldRef<"Report", 'Int'>
    readonly amountNG: FieldRef<"Report", 'Int'>
    readonly timeHour: FieldRef<"Report", 'String'>
    readonly reportType: FieldRef<"Report", 'String'>
    readonly status: FieldRef<"Report", 'String'>
    readonly reasonType: FieldRef<"Report", 'String'>
    readonly reasonDetail: FieldRef<"Report", 'String'>
    readonly reasonId: FieldRef<"Report", 'Int'>
    readonly createdAt: FieldRef<"Report", 'DateTime'>
    readonly createdBy: FieldRef<"Report", 'String'>
    readonly updatedAt: FieldRef<"Report", 'DateTime'>
    readonly updatedBy: FieldRef<"Report", 'String'>
    readonly deletedAt: FieldRef<"Report", 'DateTime'>
    readonly deletedBy: FieldRef<"Report", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Report findUnique
   */
  export type ReportFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    /**
     * Filter, which Report to fetch.
     */
    where: ReportWhereUniqueInput
  }

  /**
   * Report findUniqueOrThrow
   */
  export type ReportFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    /**
     * Filter, which Report to fetch.
     */
    where: ReportWhereUniqueInput
  }

  /**
   * Report findFirst
   */
  export type ReportFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    /**
     * Filter, which Report to fetch.
     */
    where?: ReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reports to fetch.
     */
    orderBy?: ReportOrderByWithRelationInput | ReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Reports.
     */
    cursor?: ReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Reports.
     */
    distinct?: ReportScalarFieldEnum | ReportScalarFieldEnum[]
  }

  /**
   * Report findFirstOrThrow
   */
  export type ReportFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    /**
     * Filter, which Report to fetch.
     */
    where?: ReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reports to fetch.
     */
    orderBy?: ReportOrderByWithRelationInput | ReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Reports.
     */
    cursor?: ReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Reports.
     */
    distinct?: ReportScalarFieldEnum | ReportScalarFieldEnum[]
  }

  /**
   * Report findMany
   */
  export type ReportFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    /**
     * Filter, which Reports to fetch.
     */
    where?: ReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reports to fetch.
     */
    orderBy?: ReportOrderByWithRelationInput | ReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Reports.
     */
    cursor?: ReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reports.
     */
    skip?: number
    distinct?: ReportScalarFieldEnum | ReportScalarFieldEnum[]
  }

  /**
   * Report create
   */
  export type ReportCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    /**
     * The data needed to create a Report.
     */
    data: XOR<ReportCreateInput, ReportUncheckedCreateInput>
  }

  /**
   * Report createMany
   */
  export type ReportCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Reports.
     */
    data: ReportCreateManyInput | ReportCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Report update
   */
  export type ReportUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    /**
     * The data needed to update a Report.
     */
    data: XOR<ReportUpdateInput, ReportUncheckedUpdateInput>
    /**
     * Choose, which Report to update.
     */
    where: ReportWhereUniqueInput
  }

  /**
   * Report updateMany
   */
  export type ReportUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Reports.
     */
    data: XOR<ReportUpdateManyMutationInput, ReportUncheckedUpdateManyInput>
    /**
     * Filter which Reports to update
     */
    where?: ReportWhereInput
  }

  /**
   * Report upsert
   */
  export type ReportUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    /**
     * The filter to search for the Report to update in case it exists.
     */
    where: ReportWhereUniqueInput
    /**
     * In case the Report found by the `where` argument doesn't exist, create a new Report with this data.
     */
    create: XOR<ReportCreateInput, ReportUncheckedCreateInput>
    /**
     * In case the Report was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ReportUpdateInput, ReportUncheckedUpdateInput>
  }

  /**
   * Report delete
   */
  export type ReportDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    /**
     * Filter which Report to delete.
     */
    where: ReportWhereUniqueInput
  }

  /**
   * Report deleteMany
   */
  export type ReportDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Reports to delete
     */
    where?: ReportWhereInput
  }

  /**
   * Report.reportProcess
   */
  export type Report$reportProcessArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportProcess
     */
    select?: ReportProcessSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportProcessInclude<ExtArgs> | null
    where?: ReportProcessWhereInput
    orderBy?: ReportProcessOrderByWithRelationInput | ReportProcessOrderByWithRelationInput[]
    cursor?: ReportProcessWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReportProcessScalarFieldEnum | ReportProcessScalarFieldEnum[]
  }

  /**
   * Report without action
   */
  export type ReportDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
  }


  /**
   * Model ReportProcess
   */

  export type AggregateReportProcess = {
    _count: ReportProcessCountAggregateOutputType | null
    _avg: ReportProcessAvgAggregateOutputType | null
    _sum: ReportProcessSumAggregateOutputType | null
    _min: ReportProcessMinAggregateOutputType | null
    _max: ReportProcessMaxAggregateOutputType | null
  }

  export type ReportProcessAvgAggregateOutputType = {
    id: number | null
    reportId: number | null
    amountday: number | null
  }

  export type ReportProcessSumAggregateOutputType = {
    id: number | null
    reportId: number | null
    amountday: number | null
  }

  export type ReportProcessMinAggregateOutputType = {
    id: number | null
    reportId: number | null
    processNo: string | null
    amountday: number | null
  }

  export type ReportProcessMaxAggregateOutputType = {
    id: number | null
    reportId: number | null
    processNo: string | null
    amountday: number | null
  }

  export type ReportProcessCountAggregateOutputType = {
    id: number
    reportId: number
    processNo: number
    amountday: number
    _all: number
  }


  export type ReportProcessAvgAggregateInputType = {
    id?: true
    reportId?: true
    amountday?: true
  }

  export type ReportProcessSumAggregateInputType = {
    id?: true
    reportId?: true
    amountday?: true
  }

  export type ReportProcessMinAggregateInputType = {
    id?: true
    reportId?: true
    processNo?: true
    amountday?: true
  }

  export type ReportProcessMaxAggregateInputType = {
    id?: true
    reportId?: true
    processNo?: true
    amountday?: true
  }

  export type ReportProcessCountAggregateInputType = {
    id?: true
    reportId?: true
    processNo?: true
    amountday?: true
    _all?: true
  }

  export type ReportProcessAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ReportProcess to aggregate.
     */
    where?: ReportProcessWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReportProcesses to fetch.
     */
    orderBy?: ReportProcessOrderByWithRelationInput | ReportProcessOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ReportProcessWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReportProcesses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReportProcesses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ReportProcesses
    **/
    _count?: true | ReportProcessCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ReportProcessAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ReportProcessSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReportProcessMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReportProcessMaxAggregateInputType
  }

  export type GetReportProcessAggregateType<T extends ReportProcessAggregateArgs> = {
        [P in keyof T & keyof AggregateReportProcess]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReportProcess[P]>
      : GetScalarType<T[P], AggregateReportProcess[P]>
  }




  export type ReportProcessGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReportProcessWhereInput
    orderBy?: ReportProcessOrderByWithAggregationInput | ReportProcessOrderByWithAggregationInput[]
    by: ReportProcessScalarFieldEnum[] | ReportProcessScalarFieldEnum
    having?: ReportProcessScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReportProcessCountAggregateInputType | true
    _avg?: ReportProcessAvgAggregateInputType
    _sum?: ReportProcessSumAggregateInputType
    _min?: ReportProcessMinAggregateInputType
    _max?: ReportProcessMaxAggregateInputType
  }

  export type ReportProcessGroupByOutputType = {
    id: number
    reportId: number
    processNo: string
    amountday: number
    _count: ReportProcessCountAggregateOutputType | null
    _avg: ReportProcessAvgAggregateOutputType | null
    _sum: ReportProcessSumAggregateOutputType | null
    _min: ReportProcessMinAggregateOutputType | null
    _max: ReportProcessMaxAggregateOutputType | null
  }

  type GetReportProcessGroupByPayload<T extends ReportProcessGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReportProcessGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReportProcessGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReportProcessGroupByOutputType[P]>
            : GetScalarType<T[P], ReportProcessGroupByOutputType[P]>
        }
      >
    >


  export type ReportProcessSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    reportId?: boolean
    processNo?: boolean
    amountday?: boolean
    report?: boolean | ReportDefaultArgs<ExtArgs>
    reportStock?: boolean | ReportProcess$reportStockArgs<ExtArgs>
    _count?: boolean | ReportProcessCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["reportProcess"]>


  export type ReportProcessSelectScalar = {
    id?: boolean
    reportId?: boolean
    processNo?: boolean
    amountday?: boolean
  }

  export type ReportProcessInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    report?: boolean | ReportDefaultArgs<ExtArgs>
    reportStock?: boolean | ReportProcess$reportStockArgs<ExtArgs>
    _count?: boolean | ReportProcessCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $ReportProcessPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ReportProcess"
    objects: {
      report: Prisma.$ReportPayload<ExtArgs>
      reportStock: Prisma.$ReportStockPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      reportId: number
      processNo: string
      amountday: number
    }, ExtArgs["result"]["reportProcess"]>
    composites: {}
  }

  type ReportProcessGetPayload<S extends boolean | null | undefined | ReportProcessDefaultArgs> = $Result.GetResult<Prisma.$ReportProcessPayload, S>

  type ReportProcessCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ReportProcessFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ReportProcessCountAggregateInputType | true
    }

  export interface ReportProcessDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ReportProcess'], meta: { name: 'ReportProcess' } }
    /**
     * Find zero or one ReportProcess that matches the filter.
     * @param {ReportProcessFindUniqueArgs} args - Arguments to find a ReportProcess
     * @example
     * // Get one ReportProcess
     * const reportProcess = await prisma.reportProcess.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ReportProcessFindUniqueArgs>(args: SelectSubset<T, ReportProcessFindUniqueArgs<ExtArgs>>): Prisma__ReportProcessClient<$Result.GetResult<Prisma.$ReportProcessPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ReportProcess that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ReportProcessFindUniqueOrThrowArgs} args - Arguments to find a ReportProcess
     * @example
     * // Get one ReportProcess
     * const reportProcess = await prisma.reportProcess.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ReportProcessFindUniqueOrThrowArgs>(args: SelectSubset<T, ReportProcessFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ReportProcessClient<$Result.GetResult<Prisma.$ReportProcessPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ReportProcess that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportProcessFindFirstArgs} args - Arguments to find a ReportProcess
     * @example
     * // Get one ReportProcess
     * const reportProcess = await prisma.reportProcess.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ReportProcessFindFirstArgs>(args?: SelectSubset<T, ReportProcessFindFirstArgs<ExtArgs>>): Prisma__ReportProcessClient<$Result.GetResult<Prisma.$ReportProcessPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ReportProcess that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportProcessFindFirstOrThrowArgs} args - Arguments to find a ReportProcess
     * @example
     * // Get one ReportProcess
     * const reportProcess = await prisma.reportProcess.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ReportProcessFindFirstOrThrowArgs>(args?: SelectSubset<T, ReportProcessFindFirstOrThrowArgs<ExtArgs>>): Prisma__ReportProcessClient<$Result.GetResult<Prisma.$ReportProcessPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ReportProcesses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportProcessFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ReportProcesses
     * const reportProcesses = await prisma.reportProcess.findMany()
     * 
     * // Get first 10 ReportProcesses
     * const reportProcesses = await prisma.reportProcess.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const reportProcessWithIdOnly = await prisma.reportProcess.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ReportProcessFindManyArgs>(args?: SelectSubset<T, ReportProcessFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReportProcessPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ReportProcess.
     * @param {ReportProcessCreateArgs} args - Arguments to create a ReportProcess.
     * @example
     * // Create one ReportProcess
     * const ReportProcess = await prisma.reportProcess.create({
     *   data: {
     *     // ... data to create a ReportProcess
     *   }
     * })
     * 
     */
    create<T extends ReportProcessCreateArgs>(args: SelectSubset<T, ReportProcessCreateArgs<ExtArgs>>): Prisma__ReportProcessClient<$Result.GetResult<Prisma.$ReportProcessPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ReportProcesses.
     * @param {ReportProcessCreateManyArgs} args - Arguments to create many ReportProcesses.
     * @example
     * // Create many ReportProcesses
     * const reportProcess = await prisma.reportProcess.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ReportProcessCreateManyArgs>(args?: SelectSubset<T, ReportProcessCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ReportProcess.
     * @param {ReportProcessDeleteArgs} args - Arguments to delete one ReportProcess.
     * @example
     * // Delete one ReportProcess
     * const ReportProcess = await prisma.reportProcess.delete({
     *   where: {
     *     // ... filter to delete one ReportProcess
     *   }
     * })
     * 
     */
    delete<T extends ReportProcessDeleteArgs>(args: SelectSubset<T, ReportProcessDeleteArgs<ExtArgs>>): Prisma__ReportProcessClient<$Result.GetResult<Prisma.$ReportProcessPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ReportProcess.
     * @param {ReportProcessUpdateArgs} args - Arguments to update one ReportProcess.
     * @example
     * // Update one ReportProcess
     * const reportProcess = await prisma.reportProcess.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ReportProcessUpdateArgs>(args: SelectSubset<T, ReportProcessUpdateArgs<ExtArgs>>): Prisma__ReportProcessClient<$Result.GetResult<Prisma.$ReportProcessPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ReportProcesses.
     * @param {ReportProcessDeleteManyArgs} args - Arguments to filter ReportProcesses to delete.
     * @example
     * // Delete a few ReportProcesses
     * const { count } = await prisma.reportProcess.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ReportProcessDeleteManyArgs>(args?: SelectSubset<T, ReportProcessDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ReportProcesses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportProcessUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ReportProcesses
     * const reportProcess = await prisma.reportProcess.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ReportProcessUpdateManyArgs>(args: SelectSubset<T, ReportProcessUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ReportProcess.
     * @param {ReportProcessUpsertArgs} args - Arguments to update or create a ReportProcess.
     * @example
     * // Update or create a ReportProcess
     * const reportProcess = await prisma.reportProcess.upsert({
     *   create: {
     *     // ... data to create a ReportProcess
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ReportProcess we want to update
     *   }
     * })
     */
    upsert<T extends ReportProcessUpsertArgs>(args: SelectSubset<T, ReportProcessUpsertArgs<ExtArgs>>): Prisma__ReportProcessClient<$Result.GetResult<Prisma.$ReportProcessPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ReportProcesses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportProcessCountArgs} args - Arguments to filter ReportProcesses to count.
     * @example
     * // Count the number of ReportProcesses
     * const count = await prisma.reportProcess.count({
     *   where: {
     *     // ... the filter for the ReportProcesses we want to count
     *   }
     * })
    **/
    count<T extends ReportProcessCountArgs>(
      args?: Subset<T, ReportProcessCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReportProcessCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ReportProcess.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportProcessAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReportProcessAggregateArgs>(args: Subset<T, ReportProcessAggregateArgs>): Prisma.PrismaPromise<GetReportProcessAggregateType<T>>

    /**
     * Group by ReportProcess.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportProcessGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReportProcessGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReportProcessGroupByArgs['orderBy'] }
        : { orderBy?: ReportProcessGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReportProcessGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReportProcessGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ReportProcess model
   */
  readonly fields: ReportProcessFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ReportProcess.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ReportProcessClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    report<T extends ReportDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ReportDefaultArgs<ExtArgs>>): Prisma__ReportClient<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    reportStock<T extends ReportProcess$reportStockArgs<ExtArgs> = {}>(args?: Subset<T, ReportProcess$reportStockArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReportStockPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ReportProcess model
   */ 
  interface ReportProcessFieldRefs {
    readonly id: FieldRef<"ReportProcess", 'Int'>
    readonly reportId: FieldRef<"ReportProcess", 'Int'>
    readonly processNo: FieldRef<"ReportProcess", 'String'>
    readonly amountday: FieldRef<"ReportProcess", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * ReportProcess findUnique
   */
  export type ReportProcessFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportProcess
     */
    select?: ReportProcessSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportProcessInclude<ExtArgs> | null
    /**
     * Filter, which ReportProcess to fetch.
     */
    where: ReportProcessWhereUniqueInput
  }

  /**
   * ReportProcess findUniqueOrThrow
   */
  export type ReportProcessFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportProcess
     */
    select?: ReportProcessSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportProcessInclude<ExtArgs> | null
    /**
     * Filter, which ReportProcess to fetch.
     */
    where: ReportProcessWhereUniqueInput
  }

  /**
   * ReportProcess findFirst
   */
  export type ReportProcessFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportProcess
     */
    select?: ReportProcessSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportProcessInclude<ExtArgs> | null
    /**
     * Filter, which ReportProcess to fetch.
     */
    where?: ReportProcessWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReportProcesses to fetch.
     */
    orderBy?: ReportProcessOrderByWithRelationInput | ReportProcessOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ReportProcesses.
     */
    cursor?: ReportProcessWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReportProcesses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReportProcesses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ReportProcesses.
     */
    distinct?: ReportProcessScalarFieldEnum | ReportProcessScalarFieldEnum[]
  }

  /**
   * ReportProcess findFirstOrThrow
   */
  export type ReportProcessFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportProcess
     */
    select?: ReportProcessSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportProcessInclude<ExtArgs> | null
    /**
     * Filter, which ReportProcess to fetch.
     */
    where?: ReportProcessWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReportProcesses to fetch.
     */
    orderBy?: ReportProcessOrderByWithRelationInput | ReportProcessOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ReportProcesses.
     */
    cursor?: ReportProcessWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReportProcesses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReportProcesses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ReportProcesses.
     */
    distinct?: ReportProcessScalarFieldEnum | ReportProcessScalarFieldEnum[]
  }

  /**
   * ReportProcess findMany
   */
  export type ReportProcessFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportProcess
     */
    select?: ReportProcessSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportProcessInclude<ExtArgs> | null
    /**
     * Filter, which ReportProcesses to fetch.
     */
    where?: ReportProcessWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReportProcesses to fetch.
     */
    orderBy?: ReportProcessOrderByWithRelationInput | ReportProcessOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ReportProcesses.
     */
    cursor?: ReportProcessWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReportProcesses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReportProcesses.
     */
    skip?: number
    distinct?: ReportProcessScalarFieldEnum | ReportProcessScalarFieldEnum[]
  }

  /**
   * ReportProcess create
   */
  export type ReportProcessCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportProcess
     */
    select?: ReportProcessSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportProcessInclude<ExtArgs> | null
    /**
     * The data needed to create a ReportProcess.
     */
    data: XOR<ReportProcessCreateInput, ReportProcessUncheckedCreateInput>
  }

  /**
   * ReportProcess createMany
   */
  export type ReportProcessCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ReportProcesses.
     */
    data: ReportProcessCreateManyInput | ReportProcessCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ReportProcess update
   */
  export type ReportProcessUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportProcess
     */
    select?: ReportProcessSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportProcessInclude<ExtArgs> | null
    /**
     * The data needed to update a ReportProcess.
     */
    data: XOR<ReportProcessUpdateInput, ReportProcessUncheckedUpdateInput>
    /**
     * Choose, which ReportProcess to update.
     */
    where: ReportProcessWhereUniqueInput
  }

  /**
   * ReportProcess updateMany
   */
  export type ReportProcessUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ReportProcesses.
     */
    data: XOR<ReportProcessUpdateManyMutationInput, ReportProcessUncheckedUpdateManyInput>
    /**
     * Filter which ReportProcesses to update
     */
    where?: ReportProcessWhereInput
  }

  /**
   * ReportProcess upsert
   */
  export type ReportProcessUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportProcess
     */
    select?: ReportProcessSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportProcessInclude<ExtArgs> | null
    /**
     * The filter to search for the ReportProcess to update in case it exists.
     */
    where: ReportProcessWhereUniqueInput
    /**
     * In case the ReportProcess found by the `where` argument doesn't exist, create a new ReportProcess with this data.
     */
    create: XOR<ReportProcessCreateInput, ReportProcessUncheckedCreateInput>
    /**
     * In case the ReportProcess was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ReportProcessUpdateInput, ReportProcessUncheckedUpdateInput>
  }

  /**
   * ReportProcess delete
   */
  export type ReportProcessDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportProcess
     */
    select?: ReportProcessSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportProcessInclude<ExtArgs> | null
    /**
     * Filter which ReportProcess to delete.
     */
    where: ReportProcessWhereUniqueInput
  }

  /**
   * ReportProcess deleteMany
   */
  export type ReportProcessDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ReportProcesses to delete
     */
    where?: ReportProcessWhereInput
  }

  /**
   * ReportProcess.reportStock
   */
  export type ReportProcess$reportStockArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportStock
     */
    select?: ReportStockSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportStockInclude<ExtArgs> | null
    where?: ReportStockWhereInput
    orderBy?: ReportStockOrderByWithRelationInput | ReportStockOrderByWithRelationInput[]
    cursor?: ReportStockWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReportStockScalarFieldEnum | ReportStockScalarFieldEnum[]
  }

  /**
   * ReportProcess without action
   */
  export type ReportProcessDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportProcess
     */
    select?: ReportProcessSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportProcessInclude<ExtArgs> | null
  }


  /**
   * Model ReportStock
   */

  export type AggregateReportStock = {
    _count: ReportStockCountAggregateOutputType | null
    _avg: ReportStockAvgAggregateOutputType | null
    _sum: ReportStockSumAggregateOutputType | null
    _min: ReportStockMinAggregateOutputType | null
    _max: ReportStockMaxAggregateOutputType | null
  }

  export type ReportStockAvgAggregateOutputType = {
    id: number | null
    reportProcessId: number | null
    stockamount: number | null
    stocktype: number | null
  }

  export type ReportStockSumAggregateOutputType = {
    id: number | null
    reportProcessId: number | null
    stockamount: number | null
    stocktype: number | null
  }

  export type ReportStockMinAggregateOutputType = {
    id: number | null
    reportProcessId: number | null
    stockId: string | null
    stockamount: number | null
    stocktype: number | null
  }

  export type ReportStockMaxAggregateOutputType = {
    id: number | null
    reportProcessId: number | null
    stockId: string | null
    stockamount: number | null
    stocktype: number | null
  }

  export type ReportStockCountAggregateOutputType = {
    id: number
    reportProcessId: number
    stockId: number
    stockamount: number
    stocktype: number
    _all: number
  }


  export type ReportStockAvgAggregateInputType = {
    id?: true
    reportProcessId?: true
    stockamount?: true
    stocktype?: true
  }

  export type ReportStockSumAggregateInputType = {
    id?: true
    reportProcessId?: true
    stockamount?: true
    stocktype?: true
  }

  export type ReportStockMinAggregateInputType = {
    id?: true
    reportProcessId?: true
    stockId?: true
    stockamount?: true
    stocktype?: true
  }

  export type ReportStockMaxAggregateInputType = {
    id?: true
    reportProcessId?: true
    stockId?: true
    stockamount?: true
    stocktype?: true
  }

  export type ReportStockCountAggregateInputType = {
    id?: true
    reportProcessId?: true
    stockId?: true
    stockamount?: true
    stocktype?: true
    _all?: true
  }

  export type ReportStockAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ReportStock to aggregate.
     */
    where?: ReportStockWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReportStocks to fetch.
     */
    orderBy?: ReportStockOrderByWithRelationInput | ReportStockOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ReportStockWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReportStocks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReportStocks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ReportStocks
    **/
    _count?: true | ReportStockCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ReportStockAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ReportStockSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReportStockMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReportStockMaxAggregateInputType
  }

  export type GetReportStockAggregateType<T extends ReportStockAggregateArgs> = {
        [P in keyof T & keyof AggregateReportStock]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReportStock[P]>
      : GetScalarType<T[P], AggregateReportStock[P]>
  }




  export type ReportStockGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReportStockWhereInput
    orderBy?: ReportStockOrderByWithAggregationInput | ReportStockOrderByWithAggregationInput[]
    by: ReportStockScalarFieldEnum[] | ReportStockScalarFieldEnum
    having?: ReportStockScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReportStockCountAggregateInputType | true
    _avg?: ReportStockAvgAggregateInputType
    _sum?: ReportStockSumAggregateInputType
    _min?: ReportStockMinAggregateInputType
    _max?: ReportStockMaxAggregateInputType
  }

  export type ReportStockGroupByOutputType = {
    id: number
    reportProcessId: number
    stockId: string
    stockamount: number
    stocktype: number
    _count: ReportStockCountAggregateOutputType | null
    _avg: ReportStockAvgAggregateOutputType | null
    _sum: ReportStockSumAggregateOutputType | null
    _min: ReportStockMinAggregateOutputType | null
    _max: ReportStockMaxAggregateOutputType | null
  }

  type GetReportStockGroupByPayload<T extends ReportStockGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReportStockGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReportStockGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReportStockGroupByOutputType[P]>
            : GetScalarType<T[P], ReportStockGroupByOutputType[P]>
        }
      >
    >


  export type ReportStockSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    reportProcessId?: boolean
    stockId?: boolean
    stockamount?: boolean
    stocktype?: boolean
    reportProcess?: boolean | ReportProcessDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["reportStock"]>


  export type ReportStockSelectScalar = {
    id?: boolean
    reportProcessId?: boolean
    stockId?: boolean
    stockamount?: boolean
    stocktype?: boolean
  }

  export type ReportStockInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    reportProcess?: boolean | ReportProcessDefaultArgs<ExtArgs>
  }

  export type $ReportStockPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ReportStock"
    objects: {
      reportProcess: Prisma.$ReportProcessPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      reportProcessId: number
      stockId: string
      stockamount: number
      stocktype: number
    }, ExtArgs["result"]["reportStock"]>
    composites: {}
  }

  type ReportStockGetPayload<S extends boolean | null | undefined | ReportStockDefaultArgs> = $Result.GetResult<Prisma.$ReportStockPayload, S>

  type ReportStockCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ReportStockFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ReportStockCountAggregateInputType | true
    }

  export interface ReportStockDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ReportStock'], meta: { name: 'ReportStock' } }
    /**
     * Find zero or one ReportStock that matches the filter.
     * @param {ReportStockFindUniqueArgs} args - Arguments to find a ReportStock
     * @example
     * // Get one ReportStock
     * const reportStock = await prisma.reportStock.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ReportStockFindUniqueArgs>(args: SelectSubset<T, ReportStockFindUniqueArgs<ExtArgs>>): Prisma__ReportStockClient<$Result.GetResult<Prisma.$ReportStockPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ReportStock that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ReportStockFindUniqueOrThrowArgs} args - Arguments to find a ReportStock
     * @example
     * // Get one ReportStock
     * const reportStock = await prisma.reportStock.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ReportStockFindUniqueOrThrowArgs>(args: SelectSubset<T, ReportStockFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ReportStockClient<$Result.GetResult<Prisma.$ReportStockPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ReportStock that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportStockFindFirstArgs} args - Arguments to find a ReportStock
     * @example
     * // Get one ReportStock
     * const reportStock = await prisma.reportStock.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ReportStockFindFirstArgs>(args?: SelectSubset<T, ReportStockFindFirstArgs<ExtArgs>>): Prisma__ReportStockClient<$Result.GetResult<Prisma.$ReportStockPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ReportStock that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportStockFindFirstOrThrowArgs} args - Arguments to find a ReportStock
     * @example
     * // Get one ReportStock
     * const reportStock = await prisma.reportStock.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ReportStockFindFirstOrThrowArgs>(args?: SelectSubset<T, ReportStockFindFirstOrThrowArgs<ExtArgs>>): Prisma__ReportStockClient<$Result.GetResult<Prisma.$ReportStockPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ReportStocks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportStockFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ReportStocks
     * const reportStocks = await prisma.reportStock.findMany()
     * 
     * // Get first 10 ReportStocks
     * const reportStocks = await prisma.reportStock.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const reportStockWithIdOnly = await prisma.reportStock.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ReportStockFindManyArgs>(args?: SelectSubset<T, ReportStockFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReportStockPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ReportStock.
     * @param {ReportStockCreateArgs} args - Arguments to create a ReportStock.
     * @example
     * // Create one ReportStock
     * const ReportStock = await prisma.reportStock.create({
     *   data: {
     *     // ... data to create a ReportStock
     *   }
     * })
     * 
     */
    create<T extends ReportStockCreateArgs>(args: SelectSubset<T, ReportStockCreateArgs<ExtArgs>>): Prisma__ReportStockClient<$Result.GetResult<Prisma.$ReportStockPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ReportStocks.
     * @param {ReportStockCreateManyArgs} args - Arguments to create many ReportStocks.
     * @example
     * // Create many ReportStocks
     * const reportStock = await prisma.reportStock.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ReportStockCreateManyArgs>(args?: SelectSubset<T, ReportStockCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ReportStock.
     * @param {ReportStockDeleteArgs} args - Arguments to delete one ReportStock.
     * @example
     * // Delete one ReportStock
     * const ReportStock = await prisma.reportStock.delete({
     *   where: {
     *     // ... filter to delete one ReportStock
     *   }
     * })
     * 
     */
    delete<T extends ReportStockDeleteArgs>(args: SelectSubset<T, ReportStockDeleteArgs<ExtArgs>>): Prisma__ReportStockClient<$Result.GetResult<Prisma.$ReportStockPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ReportStock.
     * @param {ReportStockUpdateArgs} args - Arguments to update one ReportStock.
     * @example
     * // Update one ReportStock
     * const reportStock = await prisma.reportStock.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ReportStockUpdateArgs>(args: SelectSubset<T, ReportStockUpdateArgs<ExtArgs>>): Prisma__ReportStockClient<$Result.GetResult<Prisma.$ReportStockPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ReportStocks.
     * @param {ReportStockDeleteManyArgs} args - Arguments to filter ReportStocks to delete.
     * @example
     * // Delete a few ReportStocks
     * const { count } = await prisma.reportStock.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ReportStockDeleteManyArgs>(args?: SelectSubset<T, ReportStockDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ReportStocks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportStockUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ReportStocks
     * const reportStock = await prisma.reportStock.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ReportStockUpdateManyArgs>(args: SelectSubset<T, ReportStockUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ReportStock.
     * @param {ReportStockUpsertArgs} args - Arguments to update or create a ReportStock.
     * @example
     * // Update or create a ReportStock
     * const reportStock = await prisma.reportStock.upsert({
     *   create: {
     *     // ... data to create a ReportStock
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ReportStock we want to update
     *   }
     * })
     */
    upsert<T extends ReportStockUpsertArgs>(args: SelectSubset<T, ReportStockUpsertArgs<ExtArgs>>): Prisma__ReportStockClient<$Result.GetResult<Prisma.$ReportStockPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ReportStocks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportStockCountArgs} args - Arguments to filter ReportStocks to count.
     * @example
     * // Count the number of ReportStocks
     * const count = await prisma.reportStock.count({
     *   where: {
     *     // ... the filter for the ReportStocks we want to count
     *   }
     * })
    **/
    count<T extends ReportStockCountArgs>(
      args?: Subset<T, ReportStockCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReportStockCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ReportStock.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportStockAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReportStockAggregateArgs>(args: Subset<T, ReportStockAggregateArgs>): Prisma.PrismaPromise<GetReportStockAggregateType<T>>

    /**
     * Group by ReportStock.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportStockGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReportStockGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReportStockGroupByArgs['orderBy'] }
        : { orderBy?: ReportStockGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReportStockGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReportStockGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ReportStock model
   */
  readonly fields: ReportStockFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ReportStock.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ReportStockClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    reportProcess<T extends ReportProcessDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ReportProcessDefaultArgs<ExtArgs>>): Prisma__ReportProcessClient<$Result.GetResult<Prisma.$ReportProcessPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ReportStock model
   */ 
  interface ReportStockFieldRefs {
    readonly id: FieldRef<"ReportStock", 'Int'>
    readonly reportProcessId: FieldRef<"ReportStock", 'Int'>
    readonly stockId: FieldRef<"ReportStock", 'String'>
    readonly stockamount: FieldRef<"ReportStock", 'Int'>
    readonly stocktype: FieldRef<"ReportStock", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * ReportStock findUnique
   */
  export type ReportStockFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportStock
     */
    select?: ReportStockSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportStockInclude<ExtArgs> | null
    /**
     * Filter, which ReportStock to fetch.
     */
    where: ReportStockWhereUniqueInput
  }

  /**
   * ReportStock findUniqueOrThrow
   */
  export type ReportStockFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportStock
     */
    select?: ReportStockSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportStockInclude<ExtArgs> | null
    /**
     * Filter, which ReportStock to fetch.
     */
    where: ReportStockWhereUniqueInput
  }

  /**
   * ReportStock findFirst
   */
  export type ReportStockFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportStock
     */
    select?: ReportStockSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportStockInclude<ExtArgs> | null
    /**
     * Filter, which ReportStock to fetch.
     */
    where?: ReportStockWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReportStocks to fetch.
     */
    orderBy?: ReportStockOrderByWithRelationInput | ReportStockOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ReportStocks.
     */
    cursor?: ReportStockWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReportStocks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReportStocks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ReportStocks.
     */
    distinct?: ReportStockScalarFieldEnum | ReportStockScalarFieldEnum[]
  }

  /**
   * ReportStock findFirstOrThrow
   */
  export type ReportStockFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportStock
     */
    select?: ReportStockSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportStockInclude<ExtArgs> | null
    /**
     * Filter, which ReportStock to fetch.
     */
    where?: ReportStockWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReportStocks to fetch.
     */
    orderBy?: ReportStockOrderByWithRelationInput | ReportStockOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ReportStocks.
     */
    cursor?: ReportStockWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReportStocks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReportStocks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ReportStocks.
     */
    distinct?: ReportStockScalarFieldEnum | ReportStockScalarFieldEnum[]
  }

  /**
   * ReportStock findMany
   */
  export type ReportStockFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportStock
     */
    select?: ReportStockSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportStockInclude<ExtArgs> | null
    /**
     * Filter, which ReportStocks to fetch.
     */
    where?: ReportStockWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReportStocks to fetch.
     */
    orderBy?: ReportStockOrderByWithRelationInput | ReportStockOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ReportStocks.
     */
    cursor?: ReportStockWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReportStocks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReportStocks.
     */
    skip?: number
    distinct?: ReportStockScalarFieldEnum | ReportStockScalarFieldEnum[]
  }

  /**
   * ReportStock create
   */
  export type ReportStockCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportStock
     */
    select?: ReportStockSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportStockInclude<ExtArgs> | null
    /**
     * The data needed to create a ReportStock.
     */
    data: XOR<ReportStockCreateInput, ReportStockUncheckedCreateInput>
  }

  /**
   * ReportStock createMany
   */
  export type ReportStockCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ReportStocks.
     */
    data: ReportStockCreateManyInput | ReportStockCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ReportStock update
   */
  export type ReportStockUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportStock
     */
    select?: ReportStockSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportStockInclude<ExtArgs> | null
    /**
     * The data needed to update a ReportStock.
     */
    data: XOR<ReportStockUpdateInput, ReportStockUncheckedUpdateInput>
    /**
     * Choose, which ReportStock to update.
     */
    where: ReportStockWhereUniqueInput
  }

  /**
   * ReportStock updateMany
   */
  export type ReportStockUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ReportStocks.
     */
    data: XOR<ReportStockUpdateManyMutationInput, ReportStockUncheckedUpdateManyInput>
    /**
     * Filter which ReportStocks to update
     */
    where?: ReportStockWhereInput
  }

  /**
   * ReportStock upsert
   */
  export type ReportStockUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportStock
     */
    select?: ReportStockSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportStockInclude<ExtArgs> | null
    /**
     * The filter to search for the ReportStock to update in case it exists.
     */
    where: ReportStockWhereUniqueInput
    /**
     * In case the ReportStock found by the `where` argument doesn't exist, create a new ReportStock with this data.
     */
    create: XOR<ReportStockCreateInput, ReportStockUncheckedCreateInput>
    /**
     * In case the ReportStock was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ReportStockUpdateInput, ReportStockUncheckedUpdateInput>
  }

  /**
   * ReportStock delete
   */
  export type ReportStockDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportStock
     */
    select?: ReportStockSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportStockInclude<ExtArgs> | null
    /**
     * Filter which ReportStock to delete.
     */
    where: ReportStockWhereUniqueInput
  }

  /**
   * ReportStock deleteMany
   */
  export type ReportStockDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ReportStocks to delete
     */
    where?: ReportStockWhereInput
  }

  /**
   * ReportStock without action
   */
  export type ReportStockDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportStock
     */
    select?: ReportStockSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportStockInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    firstName: 'firstName',
    lastName: 'lastName',
    password: 'password',
    companyId: 'companyId',
    companyBranchId: 'companyBranchId',
    departmentId: 'departmentId',
    role: 'role',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const CompanyScalarFieldEnum: {
    id: 'id',
    companyName: 'companyName',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt'
  };

  export type CompanyScalarFieldEnum = (typeof CompanyScalarFieldEnum)[keyof typeof CompanyScalarFieldEnum]


  export const CompanyBranchScalarFieldEnum: {
    id: 'id',
    companyId: 'companyId',
    companyBranchName: 'companyBranchName'
  };

  export type CompanyBranchScalarFieldEnum = (typeof CompanyBranchScalarFieldEnum)[keyof typeof CompanyBranchScalarFieldEnum]


  export const DepartmentScalarFieldEnum: {
    id: 'id',
    departmentName: 'departmentName',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt'
  };

  export type DepartmentScalarFieldEnum = (typeof DepartmentScalarFieldEnum)[keyof typeof DepartmentScalarFieldEnum]


  export const CourseScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    pdfUrl: 'pdfUrl',
    videoUrl: 'videoUrl',
    typeId: 'typeId',
    template: 'template',
    departmentId: 'departmentId',
    processId: 'processId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    createdBy: 'createdBy',
    deletedBy: 'deletedBy',
    isDeleted: 'isDeleted'
  };

  export type CourseScalarFieldEnum = (typeof CourseScalarFieldEnum)[keyof typeof CourseScalarFieldEnum]


  export const UserCourseCompletionScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    username: 'username',
    courseId: 'courseId',
    examId: 'examId',
    processId: 'processId',
    completedAt: 'completedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserCourseCompletionScalarFieldEnum = (typeof UserCourseCompletionScalarFieldEnum)[keyof typeof UserCourseCompletionScalarFieldEnum]


  export const CourseTypeScalarFieldEnum: {
    id: 'id',
    title: 'title'
  };

  export type CourseTypeScalarFieldEnum = (typeof CourseTypeScalarFieldEnum)[keyof typeof CourseTypeScalarFieldEnum]


  export const EnrollmentScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    courseId: 'courseId',
    progress: 'progress',
    completed: 'completed',
    isDownloaded: 'isDownloaded'
  };

  export type EnrollmentScalarFieldEnum = (typeof EnrollmentScalarFieldEnum)[keyof typeof EnrollmentScalarFieldEnum]


  export const ExamScalarFieldEnum: {
    id: 'id',
    title: 'title',
    departmentId: 'departmentId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    courseId: 'courseId',
    description: 'description',
    deleted: 'deleted'
  };

  export type ExamScalarFieldEnum = (typeof ExamScalarFieldEnum)[keyof typeof ExamScalarFieldEnum]


  export const QuestionScalarFieldEnum: {
    id: 'id',
    examId: 'examId',
    text: 'text',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deleted: 'deleted'
  };

  export type QuestionScalarFieldEnum = (typeof QuestionScalarFieldEnum)[keyof typeof QuestionScalarFieldEnum]


  export const ChoiceScalarFieldEnum: {
    id: 'id',
    questionId: 'questionId',
    text: 'text',
    correct: 'correct',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deleted: 'deleted'
  };

  export type ChoiceScalarFieldEnum = (typeof ChoiceScalarFieldEnum)[keyof typeof ChoiceScalarFieldEnum]


  export const ExamAttemptScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    examId: 'examId',
    startedAt: 'startedAt',
    endedAt: 'endedAt',
    grade: 'grade',
    isPassed: 'isPassed'
  };

  export type ExamAttemptScalarFieldEnum = (typeof ExamAttemptScalarFieldEnum)[keyof typeof ExamAttemptScalarFieldEnum]


  export const UserAnswerScalarFieldEnum: {
    id: 'id',
    examAttemptId: 'examAttemptId',
    questionId: 'questionId',
    selectedChoiceId: 'selectedChoiceId',
    isCorrect: 'isCorrect',
    createdAt: 'createdAt'
  };

  export type UserAnswerScalarFieldEnum = (typeof UserAnswerScalarFieldEnum)[keyof typeof UserAnswerScalarFieldEnum]


  export const OplDocumentScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    fileName: 'fileName',
    fileType: 'fileType',
    filePath: 'filePath',
    template: 'template',
    createdAt: 'createdAt',
    uploadedBy: 'uploadedBy',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt'
  };

  export type OplDocumentScalarFieldEnum = (typeof OplDocumentScalarFieldEnum)[keyof typeof OplDocumentScalarFieldEnum]


  export const FileScalarFieldEnum: {
    id: 'id',
    originalName: 'originalName',
    storedName: 'storedName',
    fileType: 'fileType',
    fileSize: 'fileSize',
    filePath: 'filePath',
    uploadDate: 'uploadDate',
    userId: 'userId',
    courseId: 'courseId'
  };

  export type FileScalarFieldEnum = (typeof FileScalarFieldEnum)[keyof typeof FileScalarFieldEnum]


  export const ProcessScalarFieldEnum: {
    id: 'id',
    pc_bluePrintNo: 'pc_bluePrintNo',
    pc_imageBluePrint: 'pc_imageBluePrint',
    pc_totalProcess: 'pc_totalProcess',
    pc_userId: 'pc_userId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt'
  };

  export type ProcessScalarFieldEnum = (typeof ProcessScalarFieldEnum)[keyof typeof ProcessScalarFieldEnum]


  export const ProcessDetailScalarFieldEnum: {
    id: 'id',
    pc_bluePrintNo: 'pc_bluePrintNo',
    pc_processTitle: 'pc_processTitle',
    pc_amountDay: 'pc_amountDay',
    pc_reasonType: 'pc_reasonType'
  };

  export type ProcessDetailScalarFieldEnum = (typeof ProcessDetailScalarFieldEnum)[keyof typeof ProcessDetailScalarFieldEnum]


  export const ProcessBranchScalarFieldEnum: {
    id: 'id',
    pc_processDetailId: 'pc_processDetailId',
    pc_remark: 'pc_remark'
  };

  export type ProcessBranchScalarFieldEnum = (typeof ProcessBranchScalarFieldEnum)[keyof typeof ProcessBranchScalarFieldEnum]


  export const ProcessMatScalarFieldEnum: {
    id: 'id',
    pc_processDetailId: 'pc_processDetailId',
    pc_matId: 'pc_matId',
    pc_matamount: 'pc_matamount'
  };

  export type ProcessMatScalarFieldEnum = (typeof ProcessMatScalarFieldEnum)[keyof typeof ProcessMatScalarFieldEnum]


  export const ProcessBomScalarFieldEnum: {
    id: 'id',
    pc_processDetailId: 'pc_processDetailId',
    pc_bomId: 'pc_bomId',
    pc_bomamount: 'pc_bomamount'
  };

  export type ProcessBomScalarFieldEnum = (typeof ProcessBomScalarFieldEnum)[keyof typeof ProcessBomScalarFieldEnum]


  export const ProjectScalarFieldEnum: {
    id: 'id',
    pj_bluePrintNo: 'pj_bluePrintNo',
    pj_serialNumber: 'pj_serialNumber',
    pj_projectName: 'pj_projectName',
    pj_startDate: 'pj_startDate',
    pj_endDate: 'pj_endDate',
    pj_amountProduct: 'pj_amountProduct',
    pj_totalDay: 'pj_totalDay',
    pj_imageProduct: 'pj_imageProduct',
    pj_remark: 'pj_remark',
    pj_status: 'pj_status',
    pj_type: 'pj_type',
    pj_userId: 'pj_userId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt'
  };

  export type ProjectScalarFieldEnum = (typeof ProjectScalarFieldEnum)[keyof typeof ProjectScalarFieldEnum]


  export const ProjectDetailScalarFieldEnum: {
    id: 'id',
    pj_projectId: 'pj_projectId',
    pj_bluePrintNo: 'pj_bluePrintNo',
    pj_serialNumber: 'pj_serialNumber',
    pj_processTitle: 'pj_processTitle',
    pj_amountDay: 'pj_amountDay',
    pj_reasonType: 'pj_reasonType',
    pj_statusPc: 'pj_statusPc'
  };

  export type ProjectDetailScalarFieldEnum = (typeof ProjectDetailScalarFieldEnum)[keyof typeof ProjectDetailScalarFieldEnum]


  export const ProjectBranchScalarFieldEnum: {
    id: 'id',
    pj_projectDetailId: 'pj_projectDetailId',
    pj_remark: 'pj_remark'
  };

  export type ProjectBranchScalarFieldEnum = (typeof ProjectBranchScalarFieldEnum)[keyof typeof ProjectBranchScalarFieldEnum]


  export const ProjectMatScalarFieldEnum: {
    id: 'id',
    pj_projectDetailId: 'pj_projectDetailId',
    pj_matId: 'pj_matId',
    pj_matamount: 'pj_matamount',
    pj_matTatal: 'pj_matTatal'
  };

  export type ProjectMatScalarFieldEnum = (typeof ProjectMatScalarFieldEnum)[keyof typeof ProjectMatScalarFieldEnum]


  export const ProjectBomScalarFieldEnum: {
    id: 'id',
    pj_projectDetailId: 'pj_projectDetailId',
    pj_bomId: 'pj_bomId',
    pj_bomamount: 'pj_bomamount',
    pj_bomTatal: 'pj_bomTatal'
  };

  export type ProjectBomScalarFieldEnum = (typeof ProjectBomScalarFieldEnum)[keyof typeof ProjectBomScalarFieldEnum]


  export const ProjectResUserScalarFieldEnum: {
    id: 'id',
    pj_projectDetailId: 'pj_projectDetailId',
    pj_userId: 'pj_userId'
  };

  export type ProjectResUserScalarFieldEnum = (typeof ProjectResUserScalarFieldEnum)[keyof typeof ProjectResUserScalarFieldEnum]


  export const CompanyHourScalarFieldEnum: {
    id: 'id',
    hour: 'hour',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CompanyHourScalarFieldEnum = (typeof CompanyHourScalarFieldEnum)[keyof typeof CompanyHourScalarFieldEnum]


  export const StockScalarFieldEnum: {
    id: 'id',
    stockId: 'stockId',
    stockName: 'stockName',
    stockQuantity: 'stockQuantity',
    stockType: 'stockType',
    stockTypeId: 'stockTypeId',
    stockImage: 'stockImage',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt'
  };

  export type StockScalarFieldEnum = (typeof StockScalarFieldEnum)[keyof typeof StockScalarFieldEnum]


  export const ReasonStockNGScalarFieldEnum: {
    id: 'id',
    reasonstockName: 'reasonstockName',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt'
  };

  export type ReasonStockNGScalarFieldEnum = (typeof ReasonStockNGScalarFieldEnum)[keyof typeof ReasonStockNGScalarFieldEnum]


  export const ReasonTypeNGScalarFieldEnum: {
    id: 'id',
    reasontypeName: 'reasontypeName',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt'
  };

  export type ReasonTypeNGScalarFieldEnum = (typeof ReasonTypeNGScalarFieldEnum)[keyof typeof ReasonTypeNGScalarFieldEnum]


  export const ReasonDetailScalarFieldEnum: {
    id: 'id',
    reasonTypeId: 'reasonTypeId',
    reasondetailName: 'reasondetailName'
  };

  export type ReasonDetailScalarFieldEnum = (typeof ReasonDetailScalarFieldEnum)[keyof typeof ReasonDetailScalarFieldEnum]


  export const ReportScalarFieldEnum: {
    id: 'id',
    projectId: 'projectId',
    blueprintNo: 'blueprintNo',
    serialId: 'serialId',
    reportName: 'reportName',
    amountComplete: 'amountComplete',
    amountNG: 'amountNG',
    timeHour: 'timeHour',
    reportType: 'reportType',
    status: 'status',
    reasonType: 'reasonType',
    reasonDetail: 'reasonDetail',
    reasonId: 'reasonId',
    createdAt: 'createdAt',
    createdBy: 'createdBy',
    updatedAt: 'updatedAt',
    updatedBy: 'updatedBy',
    deletedAt: 'deletedAt',
    deletedBy: 'deletedBy'
  };

  export type ReportScalarFieldEnum = (typeof ReportScalarFieldEnum)[keyof typeof ReportScalarFieldEnum]


  export const ReportProcessScalarFieldEnum: {
    id: 'id',
    reportId: 'reportId',
    processNo: 'processNo',
    amountday: 'amountday'
  };

  export type ReportProcessScalarFieldEnum = (typeof ReportProcessScalarFieldEnum)[keyof typeof ReportProcessScalarFieldEnum]


  export const ReportStockScalarFieldEnum: {
    id: 'id',
    reportProcessId: 'reportProcessId',
    stockId: 'stockId',
    stockamount: 'stockamount',
    stocktype: 'stocktype'
  };

  export type ReportStockScalarFieldEnum = (typeof ReportStockScalarFieldEnum)[keyof typeof ReportStockScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'BigInt'
   */
  export type BigIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BigInt'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: IntFilter<"User"> | number
    userId?: StringFilter<"User"> | string
    firstName?: StringFilter<"User"> | string
    lastName?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    companyId?: IntNullableFilter<"User"> | number | null
    companyBranchId?: IntNullableFilter<"User"> | number | null
    departmentId?: IntNullableFilter<"User"> | number | null
    role?: StringFilter<"User"> | string
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    deletedAt?: DateTimeNullableFilter<"User"> | Date | string | null
    department?: XOR<DepartmentNullableRelationFilter, DepartmentWhereInput> | null
    processes?: ProcessListRelationFilter
    exams?: ExamAttemptListRelationFilter
    enrollments?: EnrollmentListRelationFilter
    oplDocuments?: OplDocumentListRelationFilter
    files?: FileListRelationFilter
    createdCourses?: CourseListRelationFilter
    deletedCourses?: CourseListRelationFilter
    courseCompletions?: UserCourseCompletionListRelationFilter
    project?: ProjectListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    password?: SortOrder
    companyId?: SortOrderInput | SortOrder
    companyBranchId?: SortOrderInput | SortOrder
    departmentId?: SortOrderInput | SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    department?: DepartmentOrderByWithRelationInput
    processes?: ProcessOrderByRelationAggregateInput
    exams?: ExamAttemptOrderByRelationAggregateInput
    enrollments?: EnrollmentOrderByRelationAggregateInput
    oplDocuments?: OplDocumentOrderByRelationAggregateInput
    files?: FileOrderByRelationAggregateInput
    createdCourses?: CourseOrderByRelationAggregateInput
    deletedCourses?: CourseOrderByRelationAggregateInput
    courseCompletions?: UserCourseCompletionOrderByRelationAggregateInput
    project?: ProjectOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    userId?: string
    id_userId?: UserIdUserIdCompoundUniqueInput
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    firstName?: StringFilter<"User"> | string
    lastName?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    companyId?: IntNullableFilter<"User"> | number | null
    companyBranchId?: IntNullableFilter<"User"> | number | null
    departmentId?: IntNullableFilter<"User"> | number | null
    role?: StringFilter<"User"> | string
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    deletedAt?: DateTimeNullableFilter<"User"> | Date | string | null
    department?: XOR<DepartmentNullableRelationFilter, DepartmentWhereInput> | null
    processes?: ProcessListRelationFilter
    exams?: ExamAttemptListRelationFilter
    enrollments?: EnrollmentListRelationFilter
    oplDocuments?: OplDocumentListRelationFilter
    files?: FileListRelationFilter
    createdCourses?: CourseListRelationFilter
    deletedCourses?: CourseListRelationFilter
    courseCompletions?: UserCourseCompletionListRelationFilter
    project?: ProjectListRelationFilter
  }, "id" | "userId" | "id_userId">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    password?: SortOrder
    companyId?: SortOrderInput | SortOrder
    companyBranchId?: SortOrderInput | SortOrder
    departmentId?: SortOrderInput | SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"User"> | number
    userId?: StringWithAggregatesFilter<"User"> | string
    firstName?: StringWithAggregatesFilter<"User"> | string
    lastName?: StringWithAggregatesFilter<"User"> | string
    password?: StringWithAggregatesFilter<"User"> | string
    companyId?: IntNullableWithAggregatesFilter<"User"> | number | null
    companyBranchId?: IntNullableWithAggregatesFilter<"User"> | number | null
    departmentId?: IntNullableWithAggregatesFilter<"User"> | number | null
    role?: StringWithAggregatesFilter<"User"> | string
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
  }

  export type CompanyWhereInput = {
    AND?: CompanyWhereInput | CompanyWhereInput[]
    OR?: CompanyWhereInput[]
    NOT?: CompanyWhereInput | CompanyWhereInput[]
    id?: IntFilter<"Company"> | number
    companyName?: StringFilter<"Company"> | string
    createdAt?: DateTimeFilter<"Company"> | Date | string
    updatedAt?: DateTimeFilter<"Company"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Company"> | Date | string | null
    companyBranch?: CompanyBranchListRelationFilter
  }

  export type CompanyOrderByWithRelationInput = {
    id?: SortOrder
    companyName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    companyBranch?: CompanyBranchOrderByRelationAggregateInput
  }

  export type CompanyWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: CompanyWhereInput | CompanyWhereInput[]
    OR?: CompanyWhereInput[]
    NOT?: CompanyWhereInput | CompanyWhereInput[]
    companyName?: StringFilter<"Company"> | string
    createdAt?: DateTimeFilter<"Company"> | Date | string
    updatedAt?: DateTimeFilter<"Company"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Company"> | Date | string | null
    companyBranch?: CompanyBranchListRelationFilter
  }, "id">

  export type CompanyOrderByWithAggregationInput = {
    id?: SortOrder
    companyName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: CompanyCountOrderByAggregateInput
    _avg?: CompanyAvgOrderByAggregateInput
    _max?: CompanyMaxOrderByAggregateInput
    _min?: CompanyMinOrderByAggregateInput
    _sum?: CompanySumOrderByAggregateInput
  }

  export type CompanyScalarWhereWithAggregatesInput = {
    AND?: CompanyScalarWhereWithAggregatesInput | CompanyScalarWhereWithAggregatesInput[]
    OR?: CompanyScalarWhereWithAggregatesInput[]
    NOT?: CompanyScalarWhereWithAggregatesInput | CompanyScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Company"> | number
    companyName?: StringWithAggregatesFilter<"Company"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Company"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Company"> | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter<"Company"> | Date | string | null
  }

  export type CompanyBranchWhereInput = {
    AND?: CompanyBranchWhereInput | CompanyBranchWhereInput[]
    OR?: CompanyBranchWhereInput[]
    NOT?: CompanyBranchWhereInput | CompanyBranchWhereInput[]
    id?: IntFilter<"CompanyBranch"> | number
    companyId?: IntFilter<"CompanyBranch"> | number
    companyBranchName?: StringFilter<"CompanyBranch"> | string
    company?: XOR<CompanyRelationFilter, CompanyWhereInput>
  }

  export type CompanyBranchOrderByWithRelationInput = {
    id?: SortOrder
    companyId?: SortOrder
    companyBranchName?: SortOrder
    company?: CompanyOrderByWithRelationInput
  }

  export type CompanyBranchWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: CompanyBranchWhereInput | CompanyBranchWhereInput[]
    OR?: CompanyBranchWhereInput[]
    NOT?: CompanyBranchWhereInput | CompanyBranchWhereInput[]
    companyId?: IntFilter<"CompanyBranch"> | number
    companyBranchName?: StringFilter<"CompanyBranch"> | string
    company?: XOR<CompanyRelationFilter, CompanyWhereInput>
  }, "id">

  export type CompanyBranchOrderByWithAggregationInput = {
    id?: SortOrder
    companyId?: SortOrder
    companyBranchName?: SortOrder
    _count?: CompanyBranchCountOrderByAggregateInput
    _avg?: CompanyBranchAvgOrderByAggregateInput
    _max?: CompanyBranchMaxOrderByAggregateInput
    _min?: CompanyBranchMinOrderByAggregateInput
    _sum?: CompanyBranchSumOrderByAggregateInput
  }

  export type CompanyBranchScalarWhereWithAggregatesInput = {
    AND?: CompanyBranchScalarWhereWithAggregatesInput | CompanyBranchScalarWhereWithAggregatesInput[]
    OR?: CompanyBranchScalarWhereWithAggregatesInput[]
    NOT?: CompanyBranchScalarWhereWithAggregatesInput | CompanyBranchScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"CompanyBranch"> | number
    companyId?: IntWithAggregatesFilter<"CompanyBranch"> | number
    companyBranchName?: StringWithAggregatesFilter<"CompanyBranch"> | string
  }

  export type DepartmentWhereInput = {
    AND?: DepartmentWhereInput | DepartmentWhereInput[]
    OR?: DepartmentWhereInput[]
    NOT?: DepartmentWhereInput | DepartmentWhereInput[]
    id?: IntFilter<"Department"> | number
    departmentName?: StringFilter<"Department"> | string
    createdAt?: DateTimeFilter<"Department"> | Date | string
    updatedAt?: DateTimeFilter<"Department"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Department"> | Date | string | null
    user?: UserListRelationFilter
    Course?: CourseListRelationFilter
  }

  export type DepartmentOrderByWithRelationInput = {
    id?: SortOrder
    departmentName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    user?: UserOrderByRelationAggregateInput
    Course?: CourseOrderByRelationAggregateInput
  }

  export type DepartmentWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: DepartmentWhereInput | DepartmentWhereInput[]
    OR?: DepartmentWhereInput[]
    NOT?: DepartmentWhereInput | DepartmentWhereInput[]
    departmentName?: StringFilter<"Department"> | string
    createdAt?: DateTimeFilter<"Department"> | Date | string
    updatedAt?: DateTimeFilter<"Department"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Department"> | Date | string | null
    user?: UserListRelationFilter
    Course?: CourseListRelationFilter
  }, "id">

  export type DepartmentOrderByWithAggregationInput = {
    id?: SortOrder
    departmentName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: DepartmentCountOrderByAggregateInput
    _avg?: DepartmentAvgOrderByAggregateInput
    _max?: DepartmentMaxOrderByAggregateInput
    _min?: DepartmentMinOrderByAggregateInput
    _sum?: DepartmentSumOrderByAggregateInput
  }

  export type DepartmentScalarWhereWithAggregatesInput = {
    AND?: DepartmentScalarWhereWithAggregatesInput | DepartmentScalarWhereWithAggregatesInput[]
    OR?: DepartmentScalarWhereWithAggregatesInput[]
    NOT?: DepartmentScalarWhereWithAggregatesInput | DepartmentScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Department"> | number
    departmentName?: StringWithAggregatesFilter<"Department"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Department"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Department"> | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter<"Department"> | Date | string | null
  }

  export type CourseWhereInput = {
    AND?: CourseWhereInput | CourseWhereInput[]
    OR?: CourseWhereInput[]
    NOT?: CourseWhereInput | CourseWhereInput[]
    id?: IntFilter<"Course"> | number
    title?: StringFilter<"Course"> | string
    description?: StringNullableFilter<"Course"> | string | null
    pdfUrl?: StringNullableFilter<"Course"> | string | null
    videoUrl?: StringNullableFilter<"Course"> | string | null
    typeId?: IntFilter<"Course"> | number
    template?: BoolFilter<"Course"> | boolean
    departmentId?: IntNullableFilter<"Course"> | number | null
    processId?: IntFilter<"Course"> | number
    createdAt?: DateTimeFilter<"Course"> | Date | string
    updatedAt?: DateTimeFilter<"Course"> | Date | string
    createdBy?: IntFilter<"Course"> | number
    deletedBy?: IntNullableFilter<"Course"> | number | null
    isDeleted?: BoolFilter<"Course"> | boolean
    department?: XOR<DepartmentNullableRelationFilter, DepartmentWhereInput> | null
    process?: XOR<ProcessNullableRelationFilter, ProcessWhereInput> | null
    enrollments?: EnrollmentListRelationFilter
    files?: FileListRelationFilter
    exams?: ExamListRelationFilter
    completions?: UserCourseCompletionListRelationFilter
    creator?: XOR<UserRelationFilter, UserWhereInput>
    deleter?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }

  export type CourseOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    pdfUrl?: SortOrderInput | SortOrder
    videoUrl?: SortOrderInput | SortOrder
    typeId?: SortOrder
    template?: SortOrder
    departmentId?: SortOrderInput | SortOrder
    processId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrder
    deletedBy?: SortOrderInput | SortOrder
    isDeleted?: SortOrder
    department?: DepartmentOrderByWithRelationInput
    process?: ProcessOrderByWithRelationInput
    enrollments?: EnrollmentOrderByRelationAggregateInput
    files?: FileOrderByRelationAggregateInput
    exams?: ExamOrderByRelationAggregateInput
    completions?: UserCourseCompletionOrderByRelationAggregateInput
    creator?: UserOrderByWithRelationInput
    deleter?: UserOrderByWithRelationInput
  }

  export type CourseWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: CourseWhereInput | CourseWhereInput[]
    OR?: CourseWhereInput[]
    NOT?: CourseWhereInput | CourseWhereInput[]
    title?: StringFilter<"Course"> | string
    description?: StringNullableFilter<"Course"> | string | null
    pdfUrl?: StringNullableFilter<"Course"> | string | null
    videoUrl?: StringNullableFilter<"Course"> | string | null
    typeId?: IntFilter<"Course"> | number
    template?: BoolFilter<"Course"> | boolean
    departmentId?: IntNullableFilter<"Course"> | number | null
    processId?: IntFilter<"Course"> | number
    createdAt?: DateTimeFilter<"Course"> | Date | string
    updatedAt?: DateTimeFilter<"Course"> | Date | string
    createdBy?: IntFilter<"Course"> | number
    deletedBy?: IntNullableFilter<"Course"> | number | null
    isDeleted?: BoolFilter<"Course"> | boolean
    department?: XOR<DepartmentNullableRelationFilter, DepartmentWhereInput> | null
    process?: XOR<ProcessNullableRelationFilter, ProcessWhereInput> | null
    enrollments?: EnrollmentListRelationFilter
    files?: FileListRelationFilter
    exams?: ExamListRelationFilter
    completions?: UserCourseCompletionListRelationFilter
    creator?: XOR<UserRelationFilter, UserWhereInput>
    deleter?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }, "id">

  export type CourseOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    pdfUrl?: SortOrderInput | SortOrder
    videoUrl?: SortOrderInput | SortOrder
    typeId?: SortOrder
    template?: SortOrder
    departmentId?: SortOrderInput | SortOrder
    processId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrder
    deletedBy?: SortOrderInput | SortOrder
    isDeleted?: SortOrder
    _count?: CourseCountOrderByAggregateInput
    _avg?: CourseAvgOrderByAggregateInput
    _max?: CourseMaxOrderByAggregateInput
    _min?: CourseMinOrderByAggregateInput
    _sum?: CourseSumOrderByAggregateInput
  }

  export type CourseScalarWhereWithAggregatesInput = {
    AND?: CourseScalarWhereWithAggregatesInput | CourseScalarWhereWithAggregatesInput[]
    OR?: CourseScalarWhereWithAggregatesInput[]
    NOT?: CourseScalarWhereWithAggregatesInput | CourseScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Course"> | number
    title?: StringWithAggregatesFilter<"Course"> | string
    description?: StringNullableWithAggregatesFilter<"Course"> | string | null
    pdfUrl?: StringNullableWithAggregatesFilter<"Course"> | string | null
    videoUrl?: StringNullableWithAggregatesFilter<"Course"> | string | null
    typeId?: IntWithAggregatesFilter<"Course"> | number
    template?: BoolWithAggregatesFilter<"Course"> | boolean
    departmentId?: IntNullableWithAggregatesFilter<"Course"> | number | null
    processId?: IntWithAggregatesFilter<"Course"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Course"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Course"> | Date | string
    createdBy?: IntWithAggregatesFilter<"Course"> | number
    deletedBy?: IntNullableWithAggregatesFilter<"Course"> | number | null
    isDeleted?: BoolWithAggregatesFilter<"Course"> | boolean
  }

  export type UserCourseCompletionWhereInput = {
    AND?: UserCourseCompletionWhereInput | UserCourseCompletionWhereInput[]
    OR?: UserCourseCompletionWhereInput[]
    NOT?: UserCourseCompletionWhereInput | UserCourseCompletionWhereInput[]
    id?: IntFilter<"UserCourseCompletion"> | number
    userId?: IntFilter<"UserCourseCompletion"> | number
    username?: StringFilter<"UserCourseCompletion"> | string
    courseId?: IntFilter<"UserCourseCompletion"> | number
    examId?: IntFilter<"UserCourseCompletion"> | number
    processId?: IntFilter<"UserCourseCompletion"> | number
    completedAt?: DateTimeFilter<"UserCourseCompletion"> | Date | string
    createdAt?: DateTimeFilter<"UserCourseCompletion"> | Date | string
    updatedAt?: DateTimeFilter<"UserCourseCompletion"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    course?: XOR<CourseRelationFilter, CourseWhereInput>
    exam?: XOR<ExamRelationFilter, ExamWhereInput>
    process?: XOR<ProcessRelationFilter, ProcessWhereInput>
  }

  export type UserCourseCompletionOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    username?: SortOrder
    courseId?: SortOrder
    examId?: SortOrder
    processId?: SortOrder
    completedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    course?: CourseOrderByWithRelationInput
    exam?: ExamOrderByWithRelationInput
    process?: ProcessOrderByWithRelationInput
  }

  export type UserCourseCompletionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    userId_courseId_examId?: UserCourseCompletionUserIdCourseIdExamIdCompoundUniqueInput
    AND?: UserCourseCompletionWhereInput | UserCourseCompletionWhereInput[]
    OR?: UserCourseCompletionWhereInput[]
    NOT?: UserCourseCompletionWhereInput | UserCourseCompletionWhereInput[]
    userId?: IntFilter<"UserCourseCompletion"> | number
    username?: StringFilter<"UserCourseCompletion"> | string
    courseId?: IntFilter<"UserCourseCompletion"> | number
    examId?: IntFilter<"UserCourseCompletion"> | number
    processId?: IntFilter<"UserCourseCompletion"> | number
    completedAt?: DateTimeFilter<"UserCourseCompletion"> | Date | string
    createdAt?: DateTimeFilter<"UserCourseCompletion"> | Date | string
    updatedAt?: DateTimeFilter<"UserCourseCompletion"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    course?: XOR<CourseRelationFilter, CourseWhereInput>
    exam?: XOR<ExamRelationFilter, ExamWhereInput>
    process?: XOR<ProcessRelationFilter, ProcessWhereInput>
  }, "id" | "userId_courseId_examId">

  export type UserCourseCompletionOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    username?: SortOrder
    courseId?: SortOrder
    examId?: SortOrder
    processId?: SortOrder
    completedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCourseCompletionCountOrderByAggregateInput
    _avg?: UserCourseCompletionAvgOrderByAggregateInput
    _max?: UserCourseCompletionMaxOrderByAggregateInput
    _min?: UserCourseCompletionMinOrderByAggregateInput
    _sum?: UserCourseCompletionSumOrderByAggregateInput
  }

  export type UserCourseCompletionScalarWhereWithAggregatesInput = {
    AND?: UserCourseCompletionScalarWhereWithAggregatesInput | UserCourseCompletionScalarWhereWithAggregatesInput[]
    OR?: UserCourseCompletionScalarWhereWithAggregatesInput[]
    NOT?: UserCourseCompletionScalarWhereWithAggregatesInput | UserCourseCompletionScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"UserCourseCompletion"> | number
    userId?: IntWithAggregatesFilter<"UserCourseCompletion"> | number
    username?: StringWithAggregatesFilter<"UserCourseCompletion"> | string
    courseId?: IntWithAggregatesFilter<"UserCourseCompletion"> | number
    examId?: IntWithAggregatesFilter<"UserCourseCompletion"> | number
    processId?: IntWithAggregatesFilter<"UserCourseCompletion"> | number
    completedAt?: DateTimeWithAggregatesFilter<"UserCourseCompletion"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"UserCourseCompletion"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"UserCourseCompletion"> | Date | string
  }

  export type courseTypeWhereInput = {
    AND?: courseTypeWhereInput | courseTypeWhereInput[]
    OR?: courseTypeWhereInput[]
    NOT?: courseTypeWhereInput | courseTypeWhereInput[]
    id?: IntFilter<"courseType"> | number
    title?: StringFilter<"courseType"> | string
  }

  export type courseTypeOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
  }

  export type courseTypeWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: courseTypeWhereInput | courseTypeWhereInput[]
    OR?: courseTypeWhereInput[]
    NOT?: courseTypeWhereInput | courseTypeWhereInput[]
    title?: StringFilter<"courseType"> | string
  }, "id">

  export type courseTypeOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    _count?: courseTypeCountOrderByAggregateInput
    _avg?: courseTypeAvgOrderByAggregateInput
    _max?: courseTypeMaxOrderByAggregateInput
    _min?: courseTypeMinOrderByAggregateInput
    _sum?: courseTypeSumOrderByAggregateInput
  }

  export type courseTypeScalarWhereWithAggregatesInput = {
    AND?: courseTypeScalarWhereWithAggregatesInput | courseTypeScalarWhereWithAggregatesInput[]
    OR?: courseTypeScalarWhereWithAggregatesInput[]
    NOT?: courseTypeScalarWhereWithAggregatesInput | courseTypeScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"courseType"> | number
    title?: StringWithAggregatesFilter<"courseType"> | string
  }

  export type EnrollmentWhereInput = {
    AND?: EnrollmentWhereInput | EnrollmentWhereInput[]
    OR?: EnrollmentWhereInput[]
    NOT?: EnrollmentWhereInput | EnrollmentWhereInput[]
    id?: IntFilter<"Enrollment"> | number
    userId?: IntFilter<"Enrollment"> | number
    courseId?: IntFilter<"Enrollment"> | number
    progress?: FloatFilter<"Enrollment"> | number
    completed?: BoolFilter<"Enrollment"> | boolean
    isDownloaded?: FloatFilter<"Enrollment"> | number
    user?: XOR<UserRelationFilter, UserWhereInput>
    course?: XOR<CourseRelationFilter, CourseWhereInput>
  }

  export type EnrollmentOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    courseId?: SortOrder
    progress?: SortOrder
    completed?: SortOrder
    isDownloaded?: SortOrder
    user?: UserOrderByWithRelationInput
    course?: CourseOrderByWithRelationInput
  }

  export type EnrollmentWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: EnrollmentWhereInput | EnrollmentWhereInput[]
    OR?: EnrollmentWhereInput[]
    NOT?: EnrollmentWhereInput | EnrollmentWhereInput[]
    userId?: IntFilter<"Enrollment"> | number
    courseId?: IntFilter<"Enrollment"> | number
    progress?: FloatFilter<"Enrollment"> | number
    completed?: BoolFilter<"Enrollment"> | boolean
    isDownloaded?: FloatFilter<"Enrollment"> | number
    user?: XOR<UserRelationFilter, UserWhereInput>
    course?: XOR<CourseRelationFilter, CourseWhereInput>
  }, "id">

  export type EnrollmentOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    courseId?: SortOrder
    progress?: SortOrder
    completed?: SortOrder
    isDownloaded?: SortOrder
    _count?: EnrollmentCountOrderByAggregateInput
    _avg?: EnrollmentAvgOrderByAggregateInput
    _max?: EnrollmentMaxOrderByAggregateInput
    _min?: EnrollmentMinOrderByAggregateInput
    _sum?: EnrollmentSumOrderByAggregateInput
  }

  export type EnrollmentScalarWhereWithAggregatesInput = {
    AND?: EnrollmentScalarWhereWithAggregatesInput | EnrollmentScalarWhereWithAggregatesInput[]
    OR?: EnrollmentScalarWhereWithAggregatesInput[]
    NOT?: EnrollmentScalarWhereWithAggregatesInput | EnrollmentScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Enrollment"> | number
    userId?: IntWithAggregatesFilter<"Enrollment"> | number
    courseId?: IntWithAggregatesFilter<"Enrollment"> | number
    progress?: FloatWithAggregatesFilter<"Enrollment"> | number
    completed?: BoolWithAggregatesFilter<"Enrollment"> | boolean
    isDownloaded?: FloatWithAggregatesFilter<"Enrollment"> | number
  }

  export type ExamWhereInput = {
    AND?: ExamWhereInput | ExamWhereInput[]
    OR?: ExamWhereInput[]
    NOT?: ExamWhereInput | ExamWhereInput[]
    id?: IntFilter<"Exam"> | number
    title?: StringFilter<"Exam"> | string
    departmentId?: IntNullableFilter<"Exam"> | number | null
    createdAt?: DateTimeFilter<"Exam"> | Date | string
    updatedAt?: DateTimeFilter<"Exam"> | Date | string
    courseId?: IntNullableFilter<"Exam"> | number | null
    description?: StringNullableFilter<"Exam"> | string | null
    deleted?: BoolFilter<"Exam"> | boolean
    questions?: QuestionListRelationFilter
    attempts?: ExamAttemptListRelationFilter
    completions?: UserCourseCompletionListRelationFilter
    course?: XOR<CourseNullableRelationFilter, CourseWhereInput> | null
  }

  export type ExamOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    departmentId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    courseId?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    deleted?: SortOrder
    questions?: QuestionOrderByRelationAggregateInput
    attempts?: ExamAttemptOrderByRelationAggregateInput
    completions?: UserCourseCompletionOrderByRelationAggregateInput
    course?: CourseOrderByWithRelationInput
  }

  export type ExamWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ExamWhereInput | ExamWhereInput[]
    OR?: ExamWhereInput[]
    NOT?: ExamWhereInput | ExamWhereInput[]
    title?: StringFilter<"Exam"> | string
    departmentId?: IntNullableFilter<"Exam"> | number | null
    createdAt?: DateTimeFilter<"Exam"> | Date | string
    updatedAt?: DateTimeFilter<"Exam"> | Date | string
    courseId?: IntNullableFilter<"Exam"> | number | null
    description?: StringNullableFilter<"Exam"> | string | null
    deleted?: BoolFilter<"Exam"> | boolean
    questions?: QuestionListRelationFilter
    attempts?: ExamAttemptListRelationFilter
    completions?: UserCourseCompletionListRelationFilter
    course?: XOR<CourseNullableRelationFilter, CourseWhereInput> | null
  }, "id">

  export type ExamOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    departmentId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    courseId?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    deleted?: SortOrder
    _count?: ExamCountOrderByAggregateInput
    _avg?: ExamAvgOrderByAggregateInput
    _max?: ExamMaxOrderByAggregateInput
    _min?: ExamMinOrderByAggregateInput
    _sum?: ExamSumOrderByAggregateInput
  }

  export type ExamScalarWhereWithAggregatesInput = {
    AND?: ExamScalarWhereWithAggregatesInput | ExamScalarWhereWithAggregatesInput[]
    OR?: ExamScalarWhereWithAggregatesInput[]
    NOT?: ExamScalarWhereWithAggregatesInput | ExamScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Exam"> | number
    title?: StringWithAggregatesFilter<"Exam"> | string
    departmentId?: IntNullableWithAggregatesFilter<"Exam"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"Exam"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Exam"> | Date | string
    courseId?: IntNullableWithAggregatesFilter<"Exam"> | number | null
    description?: StringNullableWithAggregatesFilter<"Exam"> | string | null
    deleted?: BoolWithAggregatesFilter<"Exam"> | boolean
  }

  export type QuestionWhereInput = {
    AND?: QuestionWhereInput | QuestionWhereInput[]
    OR?: QuestionWhereInput[]
    NOT?: QuestionWhereInput | QuestionWhereInput[]
    id?: IntFilter<"Question"> | number
    examId?: IntFilter<"Question"> | number
    text?: StringFilter<"Question"> | string
    createdAt?: DateTimeFilter<"Question"> | Date | string
    updatedAt?: DateTimeFilter<"Question"> | Date | string
    deleted?: BoolFilter<"Question"> | boolean
    exam?: XOR<ExamRelationFilter, ExamWhereInput>
    choices?: ChoiceListRelationFilter
    userAnswers?: UserAnswerListRelationFilter
  }

  export type QuestionOrderByWithRelationInput = {
    id?: SortOrder
    examId?: SortOrder
    text?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deleted?: SortOrder
    exam?: ExamOrderByWithRelationInput
    choices?: ChoiceOrderByRelationAggregateInput
    userAnswers?: UserAnswerOrderByRelationAggregateInput
  }

  export type QuestionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: QuestionWhereInput | QuestionWhereInput[]
    OR?: QuestionWhereInput[]
    NOT?: QuestionWhereInput | QuestionWhereInput[]
    examId?: IntFilter<"Question"> | number
    text?: StringFilter<"Question"> | string
    createdAt?: DateTimeFilter<"Question"> | Date | string
    updatedAt?: DateTimeFilter<"Question"> | Date | string
    deleted?: BoolFilter<"Question"> | boolean
    exam?: XOR<ExamRelationFilter, ExamWhereInput>
    choices?: ChoiceListRelationFilter
    userAnswers?: UserAnswerListRelationFilter
  }, "id">

  export type QuestionOrderByWithAggregationInput = {
    id?: SortOrder
    examId?: SortOrder
    text?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deleted?: SortOrder
    _count?: QuestionCountOrderByAggregateInput
    _avg?: QuestionAvgOrderByAggregateInput
    _max?: QuestionMaxOrderByAggregateInput
    _min?: QuestionMinOrderByAggregateInput
    _sum?: QuestionSumOrderByAggregateInput
  }

  export type QuestionScalarWhereWithAggregatesInput = {
    AND?: QuestionScalarWhereWithAggregatesInput | QuestionScalarWhereWithAggregatesInput[]
    OR?: QuestionScalarWhereWithAggregatesInput[]
    NOT?: QuestionScalarWhereWithAggregatesInput | QuestionScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Question"> | number
    examId?: IntWithAggregatesFilter<"Question"> | number
    text?: StringWithAggregatesFilter<"Question"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Question"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Question"> | Date | string
    deleted?: BoolWithAggregatesFilter<"Question"> | boolean
  }

  export type ChoiceWhereInput = {
    AND?: ChoiceWhereInput | ChoiceWhereInput[]
    OR?: ChoiceWhereInput[]
    NOT?: ChoiceWhereInput | ChoiceWhereInput[]
    id?: IntFilter<"Choice"> | number
    questionId?: IntFilter<"Choice"> | number
    text?: StringFilter<"Choice"> | string
    correct?: BoolFilter<"Choice"> | boolean
    createdAt?: DateTimeFilter<"Choice"> | Date | string
    updatedAt?: DateTimeFilter<"Choice"> | Date | string
    deleted?: BoolFilter<"Choice"> | boolean
    question?: XOR<QuestionRelationFilter, QuestionWhereInput>
    UserAnswer?: UserAnswerListRelationFilter
  }

  export type ChoiceOrderByWithRelationInput = {
    id?: SortOrder
    questionId?: SortOrder
    text?: SortOrder
    correct?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deleted?: SortOrder
    question?: QuestionOrderByWithRelationInput
    UserAnswer?: UserAnswerOrderByRelationAggregateInput
  }

  export type ChoiceWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ChoiceWhereInput | ChoiceWhereInput[]
    OR?: ChoiceWhereInput[]
    NOT?: ChoiceWhereInput | ChoiceWhereInput[]
    questionId?: IntFilter<"Choice"> | number
    text?: StringFilter<"Choice"> | string
    correct?: BoolFilter<"Choice"> | boolean
    createdAt?: DateTimeFilter<"Choice"> | Date | string
    updatedAt?: DateTimeFilter<"Choice"> | Date | string
    deleted?: BoolFilter<"Choice"> | boolean
    question?: XOR<QuestionRelationFilter, QuestionWhereInput>
    UserAnswer?: UserAnswerListRelationFilter
  }, "id">

  export type ChoiceOrderByWithAggregationInput = {
    id?: SortOrder
    questionId?: SortOrder
    text?: SortOrder
    correct?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deleted?: SortOrder
    _count?: ChoiceCountOrderByAggregateInput
    _avg?: ChoiceAvgOrderByAggregateInput
    _max?: ChoiceMaxOrderByAggregateInput
    _min?: ChoiceMinOrderByAggregateInput
    _sum?: ChoiceSumOrderByAggregateInput
  }

  export type ChoiceScalarWhereWithAggregatesInput = {
    AND?: ChoiceScalarWhereWithAggregatesInput | ChoiceScalarWhereWithAggregatesInput[]
    OR?: ChoiceScalarWhereWithAggregatesInput[]
    NOT?: ChoiceScalarWhereWithAggregatesInput | ChoiceScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Choice"> | number
    questionId?: IntWithAggregatesFilter<"Choice"> | number
    text?: StringWithAggregatesFilter<"Choice"> | string
    correct?: BoolWithAggregatesFilter<"Choice"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Choice"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Choice"> | Date | string
    deleted?: BoolWithAggregatesFilter<"Choice"> | boolean
  }

  export type ExamAttemptWhereInput = {
    AND?: ExamAttemptWhereInput | ExamAttemptWhereInput[]
    OR?: ExamAttemptWhereInput[]
    NOT?: ExamAttemptWhereInput | ExamAttemptWhereInput[]
    id?: IntFilter<"ExamAttempt"> | number
    userId?: IntFilter<"ExamAttempt"> | number
    examId?: IntFilter<"ExamAttempt"> | number
    startedAt?: DateTimeFilter<"ExamAttempt"> | Date | string
    endedAt?: DateTimeNullableFilter<"ExamAttempt"> | Date | string | null
    grade?: FloatNullableFilter<"ExamAttempt"> | number | null
    isPassed?: BoolNullableFilter<"ExamAttempt"> | boolean | null
    user?: XOR<UserRelationFilter, UserWhereInput>
    exam?: XOR<ExamRelationFilter, ExamWhereInput>
    answers?: UserAnswerListRelationFilter
  }

  export type ExamAttemptOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    examId?: SortOrder
    startedAt?: SortOrder
    endedAt?: SortOrderInput | SortOrder
    grade?: SortOrderInput | SortOrder
    isPassed?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
    exam?: ExamOrderByWithRelationInput
    answers?: UserAnswerOrderByRelationAggregateInput
  }

  export type ExamAttemptWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ExamAttemptWhereInput | ExamAttemptWhereInput[]
    OR?: ExamAttemptWhereInput[]
    NOT?: ExamAttemptWhereInput | ExamAttemptWhereInput[]
    userId?: IntFilter<"ExamAttempt"> | number
    examId?: IntFilter<"ExamAttempt"> | number
    startedAt?: DateTimeFilter<"ExamAttempt"> | Date | string
    endedAt?: DateTimeNullableFilter<"ExamAttempt"> | Date | string | null
    grade?: FloatNullableFilter<"ExamAttempt"> | number | null
    isPassed?: BoolNullableFilter<"ExamAttempt"> | boolean | null
    user?: XOR<UserRelationFilter, UserWhereInput>
    exam?: XOR<ExamRelationFilter, ExamWhereInput>
    answers?: UserAnswerListRelationFilter
  }, "id">

  export type ExamAttemptOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    examId?: SortOrder
    startedAt?: SortOrder
    endedAt?: SortOrderInput | SortOrder
    grade?: SortOrderInput | SortOrder
    isPassed?: SortOrderInput | SortOrder
    _count?: ExamAttemptCountOrderByAggregateInput
    _avg?: ExamAttemptAvgOrderByAggregateInput
    _max?: ExamAttemptMaxOrderByAggregateInput
    _min?: ExamAttemptMinOrderByAggregateInput
    _sum?: ExamAttemptSumOrderByAggregateInput
  }

  export type ExamAttemptScalarWhereWithAggregatesInput = {
    AND?: ExamAttemptScalarWhereWithAggregatesInput | ExamAttemptScalarWhereWithAggregatesInput[]
    OR?: ExamAttemptScalarWhereWithAggregatesInput[]
    NOT?: ExamAttemptScalarWhereWithAggregatesInput | ExamAttemptScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ExamAttempt"> | number
    userId?: IntWithAggregatesFilter<"ExamAttempt"> | number
    examId?: IntWithAggregatesFilter<"ExamAttempt"> | number
    startedAt?: DateTimeWithAggregatesFilter<"ExamAttempt"> | Date | string
    endedAt?: DateTimeNullableWithAggregatesFilter<"ExamAttempt"> | Date | string | null
    grade?: FloatNullableWithAggregatesFilter<"ExamAttempt"> | number | null
    isPassed?: BoolNullableWithAggregatesFilter<"ExamAttempt"> | boolean | null
  }

  export type UserAnswerWhereInput = {
    AND?: UserAnswerWhereInput | UserAnswerWhereInput[]
    OR?: UserAnswerWhereInput[]
    NOT?: UserAnswerWhereInput | UserAnswerWhereInput[]
    id?: IntFilter<"UserAnswer"> | number
    examAttemptId?: IntFilter<"UserAnswer"> | number
    questionId?: IntFilter<"UserAnswer"> | number
    selectedChoiceId?: IntFilter<"UserAnswer"> | number
    isCorrect?: BoolFilter<"UserAnswer"> | boolean
    createdAt?: DateTimeFilter<"UserAnswer"> | Date | string
    examAttempt?: XOR<ExamAttemptRelationFilter, ExamAttemptWhereInput>
    question?: XOR<QuestionRelationFilter, QuestionWhereInput>
    selectedChoice?: XOR<ChoiceRelationFilter, ChoiceWhereInput>
  }

  export type UserAnswerOrderByWithRelationInput = {
    id?: SortOrder
    examAttemptId?: SortOrder
    questionId?: SortOrder
    selectedChoiceId?: SortOrder
    isCorrect?: SortOrder
    createdAt?: SortOrder
    examAttempt?: ExamAttemptOrderByWithRelationInput
    question?: QuestionOrderByWithRelationInput
    selectedChoice?: ChoiceOrderByWithRelationInput
  }

  export type UserAnswerWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    examAttemptId_questionId?: UserAnswerExamAttemptIdQuestionIdCompoundUniqueInput
    AND?: UserAnswerWhereInput | UserAnswerWhereInput[]
    OR?: UserAnswerWhereInput[]
    NOT?: UserAnswerWhereInput | UserAnswerWhereInput[]
    examAttemptId?: IntFilter<"UserAnswer"> | number
    questionId?: IntFilter<"UserAnswer"> | number
    selectedChoiceId?: IntFilter<"UserAnswer"> | number
    isCorrect?: BoolFilter<"UserAnswer"> | boolean
    createdAt?: DateTimeFilter<"UserAnswer"> | Date | string
    examAttempt?: XOR<ExamAttemptRelationFilter, ExamAttemptWhereInput>
    question?: XOR<QuestionRelationFilter, QuestionWhereInput>
    selectedChoice?: XOR<ChoiceRelationFilter, ChoiceWhereInput>
  }, "id" | "examAttemptId_questionId">

  export type UserAnswerOrderByWithAggregationInput = {
    id?: SortOrder
    examAttemptId?: SortOrder
    questionId?: SortOrder
    selectedChoiceId?: SortOrder
    isCorrect?: SortOrder
    createdAt?: SortOrder
    _count?: UserAnswerCountOrderByAggregateInput
    _avg?: UserAnswerAvgOrderByAggregateInput
    _max?: UserAnswerMaxOrderByAggregateInput
    _min?: UserAnswerMinOrderByAggregateInput
    _sum?: UserAnswerSumOrderByAggregateInput
  }

  export type UserAnswerScalarWhereWithAggregatesInput = {
    AND?: UserAnswerScalarWhereWithAggregatesInput | UserAnswerScalarWhereWithAggregatesInput[]
    OR?: UserAnswerScalarWhereWithAggregatesInput[]
    NOT?: UserAnswerScalarWhereWithAggregatesInput | UserAnswerScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"UserAnswer"> | number
    examAttemptId?: IntWithAggregatesFilter<"UserAnswer"> | number
    questionId?: IntWithAggregatesFilter<"UserAnswer"> | number
    selectedChoiceId?: IntWithAggregatesFilter<"UserAnswer"> | number
    isCorrect?: BoolWithAggregatesFilter<"UserAnswer"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"UserAnswer"> | Date | string
  }

  export type OplDocumentWhereInput = {
    AND?: OplDocumentWhereInput | OplDocumentWhereInput[]
    OR?: OplDocumentWhereInput[]
    NOT?: OplDocumentWhereInput | OplDocumentWhereInput[]
    id?: IntFilter<"OplDocument"> | number
    title?: StringFilter<"OplDocument"> | string
    description?: StringNullableFilter<"OplDocument"> | string | null
    fileName?: StringFilter<"OplDocument"> | string
    fileType?: StringFilter<"OplDocument"> | string
    filePath?: StringFilter<"OplDocument"> | string
    template?: BoolFilter<"OplDocument"> | boolean
    createdAt?: DateTimeFilter<"OplDocument"> | Date | string
    uploadedBy?: IntFilter<"OplDocument"> | number
    updatedAt?: DateTimeFilter<"OplDocument"> | Date | string
    deletedAt?: DateTimeNullableFilter<"OplDocument"> | Date | string | null
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type OplDocumentOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    fileName?: SortOrder
    fileType?: SortOrder
    filePath?: SortOrder
    template?: SortOrder
    createdAt?: SortOrder
    uploadedBy?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type OplDocumentWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: OplDocumentWhereInput | OplDocumentWhereInput[]
    OR?: OplDocumentWhereInput[]
    NOT?: OplDocumentWhereInput | OplDocumentWhereInput[]
    title?: StringFilter<"OplDocument"> | string
    description?: StringNullableFilter<"OplDocument"> | string | null
    fileName?: StringFilter<"OplDocument"> | string
    fileType?: StringFilter<"OplDocument"> | string
    filePath?: StringFilter<"OplDocument"> | string
    template?: BoolFilter<"OplDocument"> | boolean
    createdAt?: DateTimeFilter<"OplDocument"> | Date | string
    uploadedBy?: IntFilter<"OplDocument"> | number
    updatedAt?: DateTimeFilter<"OplDocument"> | Date | string
    deletedAt?: DateTimeNullableFilter<"OplDocument"> | Date | string | null
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type OplDocumentOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    fileName?: SortOrder
    fileType?: SortOrder
    filePath?: SortOrder
    template?: SortOrder
    createdAt?: SortOrder
    uploadedBy?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: OplDocumentCountOrderByAggregateInput
    _avg?: OplDocumentAvgOrderByAggregateInput
    _max?: OplDocumentMaxOrderByAggregateInput
    _min?: OplDocumentMinOrderByAggregateInput
    _sum?: OplDocumentSumOrderByAggregateInput
  }

  export type OplDocumentScalarWhereWithAggregatesInput = {
    AND?: OplDocumentScalarWhereWithAggregatesInput | OplDocumentScalarWhereWithAggregatesInput[]
    OR?: OplDocumentScalarWhereWithAggregatesInput[]
    NOT?: OplDocumentScalarWhereWithAggregatesInput | OplDocumentScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"OplDocument"> | number
    title?: StringWithAggregatesFilter<"OplDocument"> | string
    description?: StringNullableWithAggregatesFilter<"OplDocument"> | string | null
    fileName?: StringWithAggregatesFilter<"OplDocument"> | string
    fileType?: StringWithAggregatesFilter<"OplDocument"> | string
    filePath?: StringWithAggregatesFilter<"OplDocument"> | string
    template?: BoolWithAggregatesFilter<"OplDocument"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"OplDocument"> | Date | string
    uploadedBy?: IntWithAggregatesFilter<"OplDocument"> | number
    updatedAt?: DateTimeWithAggregatesFilter<"OplDocument"> | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter<"OplDocument"> | Date | string | null
  }

  export type FileWhereInput = {
    AND?: FileWhereInput | FileWhereInput[]
    OR?: FileWhereInput[]
    NOT?: FileWhereInput | FileWhereInput[]
    id?: IntFilter<"File"> | number
    originalName?: StringFilter<"File"> | string
    storedName?: StringFilter<"File"> | string
    fileType?: StringFilter<"File"> | string
    fileSize?: BigIntFilter<"File"> | bigint | number
    filePath?: StringFilter<"File"> | string
    uploadDate?: DateTimeFilter<"File"> | Date | string
    userId?: IntNullableFilter<"File"> | number | null
    courseId?: IntNullableFilter<"File"> | number | null
    user?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    course?: XOR<CourseNullableRelationFilter, CourseWhereInput> | null
  }

  export type FileOrderByWithRelationInput = {
    id?: SortOrder
    originalName?: SortOrder
    storedName?: SortOrder
    fileType?: SortOrder
    fileSize?: SortOrder
    filePath?: SortOrder
    uploadDate?: SortOrder
    userId?: SortOrderInput | SortOrder
    courseId?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
    course?: CourseOrderByWithRelationInput
  }

  export type FileWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: FileWhereInput | FileWhereInput[]
    OR?: FileWhereInput[]
    NOT?: FileWhereInput | FileWhereInput[]
    originalName?: StringFilter<"File"> | string
    storedName?: StringFilter<"File"> | string
    fileType?: StringFilter<"File"> | string
    fileSize?: BigIntFilter<"File"> | bigint | number
    filePath?: StringFilter<"File"> | string
    uploadDate?: DateTimeFilter<"File"> | Date | string
    userId?: IntNullableFilter<"File"> | number | null
    courseId?: IntNullableFilter<"File"> | number | null
    user?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    course?: XOR<CourseNullableRelationFilter, CourseWhereInput> | null
  }, "id">

  export type FileOrderByWithAggregationInput = {
    id?: SortOrder
    originalName?: SortOrder
    storedName?: SortOrder
    fileType?: SortOrder
    fileSize?: SortOrder
    filePath?: SortOrder
    uploadDate?: SortOrder
    userId?: SortOrderInput | SortOrder
    courseId?: SortOrderInput | SortOrder
    _count?: FileCountOrderByAggregateInput
    _avg?: FileAvgOrderByAggregateInput
    _max?: FileMaxOrderByAggregateInput
    _min?: FileMinOrderByAggregateInput
    _sum?: FileSumOrderByAggregateInput
  }

  export type FileScalarWhereWithAggregatesInput = {
    AND?: FileScalarWhereWithAggregatesInput | FileScalarWhereWithAggregatesInput[]
    OR?: FileScalarWhereWithAggregatesInput[]
    NOT?: FileScalarWhereWithAggregatesInput | FileScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"File"> | number
    originalName?: StringWithAggregatesFilter<"File"> | string
    storedName?: StringWithAggregatesFilter<"File"> | string
    fileType?: StringWithAggregatesFilter<"File"> | string
    fileSize?: BigIntWithAggregatesFilter<"File"> | bigint | number
    filePath?: StringWithAggregatesFilter<"File"> | string
    uploadDate?: DateTimeWithAggregatesFilter<"File"> | Date | string
    userId?: IntNullableWithAggregatesFilter<"File"> | number | null
    courseId?: IntNullableWithAggregatesFilter<"File"> | number | null
  }

  export type ProcessWhereInput = {
    AND?: ProcessWhereInput | ProcessWhereInput[]
    OR?: ProcessWhereInput[]
    NOT?: ProcessWhereInput | ProcessWhereInput[]
    id?: IntFilter<"Process"> | number
    pc_bluePrintNo?: StringFilter<"Process"> | string
    pc_imageBluePrint?: StringFilter<"Process"> | string
    pc_totalProcess?: IntFilter<"Process"> | number
    pc_userId?: StringFilter<"Process"> | string
    createdAt?: DateTimeFilter<"Process"> | Date | string
    updatedAt?: DateTimeFilter<"Process"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Process"> | Date | string | null
    user?: XOR<UserRelationFilter, UserWhereInput>
    courses?: CourseListRelationFilter
    completions?: UserCourseCompletionListRelationFilter
    processDetail?: ProcessDetailListRelationFilter
  }

  export type ProcessOrderByWithRelationInput = {
    id?: SortOrder
    pc_bluePrintNo?: SortOrder
    pc_imageBluePrint?: SortOrder
    pc_totalProcess?: SortOrder
    pc_userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
    courses?: CourseOrderByRelationAggregateInput
    completions?: UserCourseCompletionOrderByRelationAggregateInput
    processDetail?: ProcessDetailOrderByRelationAggregateInput
  }

  export type ProcessWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    pc_bluePrintNo?: string
    AND?: ProcessWhereInput | ProcessWhereInput[]
    OR?: ProcessWhereInput[]
    NOT?: ProcessWhereInput | ProcessWhereInput[]
    pc_imageBluePrint?: StringFilter<"Process"> | string
    pc_totalProcess?: IntFilter<"Process"> | number
    pc_userId?: StringFilter<"Process"> | string
    createdAt?: DateTimeFilter<"Process"> | Date | string
    updatedAt?: DateTimeFilter<"Process"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Process"> | Date | string | null
    user?: XOR<UserRelationFilter, UserWhereInput>
    courses?: CourseListRelationFilter
    completions?: UserCourseCompletionListRelationFilter
    processDetail?: ProcessDetailListRelationFilter
  }, "id" | "pc_bluePrintNo">

  export type ProcessOrderByWithAggregationInput = {
    id?: SortOrder
    pc_bluePrintNo?: SortOrder
    pc_imageBluePrint?: SortOrder
    pc_totalProcess?: SortOrder
    pc_userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: ProcessCountOrderByAggregateInput
    _avg?: ProcessAvgOrderByAggregateInput
    _max?: ProcessMaxOrderByAggregateInput
    _min?: ProcessMinOrderByAggregateInput
    _sum?: ProcessSumOrderByAggregateInput
  }

  export type ProcessScalarWhereWithAggregatesInput = {
    AND?: ProcessScalarWhereWithAggregatesInput | ProcessScalarWhereWithAggregatesInput[]
    OR?: ProcessScalarWhereWithAggregatesInput[]
    NOT?: ProcessScalarWhereWithAggregatesInput | ProcessScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Process"> | number
    pc_bluePrintNo?: StringWithAggregatesFilter<"Process"> | string
    pc_imageBluePrint?: StringWithAggregatesFilter<"Process"> | string
    pc_totalProcess?: IntWithAggregatesFilter<"Process"> | number
    pc_userId?: StringWithAggregatesFilter<"Process"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Process"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Process"> | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter<"Process"> | Date | string | null
  }

  export type ProcessDetailWhereInput = {
    AND?: ProcessDetailWhereInput | ProcessDetailWhereInput[]
    OR?: ProcessDetailWhereInput[]
    NOT?: ProcessDetailWhereInput | ProcessDetailWhereInput[]
    id?: IntFilter<"ProcessDetail"> | number
    pc_bluePrintNo?: StringFilter<"ProcessDetail"> | string
    pc_processTitle?: StringFilter<"ProcessDetail"> | string
    pc_amountDay?: IntFilter<"ProcessDetail"> | number
    pc_reasonType?: StringFilter<"ProcessDetail"> | string
    process?: XOR<ProcessRelationFilter, ProcessWhereInput>
    processBranch?: ProcessBranchListRelationFilter
    processMat?: ProcessMatListRelationFilter
    processBom?: ProcessBomListRelationFilter
  }

  export type ProcessDetailOrderByWithRelationInput = {
    id?: SortOrder
    pc_bluePrintNo?: SortOrder
    pc_processTitle?: SortOrder
    pc_amountDay?: SortOrder
    pc_reasonType?: SortOrder
    process?: ProcessOrderByWithRelationInput
    processBranch?: ProcessBranchOrderByRelationAggregateInput
    processMat?: ProcessMatOrderByRelationAggregateInput
    processBom?: ProcessBomOrderByRelationAggregateInput
  }

  export type ProcessDetailWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ProcessDetailWhereInput | ProcessDetailWhereInput[]
    OR?: ProcessDetailWhereInput[]
    NOT?: ProcessDetailWhereInput | ProcessDetailWhereInput[]
    pc_bluePrintNo?: StringFilter<"ProcessDetail"> | string
    pc_processTitle?: StringFilter<"ProcessDetail"> | string
    pc_amountDay?: IntFilter<"ProcessDetail"> | number
    pc_reasonType?: StringFilter<"ProcessDetail"> | string
    process?: XOR<ProcessRelationFilter, ProcessWhereInput>
    processBranch?: ProcessBranchListRelationFilter
    processMat?: ProcessMatListRelationFilter
    processBom?: ProcessBomListRelationFilter
  }, "id">

  export type ProcessDetailOrderByWithAggregationInput = {
    id?: SortOrder
    pc_bluePrintNo?: SortOrder
    pc_processTitle?: SortOrder
    pc_amountDay?: SortOrder
    pc_reasonType?: SortOrder
    _count?: ProcessDetailCountOrderByAggregateInput
    _avg?: ProcessDetailAvgOrderByAggregateInput
    _max?: ProcessDetailMaxOrderByAggregateInput
    _min?: ProcessDetailMinOrderByAggregateInput
    _sum?: ProcessDetailSumOrderByAggregateInput
  }

  export type ProcessDetailScalarWhereWithAggregatesInput = {
    AND?: ProcessDetailScalarWhereWithAggregatesInput | ProcessDetailScalarWhereWithAggregatesInput[]
    OR?: ProcessDetailScalarWhereWithAggregatesInput[]
    NOT?: ProcessDetailScalarWhereWithAggregatesInput | ProcessDetailScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ProcessDetail"> | number
    pc_bluePrintNo?: StringWithAggregatesFilter<"ProcessDetail"> | string
    pc_processTitle?: StringWithAggregatesFilter<"ProcessDetail"> | string
    pc_amountDay?: IntWithAggregatesFilter<"ProcessDetail"> | number
    pc_reasonType?: StringWithAggregatesFilter<"ProcessDetail"> | string
  }

  export type ProcessBranchWhereInput = {
    AND?: ProcessBranchWhereInput | ProcessBranchWhereInput[]
    OR?: ProcessBranchWhereInput[]
    NOT?: ProcessBranchWhereInput | ProcessBranchWhereInput[]
    id?: IntFilter<"ProcessBranch"> | number
    pc_processDetailId?: IntFilter<"ProcessBranch"> | number
    pc_remark?: StringFilter<"ProcessBranch"> | string
    processDetail?: XOR<ProcessDetailRelationFilter, ProcessDetailWhereInput>
  }

  export type ProcessBranchOrderByWithRelationInput = {
    id?: SortOrder
    pc_processDetailId?: SortOrder
    pc_remark?: SortOrder
    processDetail?: ProcessDetailOrderByWithRelationInput
  }

  export type ProcessBranchWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ProcessBranchWhereInput | ProcessBranchWhereInput[]
    OR?: ProcessBranchWhereInput[]
    NOT?: ProcessBranchWhereInput | ProcessBranchWhereInput[]
    pc_processDetailId?: IntFilter<"ProcessBranch"> | number
    pc_remark?: StringFilter<"ProcessBranch"> | string
    processDetail?: XOR<ProcessDetailRelationFilter, ProcessDetailWhereInput>
  }, "id">

  export type ProcessBranchOrderByWithAggregationInput = {
    id?: SortOrder
    pc_processDetailId?: SortOrder
    pc_remark?: SortOrder
    _count?: ProcessBranchCountOrderByAggregateInput
    _avg?: ProcessBranchAvgOrderByAggregateInput
    _max?: ProcessBranchMaxOrderByAggregateInput
    _min?: ProcessBranchMinOrderByAggregateInput
    _sum?: ProcessBranchSumOrderByAggregateInput
  }

  export type ProcessBranchScalarWhereWithAggregatesInput = {
    AND?: ProcessBranchScalarWhereWithAggregatesInput | ProcessBranchScalarWhereWithAggregatesInput[]
    OR?: ProcessBranchScalarWhereWithAggregatesInput[]
    NOT?: ProcessBranchScalarWhereWithAggregatesInput | ProcessBranchScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ProcessBranch"> | number
    pc_processDetailId?: IntWithAggregatesFilter<"ProcessBranch"> | number
    pc_remark?: StringWithAggregatesFilter<"ProcessBranch"> | string
  }

  export type ProcessMatWhereInput = {
    AND?: ProcessMatWhereInput | ProcessMatWhereInput[]
    OR?: ProcessMatWhereInput[]
    NOT?: ProcessMatWhereInput | ProcessMatWhereInput[]
    id?: IntFilter<"ProcessMat"> | number
    pc_processDetailId?: IntFilter<"ProcessMat"> | number
    pc_matId?: StringFilter<"ProcessMat"> | string
    pc_matamount?: IntFilter<"ProcessMat"> | number
    stock?: XOR<StockRelationFilter, StockWhereInput>
    processDetail?: XOR<ProcessDetailRelationFilter, ProcessDetailWhereInput>
  }

  export type ProcessMatOrderByWithRelationInput = {
    id?: SortOrder
    pc_processDetailId?: SortOrder
    pc_matId?: SortOrder
    pc_matamount?: SortOrder
    stock?: StockOrderByWithRelationInput
    processDetail?: ProcessDetailOrderByWithRelationInput
  }

  export type ProcessMatWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ProcessMatWhereInput | ProcessMatWhereInput[]
    OR?: ProcessMatWhereInput[]
    NOT?: ProcessMatWhereInput | ProcessMatWhereInput[]
    pc_processDetailId?: IntFilter<"ProcessMat"> | number
    pc_matId?: StringFilter<"ProcessMat"> | string
    pc_matamount?: IntFilter<"ProcessMat"> | number
    stock?: XOR<StockRelationFilter, StockWhereInput>
    processDetail?: XOR<ProcessDetailRelationFilter, ProcessDetailWhereInput>
  }, "id">

  export type ProcessMatOrderByWithAggregationInput = {
    id?: SortOrder
    pc_processDetailId?: SortOrder
    pc_matId?: SortOrder
    pc_matamount?: SortOrder
    _count?: ProcessMatCountOrderByAggregateInput
    _avg?: ProcessMatAvgOrderByAggregateInput
    _max?: ProcessMatMaxOrderByAggregateInput
    _min?: ProcessMatMinOrderByAggregateInput
    _sum?: ProcessMatSumOrderByAggregateInput
  }

  export type ProcessMatScalarWhereWithAggregatesInput = {
    AND?: ProcessMatScalarWhereWithAggregatesInput | ProcessMatScalarWhereWithAggregatesInput[]
    OR?: ProcessMatScalarWhereWithAggregatesInput[]
    NOT?: ProcessMatScalarWhereWithAggregatesInput | ProcessMatScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ProcessMat"> | number
    pc_processDetailId?: IntWithAggregatesFilter<"ProcessMat"> | number
    pc_matId?: StringWithAggregatesFilter<"ProcessMat"> | string
    pc_matamount?: IntWithAggregatesFilter<"ProcessMat"> | number
  }

  export type ProcessBomWhereInput = {
    AND?: ProcessBomWhereInput | ProcessBomWhereInput[]
    OR?: ProcessBomWhereInput[]
    NOT?: ProcessBomWhereInput | ProcessBomWhereInput[]
    id?: IntFilter<"ProcessBom"> | number
    pc_processDetailId?: IntFilter<"ProcessBom"> | number
    pc_bomId?: StringFilter<"ProcessBom"> | string
    pc_bomamount?: IntFilter<"ProcessBom"> | number
    stock?: XOR<StockRelationFilter, StockWhereInput>
    processDetail?: XOR<ProcessDetailRelationFilter, ProcessDetailWhereInput>
  }

  export type ProcessBomOrderByWithRelationInput = {
    id?: SortOrder
    pc_processDetailId?: SortOrder
    pc_bomId?: SortOrder
    pc_bomamount?: SortOrder
    stock?: StockOrderByWithRelationInput
    processDetail?: ProcessDetailOrderByWithRelationInput
  }

  export type ProcessBomWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ProcessBomWhereInput | ProcessBomWhereInput[]
    OR?: ProcessBomWhereInput[]
    NOT?: ProcessBomWhereInput | ProcessBomWhereInput[]
    pc_processDetailId?: IntFilter<"ProcessBom"> | number
    pc_bomId?: StringFilter<"ProcessBom"> | string
    pc_bomamount?: IntFilter<"ProcessBom"> | number
    stock?: XOR<StockRelationFilter, StockWhereInput>
    processDetail?: XOR<ProcessDetailRelationFilter, ProcessDetailWhereInput>
  }, "id">

  export type ProcessBomOrderByWithAggregationInput = {
    id?: SortOrder
    pc_processDetailId?: SortOrder
    pc_bomId?: SortOrder
    pc_bomamount?: SortOrder
    _count?: ProcessBomCountOrderByAggregateInput
    _avg?: ProcessBomAvgOrderByAggregateInput
    _max?: ProcessBomMaxOrderByAggregateInput
    _min?: ProcessBomMinOrderByAggregateInput
    _sum?: ProcessBomSumOrderByAggregateInput
  }

  export type ProcessBomScalarWhereWithAggregatesInput = {
    AND?: ProcessBomScalarWhereWithAggregatesInput | ProcessBomScalarWhereWithAggregatesInput[]
    OR?: ProcessBomScalarWhereWithAggregatesInput[]
    NOT?: ProcessBomScalarWhereWithAggregatesInput | ProcessBomScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ProcessBom"> | number
    pc_processDetailId?: IntWithAggregatesFilter<"ProcessBom"> | number
    pc_bomId?: StringWithAggregatesFilter<"ProcessBom"> | string
    pc_bomamount?: IntWithAggregatesFilter<"ProcessBom"> | number
  }

  export type ProjectWhereInput = {
    AND?: ProjectWhereInput | ProjectWhereInput[]
    OR?: ProjectWhereInput[]
    NOT?: ProjectWhereInput | ProjectWhereInput[]
    id?: IntFilter<"Project"> | number
    pj_bluePrintNo?: StringFilter<"Project"> | string
    pj_serialNumber?: StringFilter<"Project"> | string
    pj_projectName?: StringFilter<"Project"> | string
    pj_startDate?: DateTimeFilter<"Project"> | Date | string
    pj_endDate?: DateTimeFilter<"Project"> | Date | string
    pj_amountProduct?: IntFilter<"Project"> | number
    pj_totalDay?: IntFilter<"Project"> | number
    pj_imageProduct?: StringFilter<"Project"> | string
    pj_remark?: StringFilter<"Project"> | string
    pj_status?: StringFilter<"Project"> | string
    pj_type?: StringFilter<"Project"> | string
    pj_userId?: StringFilter<"Project"> | string
    createdAt?: DateTimeFilter<"Project"> | Date | string
    updatedAt?: DateTimeFilter<"Project"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Project"> | Date | string | null
    user?: XOR<UserRelationFilter, UserWhereInput>
    projectDetail?: ProjectDetailListRelationFilter
  }

  export type ProjectOrderByWithRelationInput = {
    id?: SortOrder
    pj_bluePrintNo?: SortOrder
    pj_serialNumber?: SortOrder
    pj_projectName?: SortOrder
    pj_startDate?: SortOrder
    pj_endDate?: SortOrder
    pj_amountProduct?: SortOrder
    pj_totalDay?: SortOrder
    pj_imageProduct?: SortOrder
    pj_remark?: SortOrder
    pj_status?: SortOrder
    pj_type?: SortOrder
    pj_userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
    projectDetail?: ProjectDetailOrderByRelationAggregateInput
  }

  export type ProjectWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ProjectWhereInput | ProjectWhereInput[]
    OR?: ProjectWhereInput[]
    NOT?: ProjectWhereInput | ProjectWhereInput[]
    pj_bluePrintNo?: StringFilter<"Project"> | string
    pj_serialNumber?: StringFilter<"Project"> | string
    pj_projectName?: StringFilter<"Project"> | string
    pj_startDate?: DateTimeFilter<"Project"> | Date | string
    pj_endDate?: DateTimeFilter<"Project"> | Date | string
    pj_amountProduct?: IntFilter<"Project"> | number
    pj_totalDay?: IntFilter<"Project"> | number
    pj_imageProduct?: StringFilter<"Project"> | string
    pj_remark?: StringFilter<"Project"> | string
    pj_status?: StringFilter<"Project"> | string
    pj_type?: StringFilter<"Project"> | string
    pj_userId?: StringFilter<"Project"> | string
    createdAt?: DateTimeFilter<"Project"> | Date | string
    updatedAt?: DateTimeFilter<"Project"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Project"> | Date | string | null
    user?: XOR<UserRelationFilter, UserWhereInput>
    projectDetail?: ProjectDetailListRelationFilter
  }, "id">

  export type ProjectOrderByWithAggregationInput = {
    id?: SortOrder
    pj_bluePrintNo?: SortOrder
    pj_serialNumber?: SortOrder
    pj_projectName?: SortOrder
    pj_startDate?: SortOrder
    pj_endDate?: SortOrder
    pj_amountProduct?: SortOrder
    pj_totalDay?: SortOrder
    pj_imageProduct?: SortOrder
    pj_remark?: SortOrder
    pj_status?: SortOrder
    pj_type?: SortOrder
    pj_userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: ProjectCountOrderByAggregateInput
    _avg?: ProjectAvgOrderByAggregateInput
    _max?: ProjectMaxOrderByAggregateInput
    _min?: ProjectMinOrderByAggregateInput
    _sum?: ProjectSumOrderByAggregateInput
  }

  export type ProjectScalarWhereWithAggregatesInput = {
    AND?: ProjectScalarWhereWithAggregatesInput | ProjectScalarWhereWithAggregatesInput[]
    OR?: ProjectScalarWhereWithAggregatesInput[]
    NOT?: ProjectScalarWhereWithAggregatesInput | ProjectScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Project"> | number
    pj_bluePrintNo?: StringWithAggregatesFilter<"Project"> | string
    pj_serialNumber?: StringWithAggregatesFilter<"Project"> | string
    pj_projectName?: StringWithAggregatesFilter<"Project"> | string
    pj_startDate?: DateTimeWithAggregatesFilter<"Project"> | Date | string
    pj_endDate?: DateTimeWithAggregatesFilter<"Project"> | Date | string
    pj_amountProduct?: IntWithAggregatesFilter<"Project"> | number
    pj_totalDay?: IntWithAggregatesFilter<"Project"> | number
    pj_imageProduct?: StringWithAggregatesFilter<"Project"> | string
    pj_remark?: StringWithAggregatesFilter<"Project"> | string
    pj_status?: StringWithAggregatesFilter<"Project"> | string
    pj_type?: StringWithAggregatesFilter<"Project"> | string
    pj_userId?: StringWithAggregatesFilter<"Project"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Project"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Project"> | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter<"Project"> | Date | string | null
  }

  export type ProjectDetailWhereInput = {
    AND?: ProjectDetailWhereInput | ProjectDetailWhereInput[]
    OR?: ProjectDetailWhereInput[]
    NOT?: ProjectDetailWhereInput | ProjectDetailWhereInput[]
    id?: IntFilter<"ProjectDetail"> | number
    pj_projectId?: IntFilter<"ProjectDetail"> | number
    pj_bluePrintNo?: StringFilter<"ProjectDetail"> | string
    pj_serialNumber?: StringFilter<"ProjectDetail"> | string
    pj_processTitle?: StringFilter<"ProjectDetail"> | string
    pj_amountDay?: IntFilter<"ProjectDetail"> | number
    pj_reasonType?: StringFilter<"ProjectDetail"> | string
    pj_statusPc?: StringFilter<"ProjectDetail"> | string
    project?: XOR<ProjectRelationFilter, ProjectWhereInput>
    projectBranch?: ProjectBranchListRelationFilter
    projectMat?: ProjectMatListRelationFilter
    projectBom?: ProjectBomListRelationFilter
    ProjectResUser?: ProjectResUserListRelationFilter
  }

  export type ProjectDetailOrderByWithRelationInput = {
    id?: SortOrder
    pj_projectId?: SortOrder
    pj_bluePrintNo?: SortOrder
    pj_serialNumber?: SortOrder
    pj_processTitle?: SortOrder
    pj_amountDay?: SortOrder
    pj_reasonType?: SortOrder
    pj_statusPc?: SortOrder
    project?: ProjectOrderByWithRelationInput
    projectBranch?: ProjectBranchOrderByRelationAggregateInput
    projectMat?: ProjectMatOrderByRelationAggregateInput
    projectBom?: ProjectBomOrderByRelationAggregateInput
    ProjectResUser?: ProjectResUserOrderByRelationAggregateInput
  }

  export type ProjectDetailWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ProjectDetailWhereInput | ProjectDetailWhereInput[]
    OR?: ProjectDetailWhereInput[]
    NOT?: ProjectDetailWhereInput | ProjectDetailWhereInput[]
    pj_projectId?: IntFilter<"ProjectDetail"> | number
    pj_bluePrintNo?: StringFilter<"ProjectDetail"> | string
    pj_serialNumber?: StringFilter<"ProjectDetail"> | string
    pj_processTitle?: StringFilter<"ProjectDetail"> | string
    pj_amountDay?: IntFilter<"ProjectDetail"> | number
    pj_reasonType?: StringFilter<"ProjectDetail"> | string
    pj_statusPc?: StringFilter<"ProjectDetail"> | string
    project?: XOR<ProjectRelationFilter, ProjectWhereInput>
    projectBranch?: ProjectBranchListRelationFilter
    projectMat?: ProjectMatListRelationFilter
    projectBom?: ProjectBomListRelationFilter
    ProjectResUser?: ProjectResUserListRelationFilter
  }, "id">

  export type ProjectDetailOrderByWithAggregationInput = {
    id?: SortOrder
    pj_projectId?: SortOrder
    pj_bluePrintNo?: SortOrder
    pj_serialNumber?: SortOrder
    pj_processTitle?: SortOrder
    pj_amountDay?: SortOrder
    pj_reasonType?: SortOrder
    pj_statusPc?: SortOrder
    _count?: ProjectDetailCountOrderByAggregateInput
    _avg?: ProjectDetailAvgOrderByAggregateInput
    _max?: ProjectDetailMaxOrderByAggregateInput
    _min?: ProjectDetailMinOrderByAggregateInput
    _sum?: ProjectDetailSumOrderByAggregateInput
  }

  export type ProjectDetailScalarWhereWithAggregatesInput = {
    AND?: ProjectDetailScalarWhereWithAggregatesInput | ProjectDetailScalarWhereWithAggregatesInput[]
    OR?: ProjectDetailScalarWhereWithAggregatesInput[]
    NOT?: ProjectDetailScalarWhereWithAggregatesInput | ProjectDetailScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ProjectDetail"> | number
    pj_projectId?: IntWithAggregatesFilter<"ProjectDetail"> | number
    pj_bluePrintNo?: StringWithAggregatesFilter<"ProjectDetail"> | string
    pj_serialNumber?: StringWithAggregatesFilter<"ProjectDetail"> | string
    pj_processTitle?: StringWithAggregatesFilter<"ProjectDetail"> | string
    pj_amountDay?: IntWithAggregatesFilter<"ProjectDetail"> | number
    pj_reasonType?: StringWithAggregatesFilter<"ProjectDetail"> | string
    pj_statusPc?: StringWithAggregatesFilter<"ProjectDetail"> | string
  }

  export type ProjectBranchWhereInput = {
    AND?: ProjectBranchWhereInput | ProjectBranchWhereInput[]
    OR?: ProjectBranchWhereInput[]
    NOT?: ProjectBranchWhereInput | ProjectBranchWhereInput[]
    id?: IntFilter<"ProjectBranch"> | number
    pj_projectDetailId?: IntFilter<"ProjectBranch"> | number
    pj_remark?: StringFilter<"ProjectBranch"> | string
    projectDetail?: XOR<ProjectDetailRelationFilter, ProjectDetailWhereInput>
  }

  export type ProjectBranchOrderByWithRelationInput = {
    id?: SortOrder
    pj_projectDetailId?: SortOrder
    pj_remark?: SortOrder
    projectDetail?: ProjectDetailOrderByWithRelationInput
  }

  export type ProjectBranchWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ProjectBranchWhereInput | ProjectBranchWhereInput[]
    OR?: ProjectBranchWhereInput[]
    NOT?: ProjectBranchWhereInput | ProjectBranchWhereInput[]
    pj_projectDetailId?: IntFilter<"ProjectBranch"> | number
    pj_remark?: StringFilter<"ProjectBranch"> | string
    projectDetail?: XOR<ProjectDetailRelationFilter, ProjectDetailWhereInput>
  }, "id">

  export type ProjectBranchOrderByWithAggregationInput = {
    id?: SortOrder
    pj_projectDetailId?: SortOrder
    pj_remark?: SortOrder
    _count?: ProjectBranchCountOrderByAggregateInput
    _avg?: ProjectBranchAvgOrderByAggregateInput
    _max?: ProjectBranchMaxOrderByAggregateInput
    _min?: ProjectBranchMinOrderByAggregateInput
    _sum?: ProjectBranchSumOrderByAggregateInput
  }

  export type ProjectBranchScalarWhereWithAggregatesInput = {
    AND?: ProjectBranchScalarWhereWithAggregatesInput | ProjectBranchScalarWhereWithAggregatesInput[]
    OR?: ProjectBranchScalarWhereWithAggregatesInput[]
    NOT?: ProjectBranchScalarWhereWithAggregatesInput | ProjectBranchScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ProjectBranch"> | number
    pj_projectDetailId?: IntWithAggregatesFilter<"ProjectBranch"> | number
    pj_remark?: StringWithAggregatesFilter<"ProjectBranch"> | string
  }

  export type ProjectMatWhereInput = {
    AND?: ProjectMatWhereInput | ProjectMatWhereInput[]
    OR?: ProjectMatWhereInput[]
    NOT?: ProjectMatWhereInput | ProjectMatWhereInput[]
    id?: IntFilter<"ProjectMat"> | number
    pj_projectDetailId?: IntFilter<"ProjectMat"> | number
    pj_matId?: StringFilter<"ProjectMat"> | string
    pj_matamount?: IntFilter<"ProjectMat"> | number
    pj_matTatal?: IntFilter<"ProjectMat"> | number
    stock?: XOR<StockRelationFilter, StockWhereInput>
    projectDetail?: XOR<ProjectDetailRelationFilter, ProjectDetailWhereInput>
  }

  export type ProjectMatOrderByWithRelationInput = {
    id?: SortOrder
    pj_projectDetailId?: SortOrder
    pj_matId?: SortOrder
    pj_matamount?: SortOrder
    pj_matTatal?: SortOrder
    stock?: StockOrderByWithRelationInput
    projectDetail?: ProjectDetailOrderByWithRelationInput
  }

  export type ProjectMatWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ProjectMatWhereInput | ProjectMatWhereInput[]
    OR?: ProjectMatWhereInput[]
    NOT?: ProjectMatWhereInput | ProjectMatWhereInput[]
    pj_projectDetailId?: IntFilter<"ProjectMat"> | number
    pj_matId?: StringFilter<"ProjectMat"> | string
    pj_matamount?: IntFilter<"ProjectMat"> | number
    pj_matTatal?: IntFilter<"ProjectMat"> | number
    stock?: XOR<StockRelationFilter, StockWhereInput>
    projectDetail?: XOR<ProjectDetailRelationFilter, ProjectDetailWhereInput>
  }, "id">

  export type ProjectMatOrderByWithAggregationInput = {
    id?: SortOrder
    pj_projectDetailId?: SortOrder
    pj_matId?: SortOrder
    pj_matamount?: SortOrder
    pj_matTatal?: SortOrder
    _count?: ProjectMatCountOrderByAggregateInput
    _avg?: ProjectMatAvgOrderByAggregateInput
    _max?: ProjectMatMaxOrderByAggregateInput
    _min?: ProjectMatMinOrderByAggregateInput
    _sum?: ProjectMatSumOrderByAggregateInput
  }

  export type ProjectMatScalarWhereWithAggregatesInput = {
    AND?: ProjectMatScalarWhereWithAggregatesInput | ProjectMatScalarWhereWithAggregatesInput[]
    OR?: ProjectMatScalarWhereWithAggregatesInput[]
    NOT?: ProjectMatScalarWhereWithAggregatesInput | ProjectMatScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ProjectMat"> | number
    pj_projectDetailId?: IntWithAggregatesFilter<"ProjectMat"> | number
    pj_matId?: StringWithAggregatesFilter<"ProjectMat"> | string
    pj_matamount?: IntWithAggregatesFilter<"ProjectMat"> | number
    pj_matTatal?: IntWithAggregatesFilter<"ProjectMat"> | number
  }

  export type ProjectBomWhereInput = {
    AND?: ProjectBomWhereInput | ProjectBomWhereInput[]
    OR?: ProjectBomWhereInput[]
    NOT?: ProjectBomWhereInput | ProjectBomWhereInput[]
    id?: IntFilter<"ProjectBom"> | number
    pj_projectDetailId?: IntFilter<"ProjectBom"> | number
    pj_bomId?: StringFilter<"ProjectBom"> | string
    pj_bomamount?: IntFilter<"ProjectBom"> | number
    pj_bomTatal?: IntFilter<"ProjectBom"> | number
    stock?: XOR<StockRelationFilter, StockWhereInput>
    projectDetail?: XOR<ProjectDetailRelationFilter, ProjectDetailWhereInput>
  }

  export type ProjectBomOrderByWithRelationInput = {
    id?: SortOrder
    pj_projectDetailId?: SortOrder
    pj_bomId?: SortOrder
    pj_bomamount?: SortOrder
    pj_bomTatal?: SortOrder
    stock?: StockOrderByWithRelationInput
    projectDetail?: ProjectDetailOrderByWithRelationInput
  }

  export type ProjectBomWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ProjectBomWhereInput | ProjectBomWhereInput[]
    OR?: ProjectBomWhereInput[]
    NOT?: ProjectBomWhereInput | ProjectBomWhereInput[]
    pj_projectDetailId?: IntFilter<"ProjectBom"> | number
    pj_bomId?: StringFilter<"ProjectBom"> | string
    pj_bomamount?: IntFilter<"ProjectBom"> | number
    pj_bomTatal?: IntFilter<"ProjectBom"> | number
    stock?: XOR<StockRelationFilter, StockWhereInput>
    projectDetail?: XOR<ProjectDetailRelationFilter, ProjectDetailWhereInput>
  }, "id">

  export type ProjectBomOrderByWithAggregationInput = {
    id?: SortOrder
    pj_projectDetailId?: SortOrder
    pj_bomId?: SortOrder
    pj_bomamount?: SortOrder
    pj_bomTatal?: SortOrder
    _count?: ProjectBomCountOrderByAggregateInput
    _avg?: ProjectBomAvgOrderByAggregateInput
    _max?: ProjectBomMaxOrderByAggregateInput
    _min?: ProjectBomMinOrderByAggregateInput
    _sum?: ProjectBomSumOrderByAggregateInput
  }

  export type ProjectBomScalarWhereWithAggregatesInput = {
    AND?: ProjectBomScalarWhereWithAggregatesInput | ProjectBomScalarWhereWithAggregatesInput[]
    OR?: ProjectBomScalarWhereWithAggregatesInput[]
    NOT?: ProjectBomScalarWhereWithAggregatesInput | ProjectBomScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ProjectBom"> | number
    pj_projectDetailId?: IntWithAggregatesFilter<"ProjectBom"> | number
    pj_bomId?: StringWithAggregatesFilter<"ProjectBom"> | string
    pj_bomamount?: IntWithAggregatesFilter<"ProjectBom"> | number
    pj_bomTatal?: IntWithAggregatesFilter<"ProjectBom"> | number
  }

  export type ProjectResUserWhereInput = {
    AND?: ProjectResUserWhereInput | ProjectResUserWhereInput[]
    OR?: ProjectResUserWhereInput[]
    NOT?: ProjectResUserWhereInput | ProjectResUserWhereInput[]
    id?: IntFilter<"ProjectResUser"> | number
    pj_projectDetailId?: IntFilter<"ProjectResUser"> | number
    pj_userId?: StringFilter<"ProjectResUser"> | string
    projectDetail?: XOR<ProjectDetailRelationFilter, ProjectDetailWhereInput>
  }

  export type ProjectResUserOrderByWithRelationInput = {
    id?: SortOrder
    pj_projectDetailId?: SortOrder
    pj_userId?: SortOrder
    projectDetail?: ProjectDetailOrderByWithRelationInput
  }

  export type ProjectResUserWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ProjectResUserWhereInput | ProjectResUserWhereInput[]
    OR?: ProjectResUserWhereInput[]
    NOT?: ProjectResUserWhereInput | ProjectResUserWhereInput[]
    pj_projectDetailId?: IntFilter<"ProjectResUser"> | number
    pj_userId?: StringFilter<"ProjectResUser"> | string
    projectDetail?: XOR<ProjectDetailRelationFilter, ProjectDetailWhereInput>
  }, "id">

  export type ProjectResUserOrderByWithAggregationInput = {
    id?: SortOrder
    pj_projectDetailId?: SortOrder
    pj_userId?: SortOrder
    _count?: ProjectResUserCountOrderByAggregateInput
    _avg?: ProjectResUserAvgOrderByAggregateInput
    _max?: ProjectResUserMaxOrderByAggregateInput
    _min?: ProjectResUserMinOrderByAggregateInput
    _sum?: ProjectResUserSumOrderByAggregateInput
  }

  export type ProjectResUserScalarWhereWithAggregatesInput = {
    AND?: ProjectResUserScalarWhereWithAggregatesInput | ProjectResUserScalarWhereWithAggregatesInput[]
    OR?: ProjectResUserScalarWhereWithAggregatesInput[]
    NOT?: ProjectResUserScalarWhereWithAggregatesInput | ProjectResUserScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ProjectResUser"> | number
    pj_projectDetailId?: IntWithAggregatesFilter<"ProjectResUser"> | number
    pj_userId?: StringWithAggregatesFilter<"ProjectResUser"> | string
  }

  export type CompanyHourWhereInput = {
    AND?: CompanyHourWhereInput | CompanyHourWhereInput[]
    OR?: CompanyHourWhereInput[]
    NOT?: CompanyHourWhereInput | CompanyHourWhereInput[]
    id?: IntFilter<"CompanyHour"> | number
    hour?: IntFilter<"CompanyHour"> | number
    createdAt?: DateTimeFilter<"CompanyHour"> | Date | string
    updatedAt?: DateTimeFilter<"CompanyHour"> | Date | string
  }

  export type CompanyHourOrderByWithRelationInput = {
    id?: SortOrder
    hour?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CompanyHourWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: CompanyHourWhereInput | CompanyHourWhereInput[]
    OR?: CompanyHourWhereInput[]
    NOT?: CompanyHourWhereInput | CompanyHourWhereInput[]
    hour?: IntFilter<"CompanyHour"> | number
    createdAt?: DateTimeFilter<"CompanyHour"> | Date | string
    updatedAt?: DateTimeFilter<"CompanyHour"> | Date | string
  }, "id">

  export type CompanyHourOrderByWithAggregationInput = {
    id?: SortOrder
    hour?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CompanyHourCountOrderByAggregateInput
    _avg?: CompanyHourAvgOrderByAggregateInput
    _max?: CompanyHourMaxOrderByAggregateInput
    _min?: CompanyHourMinOrderByAggregateInput
    _sum?: CompanyHourSumOrderByAggregateInput
  }

  export type CompanyHourScalarWhereWithAggregatesInput = {
    AND?: CompanyHourScalarWhereWithAggregatesInput | CompanyHourScalarWhereWithAggregatesInput[]
    OR?: CompanyHourScalarWhereWithAggregatesInput[]
    NOT?: CompanyHourScalarWhereWithAggregatesInput | CompanyHourScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"CompanyHour"> | number
    hour?: IntWithAggregatesFilter<"CompanyHour"> | number
    createdAt?: DateTimeWithAggregatesFilter<"CompanyHour"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CompanyHour"> | Date | string
  }

  export type StockWhereInput = {
    AND?: StockWhereInput | StockWhereInput[]
    OR?: StockWhereInput[]
    NOT?: StockWhereInput | StockWhereInput[]
    id?: IntFilter<"Stock"> | number
    stockId?: StringFilter<"Stock"> | string
    stockName?: StringFilter<"Stock"> | string
    stockQuantity?: IntFilter<"Stock"> | number
    stockType?: StringFilter<"Stock"> | string
    stockTypeId?: IntFilter<"Stock"> | number
    stockImage?: StringNullableFilter<"Stock"> | string | null
    createdAt?: DateTimeFilter<"Stock"> | Date | string
    updatedAt?: DateTimeFilter<"Stock"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Stock"> | Date | string | null
    processMat?: ProcessMatListRelationFilter
    processBom?: ProcessBomListRelationFilter
    projectMat?: ProjectMatListRelationFilter
    projectBom?: ProjectBomListRelationFilter
  }

  export type StockOrderByWithRelationInput = {
    id?: SortOrder
    stockId?: SortOrder
    stockName?: SortOrder
    stockQuantity?: SortOrder
    stockType?: SortOrder
    stockTypeId?: SortOrder
    stockImage?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    processMat?: ProcessMatOrderByRelationAggregateInput
    processBom?: ProcessBomOrderByRelationAggregateInput
    projectMat?: ProjectMatOrderByRelationAggregateInput
    projectBom?: ProjectBomOrderByRelationAggregateInput
  }

  export type StockWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    stockId?: string
    AND?: StockWhereInput | StockWhereInput[]
    OR?: StockWhereInput[]
    NOT?: StockWhereInput | StockWhereInput[]
    stockName?: StringFilter<"Stock"> | string
    stockQuantity?: IntFilter<"Stock"> | number
    stockType?: StringFilter<"Stock"> | string
    stockTypeId?: IntFilter<"Stock"> | number
    stockImage?: StringNullableFilter<"Stock"> | string | null
    createdAt?: DateTimeFilter<"Stock"> | Date | string
    updatedAt?: DateTimeFilter<"Stock"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Stock"> | Date | string | null
    processMat?: ProcessMatListRelationFilter
    processBom?: ProcessBomListRelationFilter
    projectMat?: ProjectMatListRelationFilter
    projectBom?: ProjectBomListRelationFilter
  }, "id" | "stockId">

  export type StockOrderByWithAggregationInput = {
    id?: SortOrder
    stockId?: SortOrder
    stockName?: SortOrder
    stockQuantity?: SortOrder
    stockType?: SortOrder
    stockTypeId?: SortOrder
    stockImage?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: StockCountOrderByAggregateInput
    _avg?: StockAvgOrderByAggregateInput
    _max?: StockMaxOrderByAggregateInput
    _min?: StockMinOrderByAggregateInput
    _sum?: StockSumOrderByAggregateInput
  }

  export type StockScalarWhereWithAggregatesInput = {
    AND?: StockScalarWhereWithAggregatesInput | StockScalarWhereWithAggregatesInput[]
    OR?: StockScalarWhereWithAggregatesInput[]
    NOT?: StockScalarWhereWithAggregatesInput | StockScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Stock"> | number
    stockId?: StringWithAggregatesFilter<"Stock"> | string
    stockName?: StringWithAggregatesFilter<"Stock"> | string
    stockQuantity?: IntWithAggregatesFilter<"Stock"> | number
    stockType?: StringWithAggregatesFilter<"Stock"> | string
    stockTypeId?: IntWithAggregatesFilter<"Stock"> | number
    stockImage?: StringNullableWithAggregatesFilter<"Stock"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Stock"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Stock"> | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter<"Stock"> | Date | string | null
  }

  export type ReasonStockNGWhereInput = {
    AND?: ReasonStockNGWhereInput | ReasonStockNGWhereInput[]
    OR?: ReasonStockNGWhereInput[]
    NOT?: ReasonStockNGWhereInput | ReasonStockNGWhereInput[]
    id?: IntFilter<"ReasonStockNG"> | number
    reasonstockName?: StringFilter<"ReasonStockNG"> | string
    createdAt?: DateTimeFilter<"ReasonStockNG"> | Date | string
    updatedAt?: DateTimeFilter<"ReasonStockNG"> | Date | string
    deletedAt?: DateTimeNullableFilter<"ReasonStockNG"> | Date | string | null
  }

  export type ReasonStockNGOrderByWithRelationInput = {
    id?: SortOrder
    reasonstockName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
  }

  export type ReasonStockNGWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ReasonStockNGWhereInput | ReasonStockNGWhereInput[]
    OR?: ReasonStockNGWhereInput[]
    NOT?: ReasonStockNGWhereInput | ReasonStockNGWhereInput[]
    reasonstockName?: StringFilter<"ReasonStockNG"> | string
    createdAt?: DateTimeFilter<"ReasonStockNG"> | Date | string
    updatedAt?: DateTimeFilter<"ReasonStockNG"> | Date | string
    deletedAt?: DateTimeNullableFilter<"ReasonStockNG"> | Date | string | null
  }, "id">

  export type ReasonStockNGOrderByWithAggregationInput = {
    id?: SortOrder
    reasonstockName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: ReasonStockNGCountOrderByAggregateInput
    _avg?: ReasonStockNGAvgOrderByAggregateInput
    _max?: ReasonStockNGMaxOrderByAggregateInput
    _min?: ReasonStockNGMinOrderByAggregateInput
    _sum?: ReasonStockNGSumOrderByAggregateInput
  }

  export type ReasonStockNGScalarWhereWithAggregatesInput = {
    AND?: ReasonStockNGScalarWhereWithAggregatesInput | ReasonStockNGScalarWhereWithAggregatesInput[]
    OR?: ReasonStockNGScalarWhereWithAggregatesInput[]
    NOT?: ReasonStockNGScalarWhereWithAggregatesInput | ReasonStockNGScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ReasonStockNG"> | number
    reasonstockName?: StringWithAggregatesFilter<"ReasonStockNG"> | string
    createdAt?: DateTimeWithAggregatesFilter<"ReasonStockNG"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ReasonStockNG"> | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter<"ReasonStockNG"> | Date | string | null
  }

  export type ReasonTypeNGWhereInput = {
    AND?: ReasonTypeNGWhereInput | ReasonTypeNGWhereInput[]
    OR?: ReasonTypeNGWhereInput[]
    NOT?: ReasonTypeNGWhereInput | ReasonTypeNGWhereInput[]
    id?: IntFilter<"ReasonTypeNG"> | number
    reasontypeName?: StringFilter<"ReasonTypeNG"> | string
    createdAt?: DateTimeFilter<"ReasonTypeNG"> | Date | string
    updatedAt?: DateTimeFilter<"ReasonTypeNG"> | Date | string
    deletedAt?: DateTimeNullableFilter<"ReasonTypeNG"> | Date | string | null
    reasondDetail?: ReasonDetailListRelationFilter
  }

  export type ReasonTypeNGOrderByWithRelationInput = {
    id?: SortOrder
    reasontypeName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    reasondDetail?: ReasonDetailOrderByRelationAggregateInput
  }

  export type ReasonTypeNGWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ReasonTypeNGWhereInput | ReasonTypeNGWhereInput[]
    OR?: ReasonTypeNGWhereInput[]
    NOT?: ReasonTypeNGWhereInput | ReasonTypeNGWhereInput[]
    reasontypeName?: StringFilter<"ReasonTypeNG"> | string
    createdAt?: DateTimeFilter<"ReasonTypeNG"> | Date | string
    updatedAt?: DateTimeFilter<"ReasonTypeNG"> | Date | string
    deletedAt?: DateTimeNullableFilter<"ReasonTypeNG"> | Date | string | null
    reasondDetail?: ReasonDetailListRelationFilter
  }, "id">

  export type ReasonTypeNGOrderByWithAggregationInput = {
    id?: SortOrder
    reasontypeName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: ReasonTypeNGCountOrderByAggregateInput
    _avg?: ReasonTypeNGAvgOrderByAggregateInput
    _max?: ReasonTypeNGMaxOrderByAggregateInput
    _min?: ReasonTypeNGMinOrderByAggregateInput
    _sum?: ReasonTypeNGSumOrderByAggregateInput
  }

  export type ReasonTypeNGScalarWhereWithAggregatesInput = {
    AND?: ReasonTypeNGScalarWhereWithAggregatesInput | ReasonTypeNGScalarWhereWithAggregatesInput[]
    OR?: ReasonTypeNGScalarWhereWithAggregatesInput[]
    NOT?: ReasonTypeNGScalarWhereWithAggregatesInput | ReasonTypeNGScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ReasonTypeNG"> | number
    reasontypeName?: StringWithAggregatesFilter<"ReasonTypeNG"> | string
    createdAt?: DateTimeWithAggregatesFilter<"ReasonTypeNG"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ReasonTypeNG"> | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter<"ReasonTypeNG"> | Date | string | null
  }

  export type ReasonDetailWhereInput = {
    AND?: ReasonDetailWhereInput | ReasonDetailWhereInput[]
    OR?: ReasonDetailWhereInput[]
    NOT?: ReasonDetailWhereInput | ReasonDetailWhereInput[]
    id?: IntFilter<"ReasonDetail"> | number
    reasonTypeId?: IntFilter<"ReasonDetail"> | number
    reasondetailName?: StringFilter<"ReasonDetail"> | string
    reasonTypeNG?: XOR<ReasonTypeNGRelationFilter, ReasonTypeNGWhereInput>
  }

  export type ReasonDetailOrderByWithRelationInput = {
    id?: SortOrder
    reasonTypeId?: SortOrder
    reasondetailName?: SortOrder
    reasonTypeNG?: ReasonTypeNGOrderByWithRelationInput
  }

  export type ReasonDetailWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ReasonDetailWhereInput | ReasonDetailWhereInput[]
    OR?: ReasonDetailWhereInput[]
    NOT?: ReasonDetailWhereInput | ReasonDetailWhereInput[]
    reasonTypeId?: IntFilter<"ReasonDetail"> | number
    reasondetailName?: StringFilter<"ReasonDetail"> | string
    reasonTypeNG?: XOR<ReasonTypeNGRelationFilter, ReasonTypeNGWhereInput>
  }, "id">

  export type ReasonDetailOrderByWithAggregationInput = {
    id?: SortOrder
    reasonTypeId?: SortOrder
    reasondetailName?: SortOrder
    _count?: ReasonDetailCountOrderByAggregateInput
    _avg?: ReasonDetailAvgOrderByAggregateInput
    _max?: ReasonDetailMaxOrderByAggregateInput
    _min?: ReasonDetailMinOrderByAggregateInput
    _sum?: ReasonDetailSumOrderByAggregateInput
  }

  export type ReasonDetailScalarWhereWithAggregatesInput = {
    AND?: ReasonDetailScalarWhereWithAggregatesInput | ReasonDetailScalarWhereWithAggregatesInput[]
    OR?: ReasonDetailScalarWhereWithAggregatesInput[]
    NOT?: ReasonDetailScalarWhereWithAggregatesInput | ReasonDetailScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ReasonDetail"> | number
    reasonTypeId?: IntWithAggregatesFilter<"ReasonDetail"> | number
    reasondetailName?: StringWithAggregatesFilter<"ReasonDetail"> | string
  }

  export type ReportWhereInput = {
    AND?: ReportWhereInput | ReportWhereInput[]
    OR?: ReportWhereInput[]
    NOT?: ReportWhereInput | ReportWhereInput[]
    id?: IntFilter<"Report"> | number
    projectId?: IntFilter<"Report"> | number
    blueprintNo?: StringFilter<"Report"> | string
    serialId?: StringFilter<"Report"> | string
    reportName?: StringFilter<"Report"> | string
    amountComplete?: IntFilter<"Report"> | number
    amountNG?: IntFilter<"Report"> | number
    timeHour?: StringFilter<"Report"> | string
    reportType?: StringFilter<"Report"> | string
    status?: StringFilter<"Report"> | string
    reasonType?: StringNullableFilter<"Report"> | string | null
    reasonDetail?: StringFilter<"Report"> | string
    reasonId?: IntNullableFilter<"Report"> | number | null
    createdAt?: DateTimeFilter<"Report"> | Date | string
    createdBy?: StringFilter<"Report"> | string
    updatedAt?: DateTimeFilter<"Report"> | Date | string
    updatedBy?: StringFilter<"Report"> | string
    deletedAt?: DateTimeNullableFilter<"Report"> | Date | string | null
    deletedBy?: StringFilter<"Report"> | string
    reportProcess?: ReportProcessListRelationFilter
  }

  export type ReportOrderByWithRelationInput = {
    id?: SortOrder
    projectId?: SortOrder
    blueprintNo?: SortOrder
    serialId?: SortOrder
    reportName?: SortOrder
    amountComplete?: SortOrder
    amountNG?: SortOrder
    timeHour?: SortOrder
    reportType?: SortOrder
    status?: SortOrder
    reasonType?: SortOrderInput | SortOrder
    reasonDetail?: SortOrder
    reasonId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    deletedBy?: SortOrder
    reportProcess?: ReportProcessOrderByRelationAggregateInput
  }

  export type ReportWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ReportWhereInput | ReportWhereInput[]
    OR?: ReportWhereInput[]
    NOT?: ReportWhereInput | ReportWhereInput[]
    projectId?: IntFilter<"Report"> | number
    blueprintNo?: StringFilter<"Report"> | string
    serialId?: StringFilter<"Report"> | string
    reportName?: StringFilter<"Report"> | string
    amountComplete?: IntFilter<"Report"> | number
    amountNG?: IntFilter<"Report"> | number
    timeHour?: StringFilter<"Report"> | string
    reportType?: StringFilter<"Report"> | string
    status?: StringFilter<"Report"> | string
    reasonType?: StringNullableFilter<"Report"> | string | null
    reasonDetail?: StringFilter<"Report"> | string
    reasonId?: IntNullableFilter<"Report"> | number | null
    createdAt?: DateTimeFilter<"Report"> | Date | string
    createdBy?: StringFilter<"Report"> | string
    updatedAt?: DateTimeFilter<"Report"> | Date | string
    updatedBy?: StringFilter<"Report"> | string
    deletedAt?: DateTimeNullableFilter<"Report"> | Date | string | null
    deletedBy?: StringFilter<"Report"> | string
    reportProcess?: ReportProcessListRelationFilter
  }, "id">

  export type ReportOrderByWithAggregationInput = {
    id?: SortOrder
    projectId?: SortOrder
    blueprintNo?: SortOrder
    serialId?: SortOrder
    reportName?: SortOrder
    amountComplete?: SortOrder
    amountNG?: SortOrder
    timeHour?: SortOrder
    reportType?: SortOrder
    status?: SortOrder
    reasonType?: SortOrderInput | SortOrder
    reasonDetail?: SortOrder
    reasonId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    deletedBy?: SortOrder
    _count?: ReportCountOrderByAggregateInput
    _avg?: ReportAvgOrderByAggregateInput
    _max?: ReportMaxOrderByAggregateInput
    _min?: ReportMinOrderByAggregateInput
    _sum?: ReportSumOrderByAggregateInput
  }

  export type ReportScalarWhereWithAggregatesInput = {
    AND?: ReportScalarWhereWithAggregatesInput | ReportScalarWhereWithAggregatesInput[]
    OR?: ReportScalarWhereWithAggregatesInput[]
    NOT?: ReportScalarWhereWithAggregatesInput | ReportScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Report"> | number
    projectId?: IntWithAggregatesFilter<"Report"> | number
    blueprintNo?: StringWithAggregatesFilter<"Report"> | string
    serialId?: StringWithAggregatesFilter<"Report"> | string
    reportName?: StringWithAggregatesFilter<"Report"> | string
    amountComplete?: IntWithAggregatesFilter<"Report"> | number
    amountNG?: IntWithAggregatesFilter<"Report"> | number
    timeHour?: StringWithAggregatesFilter<"Report"> | string
    reportType?: StringWithAggregatesFilter<"Report"> | string
    status?: StringWithAggregatesFilter<"Report"> | string
    reasonType?: StringNullableWithAggregatesFilter<"Report"> | string | null
    reasonDetail?: StringWithAggregatesFilter<"Report"> | string
    reasonId?: IntNullableWithAggregatesFilter<"Report"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"Report"> | Date | string
    createdBy?: StringWithAggregatesFilter<"Report"> | string
    updatedAt?: DateTimeWithAggregatesFilter<"Report"> | Date | string
    updatedBy?: StringWithAggregatesFilter<"Report"> | string
    deletedAt?: DateTimeNullableWithAggregatesFilter<"Report"> | Date | string | null
    deletedBy?: StringWithAggregatesFilter<"Report"> | string
  }

  export type ReportProcessWhereInput = {
    AND?: ReportProcessWhereInput | ReportProcessWhereInput[]
    OR?: ReportProcessWhereInput[]
    NOT?: ReportProcessWhereInput | ReportProcessWhereInput[]
    id?: IntFilter<"ReportProcess"> | number
    reportId?: IntFilter<"ReportProcess"> | number
    processNo?: StringFilter<"ReportProcess"> | string
    amountday?: IntFilter<"ReportProcess"> | number
    report?: XOR<ReportRelationFilter, ReportWhereInput>
    reportStock?: ReportStockListRelationFilter
  }

  export type ReportProcessOrderByWithRelationInput = {
    id?: SortOrder
    reportId?: SortOrder
    processNo?: SortOrder
    amountday?: SortOrder
    report?: ReportOrderByWithRelationInput
    reportStock?: ReportStockOrderByRelationAggregateInput
  }

  export type ReportProcessWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ReportProcessWhereInput | ReportProcessWhereInput[]
    OR?: ReportProcessWhereInput[]
    NOT?: ReportProcessWhereInput | ReportProcessWhereInput[]
    reportId?: IntFilter<"ReportProcess"> | number
    processNo?: StringFilter<"ReportProcess"> | string
    amountday?: IntFilter<"ReportProcess"> | number
    report?: XOR<ReportRelationFilter, ReportWhereInput>
    reportStock?: ReportStockListRelationFilter
  }, "id">

  export type ReportProcessOrderByWithAggregationInput = {
    id?: SortOrder
    reportId?: SortOrder
    processNo?: SortOrder
    amountday?: SortOrder
    _count?: ReportProcessCountOrderByAggregateInput
    _avg?: ReportProcessAvgOrderByAggregateInput
    _max?: ReportProcessMaxOrderByAggregateInput
    _min?: ReportProcessMinOrderByAggregateInput
    _sum?: ReportProcessSumOrderByAggregateInput
  }

  export type ReportProcessScalarWhereWithAggregatesInput = {
    AND?: ReportProcessScalarWhereWithAggregatesInput | ReportProcessScalarWhereWithAggregatesInput[]
    OR?: ReportProcessScalarWhereWithAggregatesInput[]
    NOT?: ReportProcessScalarWhereWithAggregatesInput | ReportProcessScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ReportProcess"> | number
    reportId?: IntWithAggregatesFilter<"ReportProcess"> | number
    processNo?: StringWithAggregatesFilter<"ReportProcess"> | string
    amountday?: IntWithAggregatesFilter<"ReportProcess"> | number
  }

  export type ReportStockWhereInput = {
    AND?: ReportStockWhereInput | ReportStockWhereInput[]
    OR?: ReportStockWhereInput[]
    NOT?: ReportStockWhereInput | ReportStockWhereInput[]
    id?: IntFilter<"ReportStock"> | number
    reportProcessId?: IntFilter<"ReportStock"> | number
    stockId?: StringFilter<"ReportStock"> | string
    stockamount?: IntFilter<"ReportStock"> | number
    stocktype?: IntFilter<"ReportStock"> | number
    reportProcess?: XOR<ReportProcessRelationFilter, ReportProcessWhereInput>
  }

  export type ReportStockOrderByWithRelationInput = {
    id?: SortOrder
    reportProcessId?: SortOrder
    stockId?: SortOrder
    stockamount?: SortOrder
    stocktype?: SortOrder
    reportProcess?: ReportProcessOrderByWithRelationInput
  }

  export type ReportStockWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ReportStockWhereInput | ReportStockWhereInput[]
    OR?: ReportStockWhereInput[]
    NOT?: ReportStockWhereInput | ReportStockWhereInput[]
    reportProcessId?: IntFilter<"ReportStock"> | number
    stockId?: StringFilter<"ReportStock"> | string
    stockamount?: IntFilter<"ReportStock"> | number
    stocktype?: IntFilter<"ReportStock"> | number
    reportProcess?: XOR<ReportProcessRelationFilter, ReportProcessWhereInput>
  }, "id">

  export type ReportStockOrderByWithAggregationInput = {
    id?: SortOrder
    reportProcessId?: SortOrder
    stockId?: SortOrder
    stockamount?: SortOrder
    stocktype?: SortOrder
    _count?: ReportStockCountOrderByAggregateInput
    _avg?: ReportStockAvgOrderByAggregateInput
    _max?: ReportStockMaxOrderByAggregateInput
    _min?: ReportStockMinOrderByAggregateInput
    _sum?: ReportStockSumOrderByAggregateInput
  }

  export type ReportStockScalarWhereWithAggregatesInput = {
    AND?: ReportStockScalarWhereWithAggregatesInput | ReportStockScalarWhereWithAggregatesInput[]
    OR?: ReportStockScalarWhereWithAggregatesInput[]
    NOT?: ReportStockScalarWhereWithAggregatesInput | ReportStockScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ReportStock"> | number
    reportProcessId?: IntWithAggregatesFilter<"ReportStock"> | number
    stockId?: StringWithAggregatesFilter<"ReportStock"> | string
    stockamount?: IntWithAggregatesFilter<"ReportStock"> | number
    stocktype?: IntWithAggregatesFilter<"ReportStock"> | number
  }

  export type UserCreateInput = {
    userId: string
    firstName: string
    lastName: string
    password: string
    companyId?: number | null
    companyBranchId?: number | null
    role: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    department?: DepartmentCreateNestedOneWithoutUserInput
    processes?: ProcessCreateNestedManyWithoutUserInput
    exams?: ExamAttemptCreateNestedManyWithoutUserInput
    enrollments?: EnrollmentCreateNestedManyWithoutUserInput
    oplDocuments?: OplDocumentCreateNestedManyWithoutUserInput
    files?: FileCreateNestedManyWithoutUserInput
    createdCourses?: CourseCreateNestedManyWithoutCreatorInput
    deletedCourses?: CourseCreateNestedManyWithoutDeleterInput
    courseCompletions?: UserCourseCompletionCreateNestedManyWithoutUserInput
    project?: ProjectCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: number
    userId: string
    firstName: string
    lastName: string
    password: string
    companyId?: number | null
    companyBranchId?: number | null
    departmentId?: number | null
    role: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    processes?: ProcessUncheckedCreateNestedManyWithoutUserInput
    exams?: ExamAttemptUncheckedCreateNestedManyWithoutUserInput
    enrollments?: EnrollmentUncheckedCreateNestedManyWithoutUserInput
    oplDocuments?: OplDocumentUncheckedCreateNestedManyWithoutUserInput
    files?: FileUncheckedCreateNestedManyWithoutUserInput
    createdCourses?: CourseUncheckedCreateNestedManyWithoutCreatorInput
    deletedCourses?: CourseUncheckedCreateNestedManyWithoutDeleterInput
    courseCompletions?: UserCourseCompletionUncheckedCreateNestedManyWithoutUserInput
    project?: ProjectUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    userId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    companyId?: NullableIntFieldUpdateOperationsInput | number | null
    companyBranchId?: NullableIntFieldUpdateOperationsInput | number | null
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    department?: DepartmentUpdateOneWithoutUserNestedInput
    processes?: ProcessUpdateManyWithoutUserNestedInput
    exams?: ExamAttemptUpdateManyWithoutUserNestedInput
    enrollments?: EnrollmentUpdateManyWithoutUserNestedInput
    oplDocuments?: OplDocumentUpdateManyWithoutUserNestedInput
    files?: FileUpdateManyWithoutUserNestedInput
    createdCourses?: CourseUpdateManyWithoutCreatorNestedInput
    deletedCourses?: CourseUpdateManyWithoutDeleterNestedInput
    courseCompletions?: UserCourseCompletionUpdateManyWithoutUserNestedInput
    project?: ProjectUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    companyId?: NullableIntFieldUpdateOperationsInput | number | null
    companyBranchId?: NullableIntFieldUpdateOperationsInput | number | null
    departmentId?: NullableIntFieldUpdateOperationsInput | number | null
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    processes?: ProcessUncheckedUpdateManyWithoutUserNestedInput
    exams?: ExamAttemptUncheckedUpdateManyWithoutUserNestedInput
    enrollments?: EnrollmentUncheckedUpdateManyWithoutUserNestedInput
    oplDocuments?: OplDocumentUncheckedUpdateManyWithoutUserNestedInput
    files?: FileUncheckedUpdateManyWithoutUserNestedInput
    createdCourses?: CourseUncheckedUpdateManyWithoutCreatorNestedInput
    deletedCourses?: CourseUncheckedUpdateManyWithoutDeleterNestedInput
    courseCompletions?: UserCourseCompletionUncheckedUpdateManyWithoutUserNestedInput
    project?: ProjectUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: number
    userId: string
    firstName: string
    lastName: string
    password: string
    companyId?: number | null
    companyBranchId?: number | null
    departmentId?: number | null
    role: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type UserUpdateManyMutationInput = {
    userId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    companyId?: NullableIntFieldUpdateOperationsInput | number | null
    companyBranchId?: NullableIntFieldUpdateOperationsInput | number | null
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    companyId?: NullableIntFieldUpdateOperationsInput | number | null
    companyBranchId?: NullableIntFieldUpdateOperationsInput | number | null
    departmentId?: NullableIntFieldUpdateOperationsInput | number | null
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CompanyCreateInput = {
    companyName: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    companyBranch?: CompanyBranchCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateInput = {
    id?: number
    companyName: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    companyBranch?: CompanyBranchUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUpdateInput = {
    companyName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    companyBranch?: CompanyBranchUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    companyName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    companyBranch?: CompanyBranchUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyCreateManyInput = {
    id?: number
    companyName: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type CompanyUpdateManyMutationInput = {
    companyName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CompanyUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    companyName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CompanyBranchCreateInput = {
    companyBranchName: string
    company: CompanyCreateNestedOneWithoutCompanyBranchInput
  }

  export type CompanyBranchUncheckedCreateInput = {
    id?: number
    companyId: number
    companyBranchName: string
  }

  export type CompanyBranchUpdateInput = {
    companyBranchName?: StringFieldUpdateOperationsInput | string
    company?: CompanyUpdateOneRequiredWithoutCompanyBranchNestedInput
  }

  export type CompanyBranchUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    companyId?: IntFieldUpdateOperationsInput | number
    companyBranchName?: StringFieldUpdateOperationsInput | string
  }

  export type CompanyBranchCreateManyInput = {
    id?: number
    companyId: number
    companyBranchName: string
  }

  export type CompanyBranchUpdateManyMutationInput = {
    companyBranchName?: StringFieldUpdateOperationsInput | string
  }

  export type CompanyBranchUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    companyId?: IntFieldUpdateOperationsInput | number
    companyBranchName?: StringFieldUpdateOperationsInput | string
  }

  export type DepartmentCreateInput = {
    departmentName: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    user?: UserCreateNestedManyWithoutDepartmentInput
    Course?: CourseCreateNestedManyWithoutDepartmentInput
  }

  export type DepartmentUncheckedCreateInput = {
    id?: number
    departmentName: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    user?: UserUncheckedCreateNestedManyWithoutDepartmentInput
    Course?: CourseUncheckedCreateNestedManyWithoutDepartmentInput
  }

  export type DepartmentUpdateInput = {
    departmentName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateManyWithoutDepartmentNestedInput
    Course?: CourseUpdateManyWithoutDepartmentNestedInput
  }

  export type DepartmentUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    departmentName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUncheckedUpdateManyWithoutDepartmentNestedInput
    Course?: CourseUncheckedUpdateManyWithoutDepartmentNestedInput
  }

  export type DepartmentCreateManyInput = {
    id?: number
    departmentName: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type DepartmentUpdateManyMutationInput = {
    departmentName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type DepartmentUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    departmentName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CourseCreateInput = {
    title: string
    description?: string | null
    pdfUrl?: string | null
    videoUrl?: string | null
    typeId: number
    template?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    department?: DepartmentCreateNestedOneWithoutCourseInput
    process?: ProcessCreateNestedOneWithoutCoursesInput
    enrollments?: EnrollmentCreateNestedManyWithoutCourseInput
    files?: FileCreateNestedManyWithoutCourseInput
    exams?: ExamCreateNestedManyWithoutCourseInput
    completions?: UserCourseCompletionCreateNestedManyWithoutCourseInput
    creator: UserCreateNestedOneWithoutCreatedCoursesInput
    deleter?: UserCreateNestedOneWithoutDeletedCoursesInput
  }

  export type CourseUncheckedCreateInput = {
    id?: number
    title: string
    description?: string | null
    pdfUrl?: string | null
    videoUrl?: string | null
    typeId: number
    template?: boolean
    departmentId?: number | null
    processId?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: number
    deletedBy?: number | null
    isDeleted?: boolean
    enrollments?: EnrollmentUncheckedCreateNestedManyWithoutCourseInput
    files?: FileUncheckedCreateNestedManyWithoutCourseInput
    exams?: ExamUncheckedCreateNestedManyWithoutCourseInput
    completions?: UserCourseCompletionUncheckedCreateNestedManyWithoutCourseInput
  }

  export type CourseUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    pdfUrl?: NullableStringFieldUpdateOperationsInput | string | null
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    typeId?: IntFieldUpdateOperationsInput | number
    template?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    department?: DepartmentUpdateOneWithoutCourseNestedInput
    process?: ProcessUpdateOneWithoutCoursesNestedInput
    enrollments?: EnrollmentUpdateManyWithoutCourseNestedInput
    files?: FileUpdateManyWithoutCourseNestedInput
    exams?: ExamUpdateManyWithoutCourseNestedInput
    completions?: UserCourseCompletionUpdateManyWithoutCourseNestedInput
    creator?: UserUpdateOneRequiredWithoutCreatedCoursesNestedInput
    deleter?: UserUpdateOneWithoutDeletedCoursesNestedInput
  }

  export type CourseUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    pdfUrl?: NullableStringFieldUpdateOperationsInput | string | null
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    typeId?: IntFieldUpdateOperationsInput | number
    template?: BoolFieldUpdateOperationsInput | boolean
    departmentId?: NullableIntFieldUpdateOperationsInput | number | null
    processId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: IntFieldUpdateOperationsInput | number
    deletedBy?: NullableIntFieldUpdateOperationsInput | number | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    enrollments?: EnrollmentUncheckedUpdateManyWithoutCourseNestedInput
    files?: FileUncheckedUpdateManyWithoutCourseNestedInput
    exams?: ExamUncheckedUpdateManyWithoutCourseNestedInput
    completions?: UserCourseCompletionUncheckedUpdateManyWithoutCourseNestedInput
  }

  export type CourseCreateManyInput = {
    id?: number
    title: string
    description?: string | null
    pdfUrl?: string | null
    videoUrl?: string | null
    typeId: number
    template?: boolean
    departmentId?: number | null
    processId?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: number
    deletedBy?: number | null
    isDeleted?: boolean
  }

  export type CourseUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    pdfUrl?: NullableStringFieldUpdateOperationsInput | string | null
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    typeId?: IntFieldUpdateOperationsInput | number
    template?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type CourseUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    pdfUrl?: NullableStringFieldUpdateOperationsInput | string | null
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    typeId?: IntFieldUpdateOperationsInput | number
    template?: BoolFieldUpdateOperationsInput | boolean
    departmentId?: NullableIntFieldUpdateOperationsInput | number | null
    processId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: IntFieldUpdateOperationsInput | number
    deletedBy?: NullableIntFieldUpdateOperationsInput | number | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type UserCourseCompletionCreateInput = {
    completedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutCourseCompletionsInput
    course: CourseCreateNestedOneWithoutCompletionsInput
    exam: ExamCreateNestedOneWithoutCompletionsInput
    process: ProcessCreateNestedOneWithoutCompletionsInput
  }

  export type UserCourseCompletionUncheckedCreateInput = {
    id?: number
    userId: number
    username: string
    courseId: number
    examId: number
    processId: number
    completedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserCourseCompletionUpdateInput = {
    completedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutCourseCompletionsNestedInput
    course?: CourseUpdateOneRequiredWithoutCompletionsNestedInput
    exam?: ExamUpdateOneRequiredWithoutCompletionsNestedInput
    process?: ProcessUpdateOneRequiredWithoutCompletionsNestedInput
  }

  export type UserCourseCompletionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    courseId?: IntFieldUpdateOperationsInput | number
    examId?: IntFieldUpdateOperationsInput | number
    processId?: IntFieldUpdateOperationsInput | number
    completedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCourseCompletionCreateManyInput = {
    id?: number
    userId: number
    username: string
    courseId: number
    examId: number
    processId: number
    completedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserCourseCompletionUpdateManyMutationInput = {
    completedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCourseCompletionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    courseId?: IntFieldUpdateOperationsInput | number
    examId?: IntFieldUpdateOperationsInput | number
    processId?: IntFieldUpdateOperationsInput | number
    completedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type courseTypeCreateInput = {
    id: number
    title: string
  }

  export type courseTypeUncheckedCreateInput = {
    id: number
    title: string
  }

  export type courseTypeUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
  }

  export type courseTypeUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
  }

  export type courseTypeCreateManyInput = {
    id: number
    title: string
  }

  export type courseTypeUpdateManyMutationInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
  }

  export type courseTypeUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
  }

  export type EnrollmentCreateInput = {
    progress: number
    completed?: boolean
    isDownloaded?: number
    user: UserCreateNestedOneWithoutEnrollmentsInput
    course: CourseCreateNestedOneWithoutEnrollmentsInput
  }

  export type EnrollmentUncheckedCreateInput = {
    id?: number
    userId: number
    courseId: number
    progress: number
    completed?: boolean
    isDownloaded?: number
  }

  export type EnrollmentUpdateInput = {
    progress?: FloatFieldUpdateOperationsInput | number
    completed?: BoolFieldUpdateOperationsInput | boolean
    isDownloaded?: FloatFieldUpdateOperationsInput | number
    user?: UserUpdateOneRequiredWithoutEnrollmentsNestedInput
    course?: CourseUpdateOneRequiredWithoutEnrollmentsNestedInput
  }

  export type EnrollmentUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    courseId?: IntFieldUpdateOperationsInput | number
    progress?: FloatFieldUpdateOperationsInput | number
    completed?: BoolFieldUpdateOperationsInput | boolean
    isDownloaded?: FloatFieldUpdateOperationsInput | number
  }

  export type EnrollmentCreateManyInput = {
    id?: number
    userId: number
    courseId: number
    progress: number
    completed?: boolean
    isDownloaded?: number
  }

  export type EnrollmentUpdateManyMutationInput = {
    progress?: FloatFieldUpdateOperationsInput | number
    completed?: BoolFieldUpdateOperationsInput | boolean
    isDownloaded?: FloatFieldUpdateOperationsInput | number
  }

  export type EnrollmentUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    courseId?: IntFieldUpdateOperationsInput | number
    progress?: FloatFieldUpdateOperationsInput | number
    completed?: BoolFieldUpdateOperationsInput | boolean
    isDownloaded?: FloatFieldUpdateOperationsInput | number
  }

  export type ExamCreateInput = {
    title: string
    departmentId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    description?: string | null
    deleted?: boolean
    questions?: QuestionCreateNestedManyWithoutExamInput
    attempts?: ExamAttemptCreateNestedManyWithoutExamInput
    completions?: UserCourseCompletionCreateNestedManyWithoutExamInput
    course?: CourseCreateNestedOneWithoutExamsInput
  }

  export type ExamUncheckedCreateInput = {
    id?: number
    title: string
    departmentId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    courseId?: number | null
    description?: string | null
    deleted?: boolean
    questions?: QuestionUncheckedCreateNestedManyWithoutExamInput
    attempts?: ExamAttemptUncheckedCreateNestedManyWithoutExamInput
    completions?: UserCourseCompletionUncheckedCreateNestedManyWithoutExamInput
  }

  export type ExamUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    departmentId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    questions?: QuestionUpdateManyWithoutExamNestedInput
    attempts?: ExamAttemptUpdateManyWithoutExamNestedInput
    completions?: UserCourseCompletionUpdateManyWithoutExamNestedInput
    course?: CourseUpdateOneWithoutExamsNestedInput
  }

  export type ExamUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    departmentId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    courseId?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    questions?: QuestionUncheckedUpdateManyWithoutExamNestedInput
    attempts?: ExamAttemptUncheckedUpdateManyWithoutExamNestedInput
    completions?: UserCourseCompletionUncheckedUpdateManyWithoutExamNestedInput
  }

  export type ExamCreateManyInput = {
    id?: number
    title: string
    departmentId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    courseId?: number | null
    description?: string | null
    deleted?: boolean
  }

  export type ExamUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    departmentId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ExamUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    departmentId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    courseId?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type QuestionCreateInput = {
    text: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deleted?: boolean
    exam: ExamCreateNestedOneWithoutQuestionsInput
    choices?: ChoiceCreateNestedManyWithoutQuestionInput
    userAnswers?: UserAnswerCreateNestedManyWithoutQuestionInput
  }

  export type QuestionUncheckedCreateInput = {
    id?: number
    examId: number
    text: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deleted?: boolean
    choices?: ChoiceUncheckedCreateNestedManyWithoutQuestionInput
    userAnswers?: UserAnswerUncheckedCreateNestedManyWithoutQuestionInput
  }

  export type QuestionUpdateInput = {
    text?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
    exam?: ExamUpdateOneRequiredWithoutQuestionsNestedInput
    choices?: ChoiceUpdateManyWithoutQuestionNestedInput
    userAnswers?: UserAnswerUpdateManyWithoutQuestionNestedInput
  }

  export type QuestionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    examId?: IntFieldUpdateOperationsInput | number
    text?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
    choices?: ChoiceUncheckedUpdateManyWithoutQuestionNestedInput
    userAnswers?: UserAnswerUncheckedUpdateManyWithoutQuestionNestedInput
  }

  export type QuestionCreateManyInput = {
    id?: number
    examId: number
    text: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deleted?: boolean
  }

  export type QuestionUpdateManyMutationInput = {
    text?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type QuestionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    examId?: IntFieldUpdateOperationsInput | number
    text?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ChoiceCreateInput = {
    text: string
    correct: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deleted?: boolean
    question: QuestionCreateNestedOneWithoutChoicesInput
    UserAnswer?: UserAnswerCreateNestedManyWithoutSelectedChoiceInput
  }

  export type ChoiceUncheckedCreateInput = {
    id?: number
    questionId: number
    text: string
    correct: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deleted?: boolean
    UserAnswer?: UserAnswerUncheckedCreateNestedManyWithoutSelectedChoiceInput
  }

  export type ChoiceUpdateInput = {
    text?: StringFieldUpdateOperationsInput | string
    correct?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
    question?: QuestionUpdateOneRequiredWithoutChoicesNestedInput
    UserAnswer?: UserAnswerUpdateManyWithoutSelectedChoiceNestedInput
  }

  export type ChoiceUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    questionId?: IntFieldUpdateOperationsInput | number
    text?: StringFieldUpdateOperationsInput | string
    correct?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
    UserAnswer?: UserAnswerUncheckedUpdateManyWithoutSelectedChoiceNestedInput
  }

  export type ChoiceCreateManyInput = {
    id?: number
    questionId: number
    text: string
    correct: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deleted?: boolean
  }

  export type ChoiceUpdateManyMutationInput = {
    text?: StringFieldUpdateOperationsInput | string
    correct?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ChoiceUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    questionId?: IntFieldUpdateOperationsInput | number
    text?: StringFieldUpdateOperationsInput | string
    correct?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ExamAttemptCreateInput = {
    startedAt?: Date | string
    endedAt?: Date | string | null
    grade?: number | null
    isPassed?: boolean | null
    user: UserCreateNestedOneWithoutExamsInput
    exam: ExamCreateNestedOneWithoutAttemptsInput
    answers?: UserAnswerCreateNestedManyWithoutExamAttemptInput
  }

  export type ExamAttemptUncheckedCreateInput = {
    id?: number
    userId: number
    examId: number
    startedAt?: Date | string
    endedAt?: Date | string | null
    grade?: number | null
    isPassed?: boolean | null
    answers?: UserAnswerUncheckedCreateNestedManyWithoutExamAttemptInput
  }

  export type ExamAttemptUpdateInput = {
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    grade?: NullableFloatFieldUpdateOperationsInput | number | null
    isPassed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    user?: UserUpdateOneRequiredWithoutExamsNestedInput
    exam?: ExamUpdateOneRequiredWithoutAttemptsNestedInput
    answers?: UserAnswerUpdateManyWithoutExamAttemptNestedInput
  }

  export type ExamAttemptUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    examId?: IntFieldUpdateOperationsInput | number
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    grade?: NullableFloatFieldUpdateOperationsInput | number | null
    isPassed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    answers?: UserAnswerUncheckedUpdateManyWithoutExamAttemptNestedInput
  }

  export type ExamAttemptCreateManyInput = {
    id?: number
    userId: number
    examId: number
    startedAt?: Date | string
    endedAt?: Date | string | null
    grade?: number | null
    isPassed?: boolean | null
  }

  export type ExamAttemptUpdateManyMutationInput = {
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    grade?: NullableFloatFieldUpdateOperationsInput | number | null
    isPassed?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type ExamAttemptUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    examId?: IntFieldUpdateOperationsInput | number
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    grade?: NullableFloatFieldUpdateOperationsInput | number | null
    isPassed?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type UserAnswerCreateInput = {
    isCorrect: boolean
    createdAt?: Date | string
    examAttempt: ExamAttemptCreateNestedOneWithoutAnswersInput
    question: QuestionCreateNestedOneWithoutUserAnswersInput
    selectedChoice: ChoiceCreateNestedOneWithoutUserAnswerInput
  }

  export type UserAnswerUncheckedCreateInput = {
    id?: number
    examAttemptId: number
    questionId: number
    selectedChoiceId: number
    isCorrect: boolean
    createdAt?: Date | string
  }

  export type UserAnswerUpdateInput = {
    isCorrect?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    examAttempt?: ExamAttemptUpdateOneRequiredWithoutAnswersNestedInput
    question?: QuestionUpdateOneRequiredWithoutUserAnswersNestedInput
    selectedChoice?: ChoiceUpdateOneRequiredWithoutUserAnswerNestedInput
  }

  export type UserAnswerUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    examAttemptId?: IntFieldUpdateOperationsInput | number
    questionId?: IntFieldUpdateOperationsInput | number
    selectedChoiceId?: IntFieldUpdateOperationsInput | number
    isCorrect?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserAnswerCreateManyInput = {
    id?: number
    examAttemptId: number
    questionId: number
    selectedChoiceId: number
    isCorrect: boolean
    createdAt?: Date | string
  }

  export type UserAnswerUpdateManyMutationInput = {
    isCorrect?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserAnswerUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    examAttemptId?: IntFieldUpdateOperationsInput | number
    questionId?: IntFieldUpdateOperationsInput | number
    selectedChoiceId?: IntFieldUpdateOperationsInput | number
    isCorrect?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OplDocumentCreateInput = {
    title: string
    description?: string | null
    fileName: string
    fileType: string
    filePath: string
    template?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    user: UserCreateNestedOneWithoutOplDocumentsInput
  }

  export type OplDocumentUncheckedCreateInput = {
    id?: number
    title: string
    description?: string | null
    fileName: string
    fileType: string
    filePath: string
    template?: boolean
    createdAt?: Date | string
    uploadedBy: number
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type OplDocumentUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    fileName?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    template?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutOplDocumentsNestedInput
  }

  export type OplDocumentUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    fileName?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    template?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    uploadedBy?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type OplDocumentCreateManyInput = {
    id?: number
    title: string
    description?: string | null
    fileName: string
    fileType: string
    filePath: string
    template?: boolean
    createdAt?: Date | string
    uploadedBy: number
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type OplDocumentUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    fileName?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    template?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type OplDocumentUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    fileName?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    template?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    uploadedBy?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type FileCreateInput = {
    originalName: string
    storedName: string
    fileType: string
    fileSize: bigint | number
    filePath: string
    uploadDate?: Date | string
    user?: UserCreateNestedOneWithoutFilesInput
    course?: CourseCreateNestedOneWithoutFilesInput
  }

  export type FileUncheckedCreateInput = {
    id?: number
    originalName: string
    storedName: string
    fileType: string
    fileSize: bigint | number
    filePath: string
    uploadDate?: Date | string
    userId?: number | null
    courseId?: number | null
  }

  export type FileUpdateInput = {
    originalName?: StringFieldUpdateOperationsInput | string
    storedName?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
    fileSize?: BigIntFieldUpdateOperationsInput | bigint | number
    filePath?: StringFieldUpdateOperationsInput | string
    uploadDate?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutFilesNestedInput
    course?: CourseUpdateOneWithoutFilesNestedInput
  }

  export type FileUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    originalName?: StringFieldUpdateOperationsInput | string
    storedName?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
    fileSize?: BigIntFieldUpdateOperationsInput | bigint | number
    filePath?: StringFieldUpdateOperationsInput | string
    uploadDate?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    courseId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type FileCreateManyInput = {
    id?: number
    originalName: string
    storedName: string
    fileType: string
    fileSize: bigint | number
    filePath: string
    uploadDate?: Date | string
    userId?: number | null
    courseId?: number | null
  }

  export type FileUpdateManyMutationInput = {
    originalName?: StringFieldUpdateOperationsInput | string
    storedName?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
    fileSize?: BigIntFieldUpdateOperationsInput | bigint | number
    filePath?: StringFieldUpdateOperationsInput | string
    uploadDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FileUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    originalName?: StringFieldUpdateOperationsInput | string
    storedName?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
    fileSize?: BigIntFieldUpdateOperationsInput | bigint | number
    filePath?: StringFieldUpdateOperationsInput | string
    uploadDate?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    courseId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ProcessCreateInput = {
    pc_bluePrintNo: string
    pc_imageBluePrint: string
    pc_totalProcess: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    user: UserCreateNestedOneWithoutProcessesInput
    courses?: CourseCreateNestedManyWithoutProcessInput
    completions?: UserCourseCompletionCreateNestedManyWithoutProcessInput
    processDetail?: ProcessDetailCreateNestedManyWithoutProcessInput
  }

  export type ProcessUncheckedCreateInput = {
    id?: number
    pc_bluePrintNo: string
    pc_imageBluePrint: string
    pc_totalProcess: number
    pc_userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    courses?: CourseUncheckedCreateNestedManyWithoutProcessInput
    completions?: UserCourseCompletionUncheckedCreateNestedManyWithoutProcessInput
    processDetail?: ProcessDetailUncheckedCreateNestedManyWithoutProcessInput
  }

  export type ProcessUpdateInput = {
    pc_bluePrintNo?: StringFieldUpdateOperationsInput | string
    pc_imageBluePrint?: StringFieldUpdateOperationsInput | string
    pc_totalProcess?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutProcessesNestedInput
    courses?: CourseUpdateManyWithoutProcessNestedInput
    completions?: UserCourseCompletionUpdateManyWithoutProcessNestedInput
    processDetail?: ProcessDetailUpdateManyWithoutProcessNestedInput
  }

  export type ProcessUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    pc_bluePrintNo?: StringFieldUpdateOperationsInput | string
    pc_imageBluePrint?: StringFieldUpdateOperationsInput | string
    pc_totalProcess?: IntFieldUpdateOperationsInput | number
    pc_userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    courses?: CourseUncheckedUpdateManyWithoutProcessNestedInput
    completions?: UserCourseCompletionUncheckedUpdateManyWithoutProcessNestedInput
    processDetail?: ProcessDetailUncheckedUpdateManyWithoutProcessNestedInput
  }

  export type ProcessCreateManyInput = {
    id?: number
    pc_bluePrintNo: string
    pc_imageBluePrint: string
    pc_totalProcess: number
    pc_userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type ProcessUpdateManyMutationInput = {
    pc_bluePrintNo?: StringFieldUpdateOperationsInput | string
    pc_imageBluePrint?: StringFieldUpdateOperationsInput | string
    pc_totalProcess?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ProcessUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    pc_bluePrintNo?: StringFieldUpdateOperationsInput | string
    pc_imageBluePrint?: StringFieldUpdateOperationsInput | string
    pc_totalProcess?: IntFieldUpdateOperationsInput | number
    pc_userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ProcessDetailCreateInput = {
    pc_processTitle: string
    pc_amountDay: number
    pc_reasonType: string
    process: ProcessCreateNestedOneWithoutProcessDetailInput
    processBranch?: ProcessBranchCreateNestedManyWithoutProcessDetailInput
    processMat?: ProcessMatCreateNestedManyWithoutProcessDetailInput
    processBom?: ProcessBomCreateNestedManyWithoutProcessDetailInput
  }

  export type ProcessDetailUncheckedCreateInput = {
    id?: number
    pc_bluePrintNo: string
    pc_processTitle: string
    pc_amountDay: number
    pc_reasonType: string
    processBranch?: ProcessBranchUncheckedCreateNestedManyWithoutProcessDetailInput
    processMat?: ProcessMatUncheckedCreateNestedManyWithoutProcessDetailInput
    processBom?: ProcessBomUncheckedCreateNestedManyWithoutProcessDetailInput
  }

  export type ProcessDetailUpdateInput = {
    pc_processTitle?: StringFieldUpdateOperationsInput | string
    pc_amountDay?: IntFieldUpdateOperationsInput | number
    pc_reasonType?: StringFieldUpdateOperationsInput | string
    process?: ProcessUpdateOneRequiredWithoutProcessDetailNestedInput
    processBranch?: ProcessBranchUpdateManyWithoutProcessDetailNestedInput
    processMat?: ProcessMatUpdateManyWithoutProcessDetailNestedInput
    processBom?: ProcessBomUpdateManyWithoutProcessDetailNestedInput
  }

  export type ProcessDetailUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    pc_bluePrintNo?: StringFieldUpdateOperationsInput | string
    pc_processTitle?: StringFieldUpdateOperationsInput | string
    pc_amountDay?: IntFieldUpdateOperationsInput | number
    pc_reasonType?: StringFieldUpdateOperationsInput | string
    processBranch?: ProcessBranchUncheckedUpdateManyWithoutProcessDetailNestedInput
    processMat?: ProcessMatUncheckedUpdateManyWithoutProcessDetailNestedInput
    processBom?: ProcessBomUncheckedUpdateManyWithoutProcessDetailNestedInput
  }

  export type ProcessDetailCreateManyInput = {
    id?: number
    pc_bluePrintNo: string
    pc_processTitle: string
    pc_amountDay: number
    pc_reasonType: string
  }

  export type ProcessDetailUpdateManyMutationInput = {
    pc_processTitle?: StringFieldUpdateOperationsInput | string
    pc_amountDay?: IntFieldUpdateOperationsInput | number
    pc_reasonType?: StringFieldUpdateOperationsInput | string
  }

  export type ProcessDetailUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    pc_bluePrintNo?: StringFieldUpdateOperationsInput | string
    pc_processTitle?: StringFieldUpdateOperationsInput | string
    pc_amountDay?: IntFieldUpdateOperationsInput | number
    pc_reasonType?: StringFieldUpdateOperationsInput | string
  }

  export type ProcessBranchCreateInput = {
    pc_remark: string
    processDetail: ProcessDetailCreateNestedOneWithoutProcessBranchInput
  }

  export type ProcessBranchUncheckedCreateInput = {
    id?: number
    pc_processDetailId: number
    pc_remark: string
  }

  export type ProcessBranchUpdateInput = {
    pc_remark?: StringFieldUpdateOperationsInput | string
    processDetail?: ProcessDetailUpdateOneRequiredWithoutProcessBranchNestedInput
  }

  export type ProcessBranchUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    pc_processDetailId?: IntFieldUpdateOperationsInput | number
    pc_remark?: StringFieldUpdateOperationsInput | string
  }

  export type ProcessBranchCreateManyInput = {
    id?: number
    pc_processDetailId: number
    pc_remark: string
  }

  export type ProcessBranchUpdateManyMutationInput = {
    pc_remark?: StringFieldUpdateOperationsInput | string
  }

  export type ProcessBranchUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    pc_processDetailId?: IntFieldUpdateOperationsInput | number
    pc_remark?: StringFieldUpdateOperationsInput | string
  }

  export type ProcessMatCreateInput = {
    pc_matamount: number
    stock: StockCreateNestedOneWithoutProcessMatInput
    processDetail: ProcessDetailCreateNestedOneWithoutProcessMatInput
  }

  export type ProcessMatUncheckedCreateInput = {
    id?: number
    pc_processDetailId: number
    pc_matId: string
    pc_matamount: number
  }

  export type ProcessMatUpdateInput = {
    pc_matamount?: IntFieldUpdateOperationsInput | number
    stock?: StockUpdateOneRequiredWithoutProcessMatNestedInput
    processDetail?: ProcessDetailUpdateOneRequiredWithoutProcessMatNestedInput
  }

  export type ProcessMatUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    pc_processDetailId?: IntFieldUpdateOperationsInput | number
    pc_matId?: StringFieldUpdateOperationsInput | string
    pc_matamount?: IntFieldUpdateOperationsInput | number
  }

  export type ProcessMatCreateManyInput = {
    id?: number
    pc_processDetailId: number
    pc_matId: string
    pc_matamount: number
  }

  export type ProcessMatUpdateManyMutationInput = {
    pc_matamount?: IntFieldUpdateOperationsInput | number
  }

  export type ProcessMatUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    pc_processDetailId?: IntFieldUpdateOperationsInput | number
    pc_matId?: StringFieldUpdateOperationsInput | string
    pc_matamount?: IntFieldUpdateOperationsInput | number
  }

  export type ProcessBomCreateInput = {
    pc_bomamount: number
    stock: StockCreateNestedOneWithoutProcessBomInput
    processDetail: ProcessDetailCreateNestedOneWithoutProcessBomInput
  }

  export type ProcessBomUncheckedCreateInput = {
    id?: number
    pc_processDetailId: number
    pc_bomId: string
    pc_bomamount: number
  }

  export type ProcessBomUpdateInput = {
    pc_bomamount?: IntFieldUpdateOperationsInput | number
    stock?: StockUpdateOneRequiredWithoutProcessBomNestedInput
    processDetail?: ProcessDetailUpdateOneRequiredWithoutProcessBomNestedInput
  }

  export type ProcessBomUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    pc_processDetailId?: IntFieldUpdateOperationsInput | number
    pc_bomId?: StringFieldUpdateOperationsInput | string
    pc_bomamount?: IntFieldUpdateOperationsInput | number
  }

  export type ProcessBomCreateManyInput = {
    id?: number
    pc_processDetailId: number
    pc_bomId: string
    pc_bomamount: number
  }

  export type ProcessBomUpdateManyMutationInput = {
    pc_bomamount?: IntFieldUpdateOperationsInput | number
  }

  export type ProcessBomUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    pc_processDetailId?: IntFieldUpdateOperationsInput | number
    pc_bomId?: StringFieldUpdateOperationsInput | string
    pc_bomamount?: IntFieldUpdateOperationsInput | number
  }

  export type ProjectCreateInput = {
    pj_bluePrintNo: string
    pj_serialNumber: string
    pj_projectName: string
    pj_startDate: Date | string
    pj_endDate: Date | string
    pj_amountProduct: number
    pj_totalDay: number
    pj_imageProduct: string
    pj_remark: string
    pj_status: string
    pj_type: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    user: UserCreateNestedOneWithoutProjectInput
    projectDetail?: ProjectDetailCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateInput = {
    id?: number
    pj_bluePrintNo: string
    pj_serialNumber: string
    pj_projectName: string
    pj_startDate: Date | string
    pj_endDate: Date | string
    pj_amountProduct: number
    pj_totalDay: number
    pj_imageProduct: string
    pj_remark: string
    pj_status: string
    pj_type: string
    pj_userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    projectDetail?: ProjectDetailUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectUpdateInput = {
    pj_bluePrintNo?: StringFieldUpdateOperationsInput | string
    pj_serialNumber?: StringFieldUpdateOperationsInput | string
    pj_projectName?: StringFieldUpdateOperationsInput | string
    pj_startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    pj_endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    pj_amountProduct?: IntFieldUpdateOperationsInput | number
    pj_totalDay?: IntFieldUpdateOperationsInput | number
    pj_imageProduct?: StringFieldUpdateOperationsInput | string
    pj_remark?: StringFieldUpdateOperationsInput | string
    pj_status?: StringFieldUpdateOperationsInput | string
    pj_type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutProjectNestedInput
    projectDetail?: ProjectDetailUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    pj_bluePrintNo?: StringFieldUpdateOperationsInput | string
    pj_serialNumber?: StringFieldUpdateOperationsInput | string
    pj_projectName?: StringFieldUpdateOperationsInput | string
    pj_startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    pj_endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    pj_amountProduct?: IntFieldUpdateOperationsInput | number
    pj_totalDay?: IntFieldUpdateOperationsInput | number
    pj_imageProduct?: StringFieldUpdateOperationsInput | string
    pj_remark?: StringFieldUpdateOperationsInput | string
    pj_status?: StringFieldUpdateOperationsInput | string
    pj_type?: StringFieldUpdateOperationsInput | string
    pj_userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    projectDetail?: ProjectDetailUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type ProjectCreateManyInput = {
    id?: number
    pj_bluePrintNo: string
    pj_serialNumber: string
    pj_projectName: string
    pj_startDate: Date | string
    pj_endDate: Date | string
    pj_amountProduct: number
    pj_totalDay: number
    pj_imageProduct: string
    pj_remark: string
    pj_status: string
    pj_type: string
    pj_userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type ProjectUpdateManyMutationInput = {
    pj_bluePrintNo?: StringFieldUpdateOperationsInput | string
    pj_serialNumber?: StringFieldUpdateOperationsInput | string
    pj_projectName?: StringFieldUpdateOperationsInput | string
    pj_startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    pj_endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    pj_amountProduct?: IntFieldUpdateOperationsInput | number
    pj_totalDay?: IntFieldUpdateOperationsInput | number
    pj_imageProduct?: StringFieldUpdateOperationsInput | string
    pj_remark?: StringFieldUpdateOperationsInput | string
    pj_status?: StringFieldUpdateOperationsInput | string
    pj_type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ProjectUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    pj_bluePrintNo?: StringFieldUpdateOperationsInput | string
    pj_serialNumber?: StringFieldUpdateOperationsInput | string
    pj_projectName?: StringFieldUpdateOperationsInput | string
    pj_startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    pj_endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    pj_amountProduct?: IntFieldUpdateOperationsInput | number
    pj_totalDay?: IntFieldUpdateOperationsInput | number
    pj_imageProduct?: StringFieldUpdateOperationsInput | string
    pj_remark?: StringFieldUpdateOperationsInput | string
    pj_status?: StringFieldUpdateOperationsInput | string
    pj_type?: StringFieldUpdateOperationsInput | string
    pj_userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ProjectDetailCreateInput = {
    pj_bluePrintNo: string
    pj_serialNumber: string
    pj_processTitle: string
    pj_amountDay: number
    pj_reasonType: string
    pj_statusPc: string
    project: ProjectCreateNestedOneWithoutProjectDetailInput
    projectBranch?: ProjectBranchCreateNestedManyWithoutProjectDetailInput
    projectMat?: ProjectMatCreateNestedManyWithoutProjectDetailInput
    projectBom?: ProjectBomCreateNestedManyWithoutProjectDetailInput
    ProjectResUser?: ProjectResUserCreateNestedManyWithoutProjectDetailInput
  }

  export type ProjectDetailUncheckedCreateInput = {
    id?: number
    pj_projectId: number
    pj_bluePrintNo: string
    pj_serialNumber: string
    pj_processTitle: string
    pj_amountDay: number
    pj_reasonType: string
    pj_statusPc: string
    projectBranch?: ProjectBranchUncheckedCreateNestedManyWithoutProjectDetailInput
    projectMat?: ProjectMatUncheckedCreateNestedManyWithoutProjectDetailInput
    projectBom?: ProjectBomUncheckedCreateNestedManyWithoutProjectDetailInput
    ProjectResUser?: ProjectResUserUncheckedCreateNestedManyWithoutProjectDetailInput
  }

  export type ProjectDetailUpdateInput = {
    pj_bluePrintNo?: StringFieldUpdateOperationsInput | string
    pj_serialNumber?: StringFieldUpdateOperationsInput | string
    pj_processTitle?: StringFieldUpdateOperationsInput | string
    pj_amountDay?: IntFieldUpdateOperationsInput | number
    pj_reasonType?: StringFieldUpdateOperationsInput | string
    pj_statusPc?: StringFieldUpdateOperationsInput | string
    project?: ProjectUpdateOneRequiredWithoutProjectDetailNestedInput
    projectBranch?: ProjectBranchUpdateManyWithoutProjectDetailNestedInput
    projectMat?: ProjectMatUpdateManyWithoutProjectDetailNestedInput
    projectBom?: ProjectBomUpdateManyWithoutProjectDetailNestedInput
    ProjectResUser?: ProjectResUserUpdateManyWithoutProjectDetailNestedInput
  }

  export type ProjectDetailUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    pj_projectId?: IntFieldUpdateOperationsInput | number
    pj_bluePrintNo?: StringFieldUpdateOperationsInput | string
    pj_serialNumber?: StringFieldUpdateOperationsInput | string
    pj_processTitle?: StringFieldUpdateOperationsInput | string
    pj_amountDay?: IntFieldUpdateOperationsInput | number
    pj_reasonType?: StringFieldUpdateOperationsInput | string
    pj_statusPc?: StringFieldUpdateOperationsInput | string
    projectBranch?: ProjectBranchUncheckedUpdateManyWithoutProjectDetailNestedInput
    projectMat?: ProjectMatUncheckedUpdateManyWithoutProjectDetailNestedInput
    projectBom?: ProjectBomUncheckedUpdateManyWithoutProjectDetailNestedInput
    ProjectResUser?: ProjectResUserUncheckedUpdateManyWithoutProjectDetailNestedInput
  }

  export type ProjectDetailCreateManyInput = {
    id?: number
    pj_projectId: number
    pj_bluePrintNo: string
    pj_serialNumber: string
    pj_processTitle: string
    pj_amountDay: number
    pj_reasonType: string
    pj_statusPc: string
  }

  export type ProjectDetailUpdateManyMutationInput = {
    pj_bluePrintNo?: StringFieldUpdateOperationsInput | string
    pj_serialNumber?: StringFieldUpdateOperationsInput | string
    pj_processTitle?: StringFieldUpdateOperationsInput | string
    pj_amountDay?: IntFieldUpdateOperationsInput | number
    pj_reasonType?: StringFieldUpdateOperationsInput | string
    pj_statusPc?: StringFieldUpdateOperationsInput | string
  }

  export type ProjectDetailUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    pj_projectId?: IntFieldUpdateOperationsInput | number
    pj_bluePrintNo?: StringFieldUpdateOperationsInput | string
    pj_serialNumber?: StringFieldUpdateOperationsInput | string
    pj_processTitle?: StringFieldUpdateOperationsInput | string
    pj_amountDay?: IntFieldUpdateOperationsInput | number
    pj_reasonType?: StringFieldUpdateOperationsInput | string
    pj_statusPc?: StringFieldUpdateOperationsInput | string
  }

  export type ProjectBranchCreateInput = {
    pj_remark: string
    projectDetail: ProjectDetailCreateNestedOneWithoutProjectBranchInput
  }

  export type ProjectBranchUncheckedCreateInput = {
    id?: number
    pj_projectDetailId: number
    pj_remark: string
  }

  export type ProjectBranchUpdateInput = {
    pj_remark?: StringFieldUpdateOperationsInput | string
    projectDetail?: ProjectDetailUpdateOneRequiredWithoutProjectBranchNestedInput
  }

  export type ProjectBranchUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    pj_projectDetailId?: IntFieldUpdateOperationsInput | number
    pj_remark?: StringFieldUpdateOperationsInput | string
  }

  export type ProjectBranchCreateManyInput = {
    id?: number
    pj_projectDetailId: number
    pj_remark: string
  }

  export type ProjectBranchUpdateManyMutationInput = {
    pj_remark?: StringFieldUpdateOperationsInput | string
  }

  export type ProjectBranchUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    pj_projectDetailId?: IntFieldUpdateOperationsInput | number
    pj_remark?: StringFieldUpdateOperationsInput | string
  }

  export type ProjectMatCreateInput = {
    pj_matamount: number
    pj_matTatal: number
    stock: StockCreateNestedOneWithoutProjectMatInput
    projectDetail: ProjectDetailCreateNestedOneWithoutProjectMatInput
  }

  export type ProjectMatUncheckedCreateInput = {
    id?: number
    pj_projectDetailId: number
    pj_matId: string
    pj_matamount: number
    pj_matTatal: number
  }

  export type ProjectMatUpdateInput = {
    pj_matamount?: IntFieldUpdateOperationsInput | number
    pj_matTatal?: IntFieldUpdateOperationsInput | number
    stock?: StockUpdateOneRequiredWithoutProjectMatNestedInput
    projectDetail?: ProjectDetailUpdateOneRequiredWithoutProjectMatNestedInput
  }

  export type ProjectMatUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    pj_projectDetailId?: IntFieldUpdateOperationsInput | number
    pj_matId?: StringFieldUpdateOperationsInput | string
    pj_matamount?: IntFieldUpdateOperationsInput | number
    pj_matTatal?: IntFieldUpdateOperationsInput | number
  }

  export type ProjectMatCreateManyInput = {
    id?: number
    pj_projectDetailId: number
    pj_matId: string
    pj_matamount: number
    pj_matTatal: number
  }

  export type ProjectMatUpdateManyMutationInput = {
    pj_matamount?: IntFieldUpdateOperationsInput | number
    pj_matTatal?: IntFieldUpdateOperationsInput | number
  }

  export type ProjectMatUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    pj_projectDetailId?: IntFieldUpdateOperationsInput | number
    pj_matId?: StringFieldUpdateOperationsInput | string
    pj_matamount?: IntFieldUpdateOperationsInput | number
    pj_matTatal?: IntFieldUpdateOperationsInput | number
  }

  export type ProjectBomCreateInput = {
    pj_bomamount: number
    pj_bomTatal: number
    stock: StockCreateNestedOneWithoutProjectBomInput
    projectDetail: ProjectDetailCreateNestedOneWithoutProjectBomInput
  }

  export type ProjectBomUncheckedCreateInput = {
    id?: number
    pj_projectDetailId: number
    pj_bomId: string
    pj_bomamount: number
    pj_bomTatal: number
  }

  export type ProjectBomUpdateInput = {
    pj_bomamount?: IntFieldUpdateOperationsInput | number
    pj_bomTatal?: IntFieldUpdateOperationsInput | number
    stock?: StockUpdateOneRequiredWithoutProjectBomNestedInput
    projectDetail?: ProjectDetailUpdateOneRequiredWithoutProjectBomNestedInput
  }

  export type ProjectBomUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    pj_projectDetailId?: IntFieldUpdateOperationsInput | number
    pj_bomId?: StringFieldUpdateOperationsInput | string
    pj_bomamount?: IntFieldUpdateOperationsInput | number
    pj_bomTatal?: IntFieldUpdateOperationsInput | number
  }

  export type ProjectBomCreateManyInput = {
    id?: number
    pj_projectDetailId: number
    pj_bomId: string
    pj_bomamount: number
    pj_bomTatal: number
  }

  export type ProjectBomUpdateManyMutationInput = {
    pj_bomamount?: IntFieldUpdateOperationsInput | number
    pj_bomTatal?: IntFieldUpdateOperationsInput | number
  }

  export type ProjectBomUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    pj_projectDetailId?: IntFieldUpdateOperationsInput | number
    pj_bomId?: StringFieldUpdateOperationsInput | string
    pj_bomamount?: IntFieldUpdateOperationsInput | number
    pj_bomTatal?: IntFieldUpdateOperationsInput | number
  }

  export type ProjectResUserCreateInput = {
    pj_userId: string
    projectDetail: ProjectDetailCreateNestedOneWithoutProjectResUserInput
  }

  export type ProjectResUserUncheckedCreateInput = {
    id?: number
    pj_projectDetailId: number
    pj_userId: string
  }

  export type ProjectResUserUpdateInput = {
    pj_userId?: StringFieldUpdateOperationsInput | string
    projectDetail?: ProjectDetailUpdateOneRequiredWithoutProjectResUserNestedInput
  }

  export type ProjectResUserUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    pj_projectDetailId?: IntFieldUpdateOperationsInput | number
    pj_userId?: StringFieldUpdateOperationsInput | string
  }

  export type ProjectResUserCreateManyInput = {
    id?: number
    pj_projectDetailId: number
    pj_userId: string
  }

  export type ProjectResUserUpdateManyMutationInput = {
    pj_userId?: StringFieldUpdateOperationsInput | string
  }

  export type ProjectResUserUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    pj_projectDetailId?: IntFieldUpdateOperationsInput | number
    pj_userId?: StringFieldUpdateOperationsInput | string
  }

  export type CompanyHourCreateInput = {
    hour: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CompanyHourUncheckedCreateInput = {
    id?: number
    hour: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CompanyHourUpdateInput = {
    hour?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanyHourUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    hour?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanyHourCreateManyInput = {
    id?: number
    hour: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CompanyHourUpdateManyMutationInput = {
    hour?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanyHourUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    hour?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StockCreateInput = {
    stockId: string
    stockName: string
    stockQuantity: number
    stockType: string
    stockTypeId: number
    stockImage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    processMat?: ProcessMatCreateNestedManyWithoutStockInput
    processBom?: ProcessBomCreateNestedManyWithoutStockInput
    projectMat?: ProjectMatCreateNestedManyWithoutStockInput
    projectBom?: ProjectBomCreateNestedManyWithoutStockInput
  }

  export type StockUncheckedCreateInput = {
    id?: number
    stockId: string
    stockName: string
    stockQuantity: number
    stockType: string
    stockTypeId: number
    stockImage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    processMat?: ProcessMatUncheckedCreateNestedManyWithoutStockInput
    processBom?: ProcessBomUncheckedCreateNestedManyWithoutStockInput
    projectMat?: ProjectMatUncheckedCreateNestedManyWithoutStockInput
    projectBom?: ProjectBomUncheckedCreateNestedManyWithoutStockInput
  }

  export type StockUpdateInput = {
    stockId?: StringFieldUpdateOperationsInput | string
    stockName?: StringFieldUpdateOperationsInput | string
    stockQuantity?: IntFieldUpdateOperationsInput | number
    stockType?: StringFieldUpdateOperationsInput | string
    stockTypeId?: IntFieldUpdateOperationsInput | number
    stockImage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    processMat?: ProcessMatUpdateManyWithoutStockNestedInput
    processBom?: ProcessBomUpdateManyWithoutStockNestedInput
    projectMat?: ProjectMatUpdateManyWithoutStockNestedInput
    projectBom?: ProjectBomUpdateManyWithoutStockNestedInput
  }

  export type StockUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    stockId?: StringFieldUpdateOperationsInput | string
    stockName?: StringFieldUpdateOperationsInput | string
    stockQuantity?: IntFieldUpdateOperationsInput | number
    stockType?: StringFieldUpdateOperationsInput | string
    stockTypeId?: IntFieldUpdateOperationsInput | number
    stockImage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    processMat?: ProcessMatUncheckedUpdateManyWithoutStockNestedInput
    processBom?: ProcessBomUncheckedUpdateManyWithoutStockNestedInput
    projectMat?: ProjectMatUncheckedUpdateManyWithoutStockNestedInput
    projectBom?: ProjectBomUncheckedUpdateManyWithoutStockNestedInput
  }

  export type StockCreateManyInput = {
    id?: number
    stockId: string
    stockName: string
    stockQuantity: number
    stockType: string
    stockTypeId: number
    stockImage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type StockUpdateManyMutationInput = {
    stockId?: StringFieldUpdateOperationsInput | string
    stockName?: StringFieldUpdateOperationsInput | string
    stockQuantity?: IntFieldUpdateOperationsInput | number
    stockType?: StringFieldUpdateOperationsInput | string
    stockTypeId?: IntFieldUpdateOperationsInput | number
    stockImage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type StockUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    stockId?: StringFieldUpdateOperationsInput | string
    stockName?: StringFieldUpdateOperationsInput | string
    stockQuantity?: IntFieldUpdateOperationsInput | number
    stockType?: StringFieldUpdateOperationsInput | string
    stockTypeId?: IntFieldUpdateOperationsInput | number
    stockImage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ReasonStockNGCreateInput = {
    reasonstockName: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type ReasonStockNGUncheckedCreateInput = {
    id?: number
    reasonstockName: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type ReasonStockNGUpdateInput = {
    reasonstockName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ReasonStockNGUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    reasonstockName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ReasonStockNGCreateManyInput = {
    id?: number
    reasonstockName: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type ReasonStockNGUpdateManyMutationInput = {
    reasonstockName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ReasonStockNGUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    reasonstockName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ReasonTypeNGCreateInput = {
    reasontypeName: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    reasondDetail?: ReasonDetailCreateNestedManyWithoutReasonTypeNGInput
  }

  export type ReasonTypeNGUncheckedCreateInput = {
    id?: number
    reasontypeName: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    reasondDetail?: ReasonDetailUncheckedCreateNestedManyWithoutReasonTypeNGInput
  }

  export type ReasonTypeNGUpdateInput = {
    reasontypeName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reasondDetail?: ReasonDetailUpdateManyWithoutReasonTypeNGNestedInput
  }

  export type ReasonTypeNGUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    reasontypeName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reasondDetail?: ReasonDetailUncheckedUpdateManyWithoutReasonTypeNGNestedInput
  }

  export type ReasonTypeNGCreateManyInput = {
    id?: number
    reasontypeName: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type ReasonTypeNGUpdateManyMutationInput = {
    reasontypeName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ReasonTypeNGUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    reasontypeName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ReasonDetailCreateInput = {
    reasondetailName: string
    reasonTypeNG: ReasonTypeNGCreateNestedOneWithoutReasondDetailInput
  }

  export type ReasonDetailUncheckedCreateInput = {
    id?: number
    reasonTypeId: number
    reasondetailName: string
  }

  export type ReasonDetailUpdateInput = {
    reasondetailName?: StringFieldUpdateOperationsInput | string
    reasonTypeNG?: ReasonTypeNGUpdateOneRequiredWithoutReasondDetailNestedInput
  }

  export type ReasonDetailUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    reasonTypeId?: IntFieldUpdateOperationsInput | number
    reasondetailName?: StringFieldUpdateOperationsInput | string
  }

  export type ReasonDetailCreateManyInput = {
    id?: number
    reasonTypeId: number
    reasondetailName: string
  }

  export type ReasonDetailUpdateManyMutationInput = {
    reasondetailName?: StringFieldUpdateOperationsInput | string
  }

  export type ReasonDetailUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    reasonTypeId?: IntFieldUpdateOperationsInput | number
    reasondetailName?: StringFieldUpdateOperationsInput | string
  }

  export type ReportCreateInput = {
    projectId: number
    blueprintNo: string
    serialId: string
    reportName: string
    amountComplete: number
    amountNG: number
    timeHour: string
    reportType: string
    status: string
    reasonType?: string | null
    reasonDetail: string
    reasonId?: number | null
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string
    updatedBy: string
    deletedAt?: Date | string | null
    deletedBy: string
    reportProcess?: ReportProcessCreateNestedManyWithoutReportInput
  }

  export type ReportUncheckedCreateInput = {
    id?: number
    projectId: number
    blueprintNo: string
    serialId: string
    reportName: string
    amountComplete: number
    amountNG: number
    timeHour: string
    reportType: string
    status: string
    reasonType?: string | null
    reasonDetail: string
    reasonId?: number | null
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string
    updatedBy: string
    deletedAt?: Date | string | null
    deletedBy: string
    reportProcess?: ReportProcessUncheckedCreateNestedManyWithoutReportInput
  }

  export type ReportUpdateInput = {
    projectId?: IntFieldUpdateOperationsInput | number
    blueprintNo?: StringFieldUpdateOperationsInput | string
    serialId?: StringFieldUpdateOperationsInput | string
    reportName?: StringFieldUpdateOperationsInput | string
    amountComplete?: IntFieldUpdateOperationsInput | number
    amountNG?: IntFieldUpdateOperationsInput | number
    timeHour?: StringFieldUpdateOperationsInput | string
    reportType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    reasonType?: NullableStringFieldUpdateOperationsInput | string | null
    reasonDetail?: StringFieldUpdateOperationsInput | string
    reasonId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: StringFieldUpdateOperationsInput | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: StringFieldUpdateOperationsInput | string
    reportProcess?: ReportProcessUpdateManyWithoutReportNestedInput
  }

  export type ReportUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    projectId?: IntFieldUpdateOperationsInput | number
    blueprintNo?: StringFieldUpdateOperationsInput | string
    serialId?: StringFieldUpdateOperationsInput | string
    reportName?: StringFieldUpdateOperationsInput | string
    amountComplete?: IntFieldUpdateOperationsInput | number
    amountNG?: IntFieldUpdateOperationsInput | number
    timeHour?: StringFieldUpdateOperationsInput | string
    reportType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    reasonType?: NullableStringFieldUpdateOperationsInput | string | null
    reasonDetail?: StringFieldUpdateOperationsInput | string
    reasonId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: StringFieldUpdateOperationsInput | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: StringFieldUpdateOperationsInput | string
    reportProcess?: ReportProcessUncheckedUpdateManyWithoutReportNestedInput
  }

  export type ReportCreateManyInput = {
    id?: number
    projectId: number
    blueprintNo: string
    serialId: string
    reportName: string
    amountComplete: number
    amountNG: number
    timeHour: string
    reportType: string
    status: string
    reasonType?: string | null
    reasonDetail: string
    reasonId?: number | null
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string
    updatedBy: string
    deletedAt?: Date | string | null
    deletedBy: string
  }

  export type ReportUpdateManyMutationInput = {
    projectId?: IntFieldUpdateOperationsInput | number
    blueprintNo?: StringFieldUpdateOperationsInput | string
    serialId?: StringFieldUpdateOperationsInput | string
    reportName?: StringFieldUpdateOperationsInput | string
    amountComplete?: IntFieldUpdateOperationsInput | number
    amountNG?: IntFieldUpdateOperationsInput | number
    timeHour?: StringFieldUpdateOperationsInput | string
    reportType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    reasonType?: NullableStringFieldUpdateOperationsInput | string | null
    reasonDetail?: StringFieldUpdateOperationsInput | string
    reasonId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: StringFieldUpdateOperationsInput | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: StringFieldUpdateOperationsInput | string
  }

  export type ReportUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    projectId?: IntFieldUpdateOperationsInput | number
    blueprintNo?: StringFieldUpdateOperationsInput | string
    serialId?: StringFieldUpdateOperationsInput | string
    reportName?: StringFieldUpdateOperationsInput | string
    amountComplete?: IntFieldUpdateOperationsInput | number
    amountNG?: IntFieldUpdateOperationsInput | number
    timeHour?: StringFieldUpdateOperationsInput | string
    reportType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    reasonType?: NullableStringFieldUpdateOperationsInput | string | null
    reasonDetail?: StringFieldUpdateOperationsInput | string
    reasonId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: StringFieldUpdateOperationsInput | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: StringFieldUpdateOperationsInput | string
  }

  export type ReportProcessCreateInput = {
    processNo: string
    amountday: number
    report: ReportCreateNestedOneWithoutReportProcessInput
    reportStock?: ReportStockCreateNestedManyWithoutReportProcessInput
  }

  export type ReportProcessUncheckedCreateInput = {
    id?: number
    reportId: number
    processNo: string
    amountday: number
    reportStock?: ReportStockUncheckedCreateNestedManyWithoutReportProcessInput
  }

  export type ReportProcessUpdateInput = {
    processNo?: StringFieldUpdateOperationsInput | string
    amountday?: IntFieldUpdateOperationsInput | number
    report?: ReportUpdateOneRequiredWithoutReportProcessNestedInput
    reportStock?: ReportStockUpdateManyWithoutReportProcessNestedInput
  }

  export type ReportProcessUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    reportId?: IntFieldUpdateOperationsInput | number
    processNo?: StringFieldUpdateOperationsInput | string
    amountday?: IntFieldUpdateOperationsInput | number
    reportStock?: ReportStockUncheckedUpdateManyWithoutReportProcessNestedInput
  }

  export type ReportProcessCreateManyInput = {
    id?: number
    reportId: number
    processNo: string
    amountday: number
  }

  export type ReportProcessUpdateManyMutationInput = {
    processNo?: StringFieldUpdateOperationsInput | string
    amountday?: IntFieldUpdateOperationsInput | number
  }

  export type ReportProcessUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    reportId?: IntFieldUpdateOperationsInput | number
    processNo?: StringFieldUpdateOperationsInput | string
    amountday?: IntFieldUpdateOperationsInput | number
  }

  export type ReportStockCreateInput = {
    stockId: string
    stockamount: number
    stocktype: number
    reportProcess: ReportProcessCreateNestedOneWithoutReportStockInput
  }

  export type ReportStockUncheckedCreateInput = {
    id?: number
    reportProcessId: number
    stockId: string
    stockamount: number
    stocktype: number
  }

  export type ReportStockUpdateInput = {
    stockId?: StringFieldUpdateOperationsInput | string
    stockamount?: IntFieldUpdateOperationsInput | number
    stocktype?: IntFieldUpdateOperationsInput | number
    reportProcess?: ReportProcessUpdateOneRequiredWithoutReportStockNestedInput
  }

  export type ReportStockUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    reportProcessId?: IntFieldUpdateOperationsInput | number
    stockId?: StringFieldUpdateOperationsInput | string
    stockamount?: IntFieldUpdateOperationsInput | number
    stocktype?: IntFieldUpdateOperationsInput | number
  }

  export type ReportStockCreateManyInput = {
    id?: number
    reportProcessId: number
    stockId: string
    stockamount: number
    stocktype: number
  }

  export type ReportStockUpdateManyMutationInput = {
    stockId?: StringFieldUpdateOperationsInput | string
    stockamount?: IntFieldUpdateOperationsInput | number
    stocktype?: IntFieldUpdateOperationsInput | number
  }

  export type ReportStockUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    reportProcessId?: IntFieldUpdateOperationsInput | number
    stockId?: StringFieldUpdateOperationsInput | string
    stockamount?: IntFieldUpdateOperationsInput | number
    stocktype?: IntFieldUpdateOperationsInput | number
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type DepartmentNullableRelationFilter = {
    is?: DepartmentWhereInput | null
    isNot?: DepartmentWhereInput | null
  }

  export type ProcessListRelationFilter = {
    every?: ProcessWhereInput
    some?: ProcessWhereInput
    none?: ProcessWhereInput
  }

  export type ExamAttemptListRelationFilter = {
    every?: ExamAttemptWhereInput
    some?: ExamAttemptWhereInput
    none?: ExamAttemptWhereInput
  }

  export type EnrollmentListRelationFilter = {
    every?: EnrollmentWhereInput
    some?: EnrollmentWhereInput
    none?: EnrollmentWhereInput
  }

  export type OplDocumentListRelationFilter = {
    every?: OplDocumentWhereInput
    some?: OplDocumentWhereInput
    none?: OplDocumentWhereInput
  }

  export type FileListRelationFilter = {
    every?: FileWhereInput
    some?: FileWhereInput
    none?: FileWhereInput
  }

  export type CourseListRelationFilter = {
    every?: CourseWhereInput
    some?: CourseWhereInput
    none?: CourseWhereInput
  }

  export type UserCourseCompletionListRelationFilter = {
    every?: UserCourseCompletionWhereInput
    some?: UserCourseCompletionWhereInput
    none?: UserCourseCompletionWhereInput
  }

  export type ProjectListRelationFilter = {
    every?: ProjectWhereInput
    some?: ProjectWhereInput
    none?: ProjectWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type ProcessOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ExamAttemptOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EnrollmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OplDocumentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FileOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CourseOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCourseCompletionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProjectOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserIdUserIdCompoundUniqueInput = {
    id: number
    userId: string
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    password?: SortOrder
    companyId?: SortOrder
    companyBranchId?: SortOrder
    departmentId?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    companyBranchId?: SortOrder
    departmentId?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    password?: SortOrder
    companyId?: SortOrder
    companyBranchId?: SortOrder
    departmentId?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    password?: SortOrder
    companyId?: SortOrder
    companyBranchId?: SortOrder
    departmentId?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    companyBranchId?: SortOrder
    departmentId?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type CompanyBranchListRelationFilter = {
    every?: CompanyBranchWhereInput
    some?: CompanyBranchWhereInput
    none?: CompanyBranchWhereInput
  }

  export type CompanyBranchOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CompanyCountOrderByAggregateInput = {
    id?: SortOrder
    companyName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type CompanyAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type CompanyMaxOrderByAggregateInput = {
    id?: SortOrder
    companyName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type CompanyMinOrderByAggregateInput = {
    id?: SortOrder
    companyName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type CompanySumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type CompanyRelationFilter = {
    is?: CompanyWhereInput
    isNot?: CompanyWhereInput
  }

  export type CompanyBranchCountOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    companyBranchName?: SortOrder
  }

  export type CompanyBranchAvgOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
  }

  export type CompanyBranchMaxOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    companyBranchName?: SortOrder
  }

  export type CompanyBranchMinOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    companyBranchName?: SortOrder
  }

  export type CompanyBranchSumOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
  }

  export type UserListRelationFilter = {
    every?: UserWhereInput
    some?: UserWhereInput
    none?: UserWhereInput
  }

  export type UserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DepartmentCountOrderByAggregateInput = {
    id?: SortOrder
    departmentName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type DepartmentAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type DepartmentMaxOrderByAggregateInput = {
    id?: SortOrder
    departmentName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type DepartmentMinOrderByAggregateInput = {
    id?: SortOrder
    departmentName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type DepartmentSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type ProcessNullableRelationFilter = {
    is?: ProcessWhereInput | null
    isNot?: ProcessWhereInput | null
  }

  export type ExamListRelationFilter = {
    every?: ExamWhereInput
    some?: ExamWhereInput
    none?: ExamWhereInput
  }

  export type UserRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type UserNullableRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type ExamOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CourseCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    pdfUrl?: SortOrder
    videoUrl?: SortOrder
    typeId?: SortOrder
    template?: SortOrder
    departmentId?: SortOrder
    processId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrder
    deletedBy?: SortOrder
    isDeleted?: SortOrder
  }

  export type CourseAvgOrderByAggregateInput = {
    id?: SortOrder
    typeId?: SortOrder
    departmentId?: SortOrder
    processId?: SortOrder
    createdBy?: SortOrder
    deletedBy?: SortOrder
  }

  export type CourseMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    pdfUrl?: SortOrder
    videoUrl?: SortOrder
    typeId?: SortOrder
    template?: SortOrder
    departmentId?: SortOrder
    processId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrder
    deletedBy?: SortOrder
    isDeleted?: SortOrder
  }

  export type CourseMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    pdfUrl?: SortOrder
    videoUrl?: SortOrder
    typeId?: SortOrder
    template?: SortOrder
    departmentId?: SortOrder
    processId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrder
    deletedBy?: SortOrder
    isDeleted?: SortOrder
  }

  export type CourseSumOrderByAggregateInput = {
    id?: SortOrder
    typeId?: SortOrder
    departmentId?: SortOrder
    processId?: SortOrder
    createdBy?: SortOrder
    deletedBy?: SortOrder
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type CourseRelationFilter = {
    is?: CourseWhereInput
    isNot?: CourseWhereInput
  }

  export type ExamRelationFilter = {
    is?: ExamWhereInput
    isNot?: ExamWhereInput
  }

  export type ProcessRelationFilter = {
    is?: ProcessWhereInput
    isNot?: ProcessWhereInput
  }

  export type UserCourseCompletionUserIdCourseIdExamIdCompoundUniqueInput = {
    userId: number
    courseId: number
    examId: number
  }

  export type UserCourseCompletionCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    username?: SortOrder
    courseId?: SortOrder
    examId?: SortOrder
    processId?: SortOrder
    completedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserCourseCompletionAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    courseId?: SortOrder
    examId?: SortOrder
    processId?: SortOrder
  }

  export type UserCourseCompletionMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    username?: SortOrder
    courseId?: SortOrder
    examId?: SortOrder
    processId?: SortOrder
    completedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserCourseCompletionMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    username?: SortOrder
    courseId?: SortOrder
    examId?: SortOrder
    processId?: SortOrder
    completedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserCourseCompletionSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    courseId?: SortOrder
    examId?: SortOrder
    processId?: SortOrder
  }

  export type courseTypeCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
  }

  export type courseTypeAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type courseTypeMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
  }

  export type courseTypeMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
  }

  export type courseTypeSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type EnrollmentCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    courseId?: SortOrder
    progress?: SortOrder
    completed?: SortOrder
    isDownloaded?: SortOrder
  }

  export type EnrollmentAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    courseId?: SortOrder
    progress?: SortOrder
    isDownloaded?: SortOrder
  }

  export type EnrollmentMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    courseId?: SortOrder
    progress?: SortOrder
    completed?: SortOrder
    isDownloaded?: SortOrder
  }

  export type EnrollmentMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    courseId?: SortOrder
    progress?: SortOrder
    completed?: SortOrder
    isDownloaded?: SortOrder
  }

  export type EnrollmentSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    courseId?: SortOrder
    progress?: SortOrder
    isDownloaded?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type QuestionListRelationFilter = {
    every?: QuestionWhereInput
    some?: QuestionWhereInput
    none?: QuestionWhereInput
  }

  export type CourseNullableRelationFilter = {
    is?: CourseWhereInput | null
    isNot?: CourseWhereInput | null
  }

  export type QuestionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ExamCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    departmentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    courseId?: SortOrder
    description?: SortOrder
    deleted?: SortOrder
  }

  export type ExamAvgOrderByAggregateInput = {
    id?: SortOrder
    departmentId?: SortOrder
    courseId?: SortOrder
  }

  export type ExamMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    departmentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    courseId?: SortOrder
    description?: SortOrder
    deleted?: SortOrder
  }

  export type ExamMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    departmentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    courseId?: SortOrder
    description?: SortOrder
    deleted?: SortOrder
  }

  export type ExamSumOrderByAggregateInput = {
    id?: SortOrder
    departmentId?: SortOrder
    courseId?: SortOrder
  }

  export type ChoiceListRelationFilter = {
    every?: ChoiceWhereInput
    some?: ChoiceWhereInput
    none?: ChoiceWhereInput
  }

  export type UserAnswerListRelationFilter = {
    every?: UserAnswerWhereInput
    some?: UserAnswerWhereInput
    none?: UserAnswerWhereInput
  }

  export type ChoiceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserAnswerOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type QuestionCountOrderByAggregateInput = {
    id?: SortOrder
    examId?: SortOrder
    text?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deleted?: SortOrder
  }

  export type QuestionAvgOrderByAggregateInput = {
    id?: SortOrder
    examId?: SortOrder
  }

  export type QuestionMaxOrderByAggregateInput = {
    id?: SortOrder
    examId?: SortOrder
    text?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deleted?: SortOrder
  }

  export type QuestionMinOrderByAggregateInput = {
    id?: SortOrder
    examId?: SortOrder
    text?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deleted?: SortOrder
  }

  export type QuestionSumOrderByAggregateInput = {
    id?: SortOrder
    examId?: SortOrder
  }

  export type QuestionRelationFilter = {
    is?: QuestionWhereInput
    isNot?: QuestionWhereInput
  }

  export type ChoiceCountOrderByAggregateInput = {
    id?: SortOrder
    questionId?: SortOrder
    text?: SortOrder
    correct?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deleted?: SortOrder
  }

  export type ChoiceAvgOrderByAggregateInput = {
    id?: SortOrder
    questionId?: SortOrder
  }

  export type ChoiceMaxOrderByAggregateInput = {
    id?: SortOrder
    questionId?: SortOrder
    text?: SortOrder
    correct?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deleted?: SortOrder
  }

  export type ChoiceMinOrderByAggregateInput = {
    id?: SortOrder
    questionId?: SortOrder
    text?: SortOrder
    correct?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deleted?: SortOrder
  }

  export type ChoiceSumOrderByAggregateInput = {
    id?: SortOrder
    questionId?: SortOrder
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type BoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type ExamAttemptCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    examId?: SortOrder
    startedAt?: SortOrder
    endedAt?: SortOrder
    grade?: SortOrder
    isPassed?: SortOrder
  }

  export type ExamAttemptAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    examId?: SortOrder
    grade?: SortOrder
  }

  export type ExamAttemptMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    examId?: SortOrder
    startedAt?: SortOrder
    endedAt?: SortOrder
    grade?: SortOrder
    isPassed?: SortOrder
  }

  export type ExamAttemptMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    examId?: SortOrder
    startedAt?: SortOrder
    endedAt?: SortOrder
    grade?: SortOrder
    isPassed?: SortOrder
  }

  export type ExamAttemptSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    examId?: SortOrder
    grade?: SortOrder
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type BoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type ExamAttemptRelationFilter = {
    is?: ExamAttemptWhereInput
    isNot?: ExamAttemptWhereInput
  }

  export type ChoiceRelationFilter = {
    is?: ChoiceWhereInput
    isNot?: ChoiceWhereInput
  }

  export type UserAnswerExamAttemptIdQuestionIdCompoundUniqueInput = {
    examAttemptId: number
    questionId: number
  }

  export type UserAnswerCountOrderByAggregateInput = {
    id?: SortOrder
    examAttemptId?: SortOrder
    questionId?: SortOrder
    selectedChoiceId?: SortOrder
    isCorrect?: SortOrder
    createdAt?: SortOrder
  }

  export type UserAnswerAvgOrderByAggregateInput = {
    id?: SortOrder
    examAttemptId?: SortOrder
    questionId?: SortOrder
    selectedChoiceId?: SortOrder
  }

  export type UserAnswerMaxOrderByAggregateInput = {
    id?: SortOrder
    examAttemptId?: SortOrder
    questionId?: SortOrder
    selectedChoiceId?: SortOrder
    isCorrect?: SortOrder
    createdAt?: SortOrder
  }

  export type UserAnswerMinOrderByAggregateInput = {
    id?: SortOrder
    examAttemptId?: SortOrder
    questionId?: SortOrder
    selectedChoiceId?: SortOrder
    isCorrect?: SortOrder
    createdAt?: SortOrder
  }

  export type UserAnswerSumOrderByAggregateInput = {
    id?: SortOrder
    examAttemptId?: SortOrder
    questionId?: SortOrder
    selectedChoiceId?: SortOrder
  }

  export type OplDocumentCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    fileName?: SortOrder
    fileType?: SortOrder
    filePath?: SortOrder
    template?: SortOrder
    createdAt?: SortOrder
    uploadedBy?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type OplDocumentAvgOrderByAggregateInput = {
    id?: SortOrder
    uploadedBy?: SortOrder
  }

  export type OplDocumentMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    fileName?: SortOrder
    fileType?: SortOrder
    filePath?: SortOrder
    template?: SortOrder
    createdAt?: SortOrder
    uploadedBy?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type OplDocumentMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    fileName?: SortOrder
    fileType?: SortOrder
    filePath?: SortOrder
    template?: SortOrder
    createdAt?: SortOrder
    uploadedBy?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type OplDocumentSumOrderByAggregateInput = {
    id?: SortOrder
    uploadedBy?: SortOrder
  }

  export type BigIntFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[]
    notIn?: bigint[] | number[]
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntFilter<$PrismaModel> | bigint | number
  }

  export type FileCountOrderByAggregateInput = {
    id?: SortOrder
    originalName?: SortOrder
    storedName?: SortOrder
    fileType?: SortOrder
    fileSize?: SortOrder
    filePath?: SortOrder
    uploadDate?: SortOrder
    userId?: SortOrder
    courseId?: SortOrder
  }

  export type FileAvgOrderByAggregateInput = {
    id?: SortOrder
    fileSize?: SortOrder
    userId?: SortOrder
    courseId?: SortOrder
  }

  export type FileMaxOrderByAggregateInput = {
    id?: SortOrder
    originalName?: SortOrder
    storedName?: SortOrder
    fileType?: SortOrder
    fileSize?: SortOrder
    filePath?: SortOrder
    uploadDate?: SortOrder
    userId?: SortOrder
    courseId?: SortOrder
  }

  export type FileMinOrderByAggregateInput = {
    id?: SortOrder
    originalName?: SortOrder
    storedName?: SortOrder
    fileType?: SortOrder
    fileSize?: SortOrder
    filePath?: SortOrder
    uploadDate?: SortOrder
    userId?: SortOrder
    courseId?: SortOrder
  }

  export type FileSumOrderByAggregateInput = {
    id?: SortOrder
    fileSize?: SortOrder
    userId?: SortOrder
    courseId?: SortOrder
  }

  export type BigIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[]
    notIn?: bigint[] | number[]
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntWithAggregatesFilter<$PrismaModel> | bigint | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedBigIntFilter<$PrismaModel>
    _min?: NestedBigIntFilter<$PrismaModel>
    _max?: NestedBigIntFilter<$PrismaModel>
  }

  export type ProcessDetailListRelationFilter = {
    every?: ProcessDetailWhereInput
    some?: ProcessDetailWhereInput
    none?: ProcessDetailWhereInput
  }

  export type ProcessDetailOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProcessCountOrderByAggregateInput = {
    id?: SortOrder
    pc_bluePrintNo?: SortOrder
    pc_imageBluePrint?: SortOrder
    pc_totalProcess?: SortOrder
    pc_userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type ProcessAvgOrderByAggregateInput = {
    id?: SortOrder
    pc_totalProcess?: SortOrder
  }

  export type ProcessMaxOrderByAggregateInput = {
    id?: SortOrder
    pc_bluePrintNo?: SortOrder
    pc_imageBluePrint?: SortOrder
    pc_totalProcess?: SortOrder
    pc_userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type ProcessMinOrderByAggregateInput = {
    id?: SortOrder
    pc_bluePrintNo?: SortOrder
    pc_imageBluePrint?: SortOrder
    pc_totalProcess?: SortOrder
    pc_userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type ProcessSumOrderByAggregateInput = {
    id?: SortOrder
    pc_totalProcess?: SortOrder
  }

  export type ProcessBranchListRelationFilter = {
    every?: ProcessBranchWhereInput
    some?: ProcessBranchWhereInput
    none?: ProcessBranchWhereInput
  }

  export type ProcessMatListRelationFilter = {
    every?: ProcessMatWhereInput
    some?: ProcessMatWhereInput
    none?: ProcessMatWhereInput
  }

  export type ProcessBomListRelationFilter = {
    every?: ProcessBomWhereInput
    some?: ProcessBomWhereInput
    none?: ProcessBomWhereInput
  }

  export type ProcessBranchOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProcessMatOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProcessBomOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProcessDetailCountOrderByAggregateInput = {
    id?: SortOrder
    pc_bluePrintNo?: SortOrder
    pc_processTitle?: SortOrder
    pc_amountDay?: SortOrder
    pc_reasonType?: SortOrder
  }

  export type ProcessDetailAvgOrderByAggregateInput = {
    id?: SortOrder
    pc_amountDay?: SortOrder
  }

  export type ProcessDetailMaxOrderByAggregateInput = {
    id?: SortOrder
    pc_bluePrintNo?: SortOrder
    pc_processTitle?: SortOrder
    pc_amountDay?: SortOrder
    pc_reasonType?: SortOrder
  }

  export type ProcessDetailMinOrderByAggregateInput = {
    id?: SortOrder
    pc_bluePrintNo?: SortOrder
    pc_processTitle?: SortOrder
    pc_amountDay?: SortOrder
    pc_reasonType?: SortOrder
  }

  export type ProcessDetailSumOrderByAggregateInput = {
    id?: SortOrder
    pc_amountDay?: SortOrder
  }

  export type ProcessDetailRelationFilter = {
    is?: ProcessDetailWhereInput
    isNot?: ProcessDetailWhereInput
  }

  export type ProcessBranchCountOrderByAggregateInput = {
    id?: SortOrder
    pc_processDetailId?: SortOrder
    pc_remark?: SortOrder
  }

  export type ProcessBranchAvgOrderByAggregateInput = {
    id?: SortOrder
    pc_processDetailId?: SortOrder
  }

  export type ProcessBranchMaxOrderByAggregateInput = {
    id?: SortOrder
    pc_processDetailId?: SortOrder
    pc_remark?: SortOrder
  }

  export type ProcessBranchMinOrderByAggregateInput = {
    id?: SortOrder
    pc_processDetailId?: SortOrder
    pc_remark?: SortOrder
  }

  export type ProcessBranchSumOrderByAggregateInput = {
    id?: SortOrder
    pc_processDetailId?: SortOrder
  }

  export type StockRelationFilter = {
    is?: StockWhereInput
    isNot?: StockWhereInput
  }

  export type ProcessMatCountOrderByAggregateInput = {
    id?: SortOrder
    pc_processDetailId?: SortOrder
    pc_matId?: SortOrder
    pc_matamount?: SortOrder
  }

  export type ProcessMatAvgOrderByAggregateInput = {
    id?: SortOrder
    pc_processDetailId?: SortOrder
    pc_matamount?: SortOrder
  }

  export type ProcessMatMaxOrderByAggregateInput = {
    id?: SortOrder
    pc_processDetailId?: SortOrder
    pc_matId?: SortOrder
    pc_matamount?: SortOrder
  }

  export type ProcessMatMinOrderByAggregateInput = {
    id?: SortOrder
    pc_processDetailId?: SortOrder
    pc_matId?: SortOrder
    pc_matamount?: SortOrder
  }

  export type ProcessMatSumOrderByAggregateInput = {
    id?: SortOrder
    pc_processDetailId?: SortOrder
    pc_matamount?: SortOrder
  }

  export type ProcessBomCountOrderByAggregateInput = {
    id?: SortOrder
    pc_processDetailId?: SortOrder
    pc_bomId?: SortOrder
    pc_bomamount?: SortOrder
  }

  export type ProcessBomAvgOrderByAggregateInput = {
    id?: SortOrder
    pc_processDetailId?: SortOrder
    pc_bomamount?: SortOrder
  }

  export type ProcessBomMaxOrderByAggregateInput = {
    id?: SortOrder
    pc_processDetailId?: SortOrder
    pc_bomId?: SortOrder
    pc_bomamount?: SortOrder
  }

  export type ProcessBomMinOrderByAggregateInput = {
    id?: SortOrder
    pc_processDetailId?: SortOrder
    pc_bomId?: SortOrder
    pc_bomamount?: SortOrder
  }

  export type ProcessBomSumOrderByAggregateInput = {
    id?: SortOrder
    pc_processDetailId?: SortOrder
    pc_bomamount?: SortOrder
  }

  export type ProjectDetailListRelationFilter = {
    every?: ProjectDetailWhereInput
    some?: ProjectDetailWhereInput
    none?: ProjectDetailWhereInput
  }

  export type ProjectDetailOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProjectCountOrderByAggregateInput = {
    id?: SortOrder
    pj_bluePrintNo?: SortOrder
    pj_serialNumber?: SortOrder
    pj_projectName?: SortOrder
    pj_startDate?: SortOrder
    pj_endDate?: SortOrder
    pj_amountProduct?: SortOrder
    pj_totalDay?: SortOrder
    pj_imageProduct?: SortOrder
    pj_remark?: SortOrder
    pj_status?: SortOrder
    pj_type?: SortOrder
    pj_userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type ProjectAvgOrderByAggregateInput = {
    id?: SortOrder
    pj_amountProduct?: SortOrder
    pj_totalDay?: SortOrder
  }

  export type ProjectMaxOrderByAggregateInput = {
    id?: SortOrder
    pj_bluePrintNo?: SortOrder
    pj_serialNumber?: SortOrder
    pj_projectName?: SortOrder
    pj_startDate?: SortOrder
    pj_endDate?: SortOrder
    pj_amountProduct?: SortOrder
    pj_totalDay?: SortOrder
    pj_imageProduct?: SortOrder
    pj_remark?: SortOrder
    pj_status?: SortOrder
    pj_type?: SortOrder
    pj_userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type ProjectMinOrderByAggregateInput = {
    id?: SortOrder
    pj_bluePrintNo?: SortOrder
    pj_serialNumber?: SortOrder
    pj_projectName?: SortOrder
    pj_startDate?: SortOrder
    pj_endDate?: SortOrder
    pj_amountProduct?: SortOrder
    pj_totalDay?: SortOrder
    pj_imageProduct?: SortOrder
    pj_remark?: SortOrder
    pj_status?: SortOrder
    pj_type?: SortOrder
    pj_userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type ProjectSumOrderByAggregateInput = {
    id?: SortOrder
    pj_amountProduct?: SortOrder
    pj_totalDay?: SortOrder
  }

  export type ProjectRelationFilter = {
    is?: ProjectWhereInput
    isNot?: ProjectWhereInput
  }

  export type ProjectBranchListRelationFilter = {
    every?: ProjectBranchWhereInput
    some?: ProjectBranchWhereInput
    none?: ProjectBranchWhereInput
  }

  export type ProjectMatListRelationFilter = {
    every?: ProjectMatWhereInput
    some?: ProjectMatWhereInput
    none?: ProjectMatWhereInput
  }

  export type ProjectBomListRelationFilter = {
    every?: ProjectBomWhereInput
    some?: ProjectBomWhereInput
    none?: ProjectBomWhereInput
  }

  export type ProjectResUserListRelationFilter = {
    every?: ProjectResUserWhereInput
    some?: ProjectResUserWhereInput
    none?: ProjectResUserWhereInput
  }

  export type ProjectBranchOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProjectMatOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProjectBomOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProjectResUserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProjectDetailCountOrderByAggregateInput = {
    id?: SortOrder
    pj_projectId?: SortOrder
    pj_bluePrintNo?: SortOrder
    pj_serialNumber?: SortOrder
    pj_processTitle?: SortOrder
    pj_amountDay?: SortOrder
    pj_reasonType?: SortOrder
    pj_statusPc?: SortOrder
  }

  export type ProjectDetailAvgOrderByAggregateInput = {
    id?: SortOrder
    pj_projectId?: SortOrder
    pj_amountDay?: SortOrder
  }

  export type ProjectDetailMaxOrderByAggregateInput = {
    id?: SortOrder
    pj_projectId?: SortOrder
    pj_bluePrintNo?: SortOrder
    pj_serialNumber?: SortOrder
    pj_processTitle?: SortOrder
    pj_amountDay?: SortOrder
    pj_reasonType?: SortOrder
    pj_statusPc?: SortOrder
  }

  export type ProjectDetailMinOrderByAggregateInput = {
    id?: SortOrder
    pj_projectId?: SortOrder
    pj_bluePrintNo?: SortOrder
    pj_serialNumber?: SortOrder
    pj_processTitle?: SortOrder
    pj_amountDay?: SortOrder
    pj_reasonType?: SortOrder
    pj_statusPc?: SortOrder
  }

  export type ProjectDetailSumOrderByAggregateInput = {
    id?: SortOrder
    pj_projectId?: SortOrder
    pj_amountDay?: SortOrder
  }

  export type ProjectDetailRelationFilter = {
    is?: ProjectDetailWhereInput
    isNot?: ProjectDetailWhereInput
  }

  export type ProjectBranchCountOrderByAggregateInput = {
    id?: SortOrder
    pj_projectDetailId?: SortOrder
    pj_remark?: SortOrder
  }

  export type ProjectBranchAvgOrderByAggregateInput = {
    id?: SortOrder
    pj_projectDetailId?: SortOrder
  }

  export type ProjectBranchMaxOrderByAggregateInput = {
    id?: SortOrder
    pj_projectDetailId?: SortOrder
    pj_remark?: SortOrder
  }

  export type ProjectBranchMinOrderByAggregateInput = {
    id?: SortOrder
    pj_projectDetailId?: SortOrder
    pj_remark?: SortOrder
  }

  export type ProjectBranchSumOrderByAggregateInput = {
    id?: SortOrder
    pj_projectDetailId?: SortOrder
  }

  export type ProjectMatCountOrderByAggregateInput = {
    id?: SortOrder
    pj_projectDetailId?: SortOrder
    pj_matId?: SortOrder
    pj_matamount?: SortOrder
    pj_matTatal?: SortOrder
  }

  export type ProjectMatAvgOrderByAggregateInput = {
    id?: SortOrder
    pj_projectDetailId?: SortOrder
    pj_matamount?: SortOrder
    pj_matTatal?: SortOrder
  }

  export type ProjectMatMaxOrderByAggregateInput = {
    id?: SortOrder
    pj_projectDetailId?: SortOrder
    pj_matId?: SortOrder
    pj_matamount?: SortOrder
    pj_matTatal?: SortOrder
  }

  export type ProjectMatMinOrderByAggregateInput = {
    id?: SortOrder
    pj_projectDetailId?: SortOrder
    pj_matId?: SortOrder
    pj_matamount?: SortOrder
    pj_matTatal?: SortOrder
  }

  export type ProjectMatSumOrderByAggregateInput = {
    id?: SortOrder
    pj_projectDetailId?: SortOrder
    pj_matamount?: SortOrder
    pj_matTatal?: SortOrder
  }

  export type ProjectBomCountOrderByAggregateInput = {
    id?: SortOrder
    pj_projectDetailId?: SortOrder
    pj_bomId?: SortOrder
    pj_bomamount?: SortOrder
    pj_bomTatal?: SortOrder
  }

  export type ProjectBomAvgOrderByAggregateInput = {
    id?: SortOrder
    pj_projectDetailId?: SortOrder
    pj_bomamount?: SortOrder
    pj_bomTatal?: SortOrder
  }

  export type ProjectBomMaxOrderByAggregateInput = {
    id?: SortOrder
    pj_projectDetailId?: SortOrder
    pj_bomId?: SortOrder
    pj_bomamount?: SortOrder
    pj_bomTatal?: SortOrder
  }

  export type ProjectBomMinOrderByAggregateInput = {
    id?: SortOrder
    pj_projectDetailId?: SortOrder
    pj_bomId?: SortOrder
    pj_bomamount?: SortOrder
    pj_bomTatal?: SortOrder
  }

  export type ProjectBomSumOrderByAggregateInput = {
    id?: SortOrder
    pj_projectDetailId?: SortOrder
    pj_bomamount?: SortOrder
    pj_bomTatal?: SortOrder
  }

  export type ProjectResUserCountOrderByAggregateInput = {
    id?: SortOrder
    pj_projectDetailId?: SortOrder
    pj_userId?: SortOrder
  }

  export type ProjectResUserAvgOrderByAggregateInput = {
    id?: SortOrder
    pj_projectDetailId?: SortOrder
  }

  export type ProjectResUserMaxOrderByAggregateInput = {
    id?: SortOrder
    pj_projectDetailId?: SortOrder
    pj_userId?: SortOrder
  }

  export type ProjectResUserMinOrderByAggregateInput = {
    id?: SortOrder
    pj_projectDetailId?: SortOrder
    pj_userId?: SortOrder
  }

  export type ProjectResUserSumOrderByAggregateInput = {
    id?: SortOrder
    pj_projectDetailId?: SortOrder
  }

  export type CompanyHourCountOrderByAggregateInput = {
    id?: SortOrder
    hour?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CompanyHourAvgOrderByAggregateInput = {
    id?: SortOrder
    hour?: SortOrder
  }

  export type CompanyHourMaxOrderByAggregateInput = {
    id?: SortOrder
    hour?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CompanyHourMinOrderByAggregateInput = {
    id?: SortOrder
    hour?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CompanyHourSumOrderByAggregateInput = {
    id?: SortOrder
    hour?: SortOrder
  }

  export type StockCountOrderByAggregateInput = {
    id?: SortOrder
    stockId?: SortOrder
    stockName?: SortOrder
    stockQuantity?: SortOrder
    stockType?: SortOrder
    stockTypeId?: SortOrder
    stockImage?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type StockAvgOrderByAggregateInput = {
    id?: SortOrder
    stockQuantity?: SortOrder
    stockTypeId?: SortOrder
  }

  export type StockMaxOrderByAggregateInput = {
    id?: SortOrder
    stockId?: SortOrder
    stockName?: SortOrder
    stockQuantity?: SortOrder
    stockType?: SortOrder
    stockTypeId?: SortOrder
    stockImage?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type StockMinOrderByAggregateInput = {
    id?: SortOrder
    stockId?: SortOrder
    stockName?: SortOrder
    stockQuantity?: SortOrder
    stockType?: SortOrder
    stockTypeId?: SortOrder
    stockImage?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type StockSumOrderByAggregateInput = {
    id?: SortOrder
    stockQuantity?: SortOrder
    stockTypeId?: SortOrder
  }

  export type ReasonStockNGCountOrderByAggregateInput = {
    id?: SortOrder
    reasonstockName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type ReasonStockNGAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ReasonStockNGMaxOrderByAggregateInput = {
    id?: SortOrder
    reasonstockName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type ReasonStockNGMinOrderByAggregateInput = {
    id?: SortOrder
    reasonstockName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type ReasonStockNGSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ReasonDetailListRelationFilter = {
    every?: ReasonDetailWhereInput
    some?: ReasonDetailWhereInput
    none?: ReasonDetailWhereInput
  }

  export type ReasonDetailOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ReasonTypeNGCountOrderByAggregateInput = {
    id?: SortOrder
    reasontypeName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type ReasonTypeNGAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ReasonTypeNGMaxOrderByAggregateInput = {
    id?: SortOrder
    reasontypeName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type ReasonTypeNGMinOrderByAggregateInput = {
    id?: SortOrder
    reasontypeName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type ReasonTypeNGSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ReasonTypeNGRelationFilter = {
    is?: ReasonTypeNGWhereInput
    isNot?: ReasonTypeNGWhereInput
  }

  export type ReasonDetailCountOrderByAggregateInput = {
    id?: SortOrder
    reasonTypeId?: SortOrder
    reasondetailName?: SortOrder
  }

  export type ReasonDetailAvgOrderByAggregateInput = {
    id?: SortOrder
    reasonTypeId?: SortOrder
  }

  export type ReasonDetailMaxOrderByAggregateInput = {
    id?: SortOrder
    reasonTypeId?: SortOrder
    reasondetailName?: SortOrder
  }

  export type ReasonDetailMinOrderByAggregateInput = {
    id?: SortOrder
    reasonTypeId?: SortOrder
    reasondetailName?: SortOrder
  }

  export type ReasonDetailSumOrderByAggregateInput = {
    id?: SortOrder
    reasonTypeId?: SortOrder
  }

  export type ReportProcessListRelationFilter = {
    every?: ReportProcessWhereInput
    some?: ReportProcessWhereInput
    none?: ReportProcessWhereInput
  }

  export type ReportProcessOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ReportCountOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    blueprintNo?: SortOrder
    serialId?: SortOrder
    reportName?: SortOrder
    amountComplete?: SortOrder
    amountNG?: SortOrder
    timeHour?: SortOrder
    reportType?: SortOrder
    status?: SortOrder
    reasonType?: SortOrder
    reasonDetail?: SortOrder
    reasonId?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
    deletedAt?: SortOrder
    deletedBy?: SortOrder
  }

  export type ReportAvgOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    amountComplete?: SortOrder
    amountNG?: SortOrder
    reasonId?: SortOrder
  }

  export type ReportMaxOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    blueprintNo?: SortOrder
    serialId?: SortOrder
    reportName?: SortOrder
    amountComplete?: SortOrder
    amountNG?: SortOrder
    timeHour?: SortOrder
    reportType?: SortOrder
    status?: SortOrder
    reasonType?: SortOrder
    reasonDetail?: SortOrder
    reasonId?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
    deletedAt?: SortOrder
    deletedBy?: SortOrder
  }

  export type ReportMinOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    blueprintNo?: SortOrder
    serialId?: SortOrder
    reportName?: SortOrder
    amountComplete?: SortOrder
    amountNG?: SortOrder
    timeHour?: SortOrder
    reportType?: SortOrder
    status?: SortOrder
    reasonType?: SortOrder
    reasonDetail?: SortOrder
    reasonId?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
    deletedAt?: SortOrder
    deletedBy?: SortOrder
  }

  export type ReportSumOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    amountComplete?: SortOrder
    amountNG?: SortOrder
    reasonId?: SortOrder
  }

  export type ReportRelationFilter = {
    is?: ReportWhereInput
    isNot?: ReportWhereInput
  }

  export type ReportStockListRelationFilter = {
    every?: ReportStockWhereInput
    some?: ReportStockWhereInput
    none?: ReportStockWhereInput
  }

  export type ReportStockOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ReportProcessCountOrderByAggregateInput = {
    id?: SortOrder
    reportId?: SortOrder
    processNo?: SortOrder
    amountday?: SortOrder
  }

  export type ReportProcessAvgOrderByAggregateInput = {
    id?: SortOrder
    reportId?: SortOrder
    amountday?: SortOrder
  }

  export type ReportProcessMaxOrderByAggregateInput = {
    id?: SortOrder
    reportId?: SortOrder
    processNo?: SortOrder
    amountday?: SortOrder
  }

  export type ReportProcessMinOrderByAggregateInput = {
    id?: SortOrder
    reportId?: SortOrder
    processNo?: SortOrder
    amountday?: SortOrder
  }

  export type ReportProcessSumOrderByAggregateInput = {
    id?: SortOrder
    reportId?: SortOrder
    amountday?: SortOrder
  }

  export type ReportProcessRelationFilter = {
    is?: ReportProcessWhereInput
    isNot?: ReportProcessWhereInput
  }

  export type ReportStockCountOrderByAggregateInput = {
    id?: SortOrder
    reportProcessId?: SortOrder
    stockId?: SortOrder
    stockamount?: SortOrder
    stocktype?: SortOrder
  }

  export type ReportStockAvgOrderByAggregateInput = {
    id?: SortOrder
    reportProcessId?: SortOrder
    stockamount?: SortOrder
    stocktype?: SortOrder
  }

  export type ReportStockMaxOrderByAggregateInput = {
    id?: SortOrder
    reportProcessId?: SortOrder
    stockId?: SortOrder
    stockamount?: SortOrder
    stocktype?: SortOrder
  }

  export type ReportStockMinOrderByAggregateInput = {
    id?: SortOrder
    reportProcessId?: SortOrder
    stockId?: SortOrder
    stockamount?: SortOrder
    stocktype?: SortOrder
  }

  export type ReportStockSumOrderByAggregateInput = {
    id?: SortOrder
    reportProcessId?: SortOrder
    stockamount?: SortOrder
    stocktype?: SortOrder
  }

  export type DepartmentCreateNestedOneWithoutUserInput = {
    create?: XOR<DepartmentCreateWithoutUserInput, DepartmentUncheckedCreateWithoutUserInput>
    connectOrCreate?: DepartmentCreateOrConnectWithoutUserInput
    connect?: DepartmentWhereUniqueInput
  }

  export type ProcessCreateNestedManyWithoutUserInput = {
    create?: XOR<ProcessCreateWithoutUserInput, ProcessUncheckedCreateWithoutUserInput> | ProcessCreateWithoutUserInput[] | ProcessUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProcessCreateOrConnectWithoutUserInput | ProcessCreateOrConnectWithoutUserInput[]
    createMany?: ProcessCreateManyUserInputEnvelope
    connect?: ProcessWhereUniqueInput | ProcessWhereUniqueInput[]
  }

  export type ExamAttemptCreateNestedManyWithoutUserInput = {
    create?: XOR<ExamAttemptCreateWithoutUserInput, ExamAttemptUncheckedCreateWithoutUserInput> | ExamAttemptCreateWithoutUserInput[] | ExamAttemptUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ExamAttemptCreateOrConnectWithoutUserInput | ExamAttemptCreateOrConnectWithoutUserInput[]
    createMany?: ExamAttemptCreateManyUserInputEnvelope
    connect?: ExamAttemptWhereUniqueInput | ExamAttemptWhereUniqueInput[]
  }

  export type EnrollmentCreateNestedManyWithoutUserInput = {
    create?: XOR<EnrollmentCreateWithoutUserInput, EnrollmentUncheckedCreateWithoutUserInput> | EnrollmentCreateWithoutUserInput[] | EnrollmentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: EnrollmentCreateOrConnectWithoutUserInput | EnrollmentCreateOrConnectWithoutUserInput[]
    createMany?: EnrollmentCreateManyUserInputEnvelope
    connect?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[]
  }

  export type OplDocumentCreateNestedManyWithoutUserInput = {
    create?: XOR<OplDocumentCreateWithoutUserInput, OplDocumentUncheckedCreateWithoutUserInput> | OplDocumentCreateWithoutUserInput[] | OplDocumentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: OplDocumentCreateOrConnectWithoutUserInput | OplDocumentCreateOrConnectWithoutUserInput[]
    createMany?: OplDocumentCreateManyUserInputEnvelope
    connect?: OplDocumentWhereUniqueInput | OplDocumentWhereUniqueInput[]
  }

  export type FileCreateNestedManyWithoutUserInput = {
    create?: XOR<FileCreateWithoutUserInput, FileUncheckedCreateWithoutUserInput> | FileCreateWithoutUserInput[] | FileUncheckedCreateWithoutUserInput[]
    connectOrCreate?: FileCreateOrConnectWithoutUserInput | FileCreateOrConnectWithoutUserInput[]
    createMany?: FileCreateManyUserInputEnvelope
    connect?: FileWhereUniqueInput | FileWhereUniqueInput[]
  }

  export type CourseCreateNestedManyWithoutCreatorInput = {
    create?: XOR<CourseCreateWithoutCreatorInput, CourseUncheckedCreateWithoutCreatorInput> | CourseCreateWithoutCreatorInput[] | CourseUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: CourseCreateOrConnectWithoutCreatorInput | CourseCreateOrConnectWithoutCreatorInput[]
    createMany?: CourseCreateManyCreatorInputEnvelope
    connect?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
  }

  export type CourseCreateNestedManyWithoutDeleterInput = {
    create?: XOR<CourseCreateWithoutDeleterInput, CourseUncheckedCreateWithoutDeleterInput> | CourseCreateWithoutDeleterInput[] | CourseUncheckedCreateWithoutDeleterInput[]
    connectOrCreate?: CourseCreateOrConnectWithoutDeleterInput | CourseCreateOrConnectWithoutDeleterInput[]
    createMany?: CourseCreateManyDeleterInputEnvelope
    connect?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
  }

  export type UserCourseCompletionCreateNestedManyWithoutUserInput = {
    create?: XOR<UserCourseCompletionCreateWithoutUserInput, UserCourseCompletionUncheckedCreateWithoutUserInput> | UserCourseCompletionCreateWithoutUserInput[] | UserCourseCompletionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserCourseCompletionCreateOrConnectWithoutUserInput | UserCourseCompletionCreateOrConnectWithoutUserInput[]
    createMany?: UserCourseCompletionCreateManyUserInputEnvelope
    connect?: UserCourseCompletionWhereUniqueInput | UserCourseCompletionWhereUniqueInput[]
  }

  export type ProjectCreateNestedManyWithoutUserInput = {
    create?: XOR<ProjectCreateWithoutUserInput, ProjectUncheckedCreateWithoutUserInput> | ProjectCreateWithoutUserInput[] | ProjectUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutUserInput | ProjectCreateOrConnectWithoutUserInput[]
    createMany?: ProjectCreateManyUserInputEnvelope
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
  }

  export type ProcessUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ProcessCreateWithoutUserInput, ProcessUncheckedCreateWithoutUserInput> | ProcessCreateWithoutUserInput[] | ProcessUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProcessCreateOrConnectWithoutUserInput | ProcessCreateOrConnectWithoutUserInput[]
    createMany?: ProcessCreateManyUserInputEnvelope
    connect?: ProcessWhereUniqueInput | ProcessWhereUniqueInput[]
  }

  export type ExamAttemptUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ExamAttemptCreateWithoutUserInput, ExamAttemptUncheckedCreateWithoutUserInput> | ExamAttemptCreateWithoutUserInput[] | ExamAttemptUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ExamAttemptCreateOrConnectWithoutUserInput | ExamAttemptCreateOrConnectWithoutUserInput[]
    createMany?: ExamAttemptCreateManyUserInputEnvelope
    connect?: ExamAttemptWhereUniqueInput | ExamAttemptWhereUniqueInput[]
  }

  export type EnrollmentUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<EnrollmentCreateWithoutUserInput, EnrollmentUncheckedCreateWithoutUserInput> | EnrollmentCreateWithoutUserInput[] | EnrollmentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: EnrollmentCreateOrConnectWithoutUserInput | EnrollmentCreateOrConnectWithoutUserInput[]
    createMany?: EnrollmentCreateManyUserInputEnvelope
    connect?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[]
  }

  export type OplDocumentUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<OplDocumentCreateWithoutUserInput, OplDocumentUncheckedCreateWithoutUserInput> | OplDocumentCreateWithoutUserInput[] | OplDocumentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: OplDocumentCreateOrConnectWithoutUserInput | OplDocumentCreateOrConnectWithoutUserInput[]
    createMany?: OplDocumentCreateManyUserInputEnvelope
    connect?: OplDocumentWhereUniqueInput | OplDocumentWhereUniqueInput[]
  }

  export type FileUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<FileCreateWithoutUserInput, FileUncheckedCreateWithoutUserInput> | FileCreateWithoutUserInput[] | FileUncheckedCreateWithoutUserInput[]
    connectOrCreate?: FileCreateOrConnectWithoutUserInput | FileCreateOrConnectWithoutUserInput[]
    createMany?: FileCreateManyUserInputEnvelope
    connect?: FileWhereUniqueInput | FileWhereUniqueInput[]
  }

  export type CourseUncheckedCreateNestedManyWithoutCreatorInput = {
    create?: XOR<CourseCreateWithoutCreatorInput, CourseUncheckedCreateWithoutCreatorInput> | CourseCreateWithoutCreatorInput[] | CourseUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: CourseCreateOrConnectWithoutCreatorInput | CourseCreateOrConnectWithoutCreatorInput[]
    createMany?: CourseCreateManyCreatorInputEnvelope
    connect?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
  }

  export type CourseUncheckedCreateNestedManyWithoutDeleterInput = {
    create?: XOR<CourseCreateWithoutDeleterInput, CourseUncheckedCreateWithoutDeleterInput> | CourseCreateWithoutDeleterInput[] | CourseUncheckedCreateWithoutDeleterInput[]
    connectOrCreate?: CourseCreateOrConnectWithoutDeleterInput | CourseCreateOrConnectWithoutDeleterInput[]
    createMany?: CourseCreateManyDeleterInputEnvelope
    connect?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
  }

  export type UserCourseCompletionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserCourseCompletionCreateWithoutUserInput, UserCourseCompletionUncheckedCreateWithoutUserInput> | UserCourseCompletionCreateWithoutUserInput[] | UserCourseCompletionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserCourseCompletionCreateOrConnectWithoutUserInput | UserCourseCompletionCreateOrConnectWithoutUserInput[]
    createMany?: UserCourseCompletionCreateManyUserInputEnvelope
    connect?: UserCourseCompletionWhereUniqueInput | UserCourseCompletionWhereUniqueInput[]
  }

  export type ProjectUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ProjectCreateWithoutUserInput, ProjectUncheckedCreateWithoutUserInput> | ProjectCreateWithoutUserInput[] | ProjectUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutUserInput | ProjectCreateOrConnectWithoutUserInput[]
    createMany?: ProjectCreateManyUserInputEnvelope
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type DepartmentUpdateOneWithoutUserNestedInput = {
    create?: XOR<DepartmentCreateWithoutUserInput, DepartmentUncheckedCreateWithoutUserInput>
    connectOrCreate?: DepartmentCreateOrConnectWithoutUserInput
    upsert?: DepartmentUpsertWithoutUserInput
    disconnect?: DepartmentWhereInput | boolean
    delete?: DepartmentWhereInput | boolean
    connect?: DepartmentWhereUniqueInput
    update?: XOR<XOR<DepartmentUpdateToOneWithWhereWithoutUserInput, DepartmentUpdateWithoutUserInput>, DepartmentUncheckedUpdateWithoutUserInput>
  }

  export type ProcessUpdateManyWithoutUserNestedInput = {
    create?: XOR<ProcessCreateWithoutUserInput, ProcessUncheckedCreateWithoutUserInput> | ProcessCreateWithoutUserInput[] | ProcessUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProcessCreateOrConnectWithoutUserInput | ProcessCreateOrConnectWithoutUserInput[]
    upsert?: ProcessUpsertWithWhereUniqueWithoutUserInput | ProcessUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ProcessCreateManyUserInputEnvelope
    set?: ProcessWhereUniqueInput | ProcessWhereUniqueInput[]
    disconnect?: ProcessWhereUniqueInput | ProcessWhereUniqueInput[]
    delete?: ProcessWhereUniqueInput | ProcessWhereUniqueInput[]
    connect?: ProcessWhereUniqueInput | ProcessWhereUniqueInput[]
    update?: ProcessUpdateWithWhereUniqueWithoutUserInput | ProcessUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ProcessUpdateManyWithWhereWithoutUserInput | ProcessUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ProcessScalarWhereInput | ProcessScalarWhereInput[]
  }

  export type ExamAttemptUpdateManyWithoutUserNestedInput = {
    create?: XOR<ExamAttemptCreateWithoutUserInput, ExamAttemptUncheckedCreateWithoutUserInput> | ExamAttemptCreateWithoutUserInput[] | ExamAttemptUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ExamAttemptCreateOrConnectWithoutUserInput | ExamAttemptCreateOrConnectWithoutUserInput[]
    upsert?: ExamAttemptUpsertWithWhereUniqueWithoutUserInput | ExamAttemptUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ExamAttemptCreateManyUserInputEnvelope
    set?: ExamAttemptWhereUniqueInput | ExamAttemptWhereUniqueInput[]
    disconnect?: ExamAttemptWhereUniqueInput | ExamAttemptWhereUniqueInput[]
    delete?: ExamAttemptWhereUniqueInput | ExamAttemptWhereUniqueInput[]
    connect?: ExamAttemptWhereUniqueInput | ExamAttemptWhereUniqueInput[]
    update?: ExamAttemptUpdateWithWhereUniqueWithoutUserInput | ExamAttemptUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ExamAttemptUpdateManyWithWhereWithoutUserInput | ExamAttemptUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ExamAttemptScalarWhereInput | ExamAttemptScalarWhereInput[]
  }

  export type EnrollmentUpdateManyWithoutUserNestedInput = {
    create?: XOR<EnrollmentCreateWithoutUserInput, EnrollmentUncheckedCreateWithoutUserInput> | EnrollmentCreateWithoutUserInput[] | EnrollmentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: EnrollmentCreateOrConnectWithoutUserInput | EnrollmentCreateOrConnectWithoutUserInput[]
    upsert?: EnrollmentUpsertWithWhereUniqueWithoutUserInput | EnrollmentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: EnrollmentCreateManyUserInputEnvelope
    set?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[]
    disconnect?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[]
    delete?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[]
    connect?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[]
    update?: EnrollmentUpdateWithWhereUniqueWithoutUserInput | EnrollmentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: EnrollmentUpdateManyWithWhereWithoutUserInput | EnrollmentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: EnrollmentScalarWhereInput | EnrollmentScalarWhereInput[]
  }

  export type OplDocumentUpdateManyWithoutUserNestedInput = {
    create?: XOR<OplDocumentCreateWithoutUserInput, OplDocumentUncheckedCreateWithoutUserInput> | OplDocumentCreateWithoutUserInput[] | OplDocumentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: OplDocumentCreateOrConnectWithoutUserInput | OplDocumentCreateOrConnectWithoutUserInput[]
    upsert?: OplDocumentUpsertWithWhereUniqueWithoutUserInput | OplDocumentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: OplDocumentCreateManyUserInputEnvelope
    set?: OplDocumentWhereUniqueInput | OplDocumentWhereUniqueInput[]
    disconnect?: OplDocumentWhereUniqueInput | OplDocumentWhereUniqueInput[]
    delete?: OplDocumentWhereUniqueInput | OplDocumentWhereUniqueInput[]
    connect?: OplDocumentWhereUniqueInput | OplDocumentWhereUniqueInput[]
    update?: OplDocumentUpdateWithWhereUniqueWithoutUserInput | OplDocumentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: OplDocumentUpdateManyWithWhereWithoutUserInput | OplDocumentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: OplDocumentScalarWhereInput | OplDocumentScalarWhereInput[]
  }

  export type FileUpdateManyWithoutUserNestedInput = {
    create?: XOR<FileCreateWithoutUserInput, FileUncheckedCreateWithoutUserInput> | FileCreateWithoutUserInput[] | FileUncheckedCreateWithoutUserInput[]
    connectOrCreate?: FileCreateOrConnectWithoutUserInput | FileCreateOrConnectWithoutUserInput[]
    upsert?: FileUpsertWithWhereUniqueWithoutUserInput | FileUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: FileCreateManyUserInputEnvelope
    set?: FileWhereUniqueInput | FileWhereUniqueInput[]
    disconnect?: FileWhereUniqueInput | FileWhereUniqueInput[]
    delete?: FileWhereUniqueInput | FileWhereUniqueInput[]
    connect?: FileWhereUniqueInput | FileWhereUniqueInput[]
    update?: FileUpdateWithWhereUniqueWithoutUserInput | FileUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: FileUpdateManyWithWhereWithoutUserInput | FileUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: FileScalarWhereInput | FileScalarWhereInput[]
  }

  export type CourseUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<CourseCreateWithoutCreatorInput, CourseUncheckedCreateWithoutCreatorInput> | CourseCreateWithoutCreatorInput[] | CourseUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: CourseCreateOrConnectWithoutCreatorInput | CourseCreateOrConnectWithoutCreatorInput[]
    upsert?: CourseUpsertWithWhereUniqueWithoutCreatorInput | CourseUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: CourseCreateManyCreatorInputEnvelope
    set?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
    disconnect?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
    delete?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
    connect?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
    update?: CourseUpdateWithWhereUniqueWithoutCreatorInput | CourseUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: CourseUpdateManyWithWhereWithoutCreatorInput | CourseUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: CourseScalarWhereInput | CourseScalarWhereInput[]
  }

  export type CourseUpdateManyWithoutDeleterNestedInput = {
    create?: XOR<CourseCreateWithoutDeleterInput, CourseUncheckedCreateWithoutDeleterInput> | CourseCreateWithoutDeleterInput[] | CourseUncheckedCreateWithoutDeleterInput[]
    connectOrCreate?: CourseCreateOrConnectWithoutDeleterInput | CourseCreateOrConnectWithoutDeleterInput[]
    upsert?: CourseUpsertWithWhereUniqueWithoutDeleterInput | CourseUpsertWithWhereUniqueWithoutDeleterInput[]
    createMany?: CourseCreateManyDeleterInputEnvelope
    set?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
    disconnect?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
    delete?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
    connect?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
    update?: CourseUpdateWithWhereUniqueWithoutDeleterInput | CourseUpdateWithWhereUniqueWithoutDeleterInput[]
    updateMany?: CourseUpdateManyWithWhereWithoutDeleterInput | CourseUpdateManyWithWhereWithoutDeleterInput[]
    deleteMany?: CourseScalarWhereInput | CourseScalarWhereInput[]
  }

  export type UserCourseCompletionUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserCourseCompletionCreateWithoutUserInput, UserCourseCompletionUncheckedCreateWithoutUserInput> | UserCourseCompletionCreateWithoutUserInput[] | UserCourseCompletionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserCourseCompletionCreateOrConnectWithoutUserInput | UserCourseCompletionCreateOrConnectWithoutUserInput[]
    upsert?: UserCourseCompletionUpsertWithWhereUniqueWithoutUserInput | UserCourseCompletionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserCourseCompletionCreateManyUserInputEnvelope
    set?: UserCourseCompletionWhereUniqueInput | UserCourseCompletionWhereUniqueInput[]
    disconnect?: UserCourseCompletionWhereUniqueInput | UserCourseCompletionWhereUniqueInput[]
    delete?: UserCourseCompletionWhereUniqueInput | UserCourseCompletionWhereUniqueInput[]
    connect?: UserCourseCompletionWhereUniqueInput | UserCourseCompletionWhereUniqueInput[]
    update?: UserCourseCompletionUpdateWithWhereUniqueWithoutUserInput | UserCourseCompletionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserCourseCompletionUpdateManyWithWhereWithoutUserInput | UserCourseCompletionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserCourseCompletionScalarWhereInput | UserCourseCompletionScalarWhereInput[]
  }

  export type ProjectUpdateManyWithoutUserNestedInput = {
    create?: XOR<ProjectCreateWithoutUserInput, ProjectUncheckedCreateWithoutUserInput> | ProjectCreateWithoutUserInput[] | ProjectUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutUserInput | ProjectCreateOrConnectWithoutUserInput[]
    upsert?: ProjectUpsertWithWhereUniqueWithoutUserInput | ProjectUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ProjectCreateManyUserInputEnvelope
    set?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    disconnect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    delete?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    update?: ProjectUpdateWithWhereUniqueWithoutUserInput | ProjectUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ProjectUpdateManyWithWhereWithoutUserInput | ProjectUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ProjectScalarWhereInput | ProjectScalarWhereInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type ProcessUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ProcessCreateWithoutUserInput, ProcessUncheckedCreateWithoutUserInput> | ProcessCreateWithoutUserInput[] | ProcessUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProcessCreateOrConnectWithoutUserInput | ProcessCreateOrConnectWithoutUserInput[]
    upsert?: ProcessUpsertWithWhereUniqueWithoutUserInput | ProcessUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ProcessCreateManyUserInputEnvelope
    set?: ProcessWhereUniqueInput | ProcessWhereUniqueInput[]
    disconnect?: ProcessWhereUniqueInput | ProcessWhereUniqueInput[]
    delete?: ProcessWhereUniqueInput | ProcessWhereUniqueInput[]
    connect?: ProcessWhereUniqueInput | ProcessWhereUniqueInput[]
    update?: ProcessUpdateWithWhereUniqueWithoutUserInput | ProcessUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ProcessUpdateManyWithWhereWithoutUserInput | ProcessUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ProcessScalarWhereInput | ProcessScalarWhereInput[]
  }

  export type ExamAttemptUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ExamAttemptCreateWithoutUserInput, ExamAttemptUncheckedCreateWithoutUserInput> | ExamAttemptCreateWithoutUserInput[] | ExamAttemptUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ExamAttemptCreateOrConnectWithoutUserInput | ExamAttemptCreateOrConnectWithoutUserInput[]
    upsert?: ExamAttemptUpsertWithWhereUniqueWithoutUserInput | ExamAttemptUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ExamAttemptCreateManyUserInputEnvelope
    set?: ExamAttemptWhereUniqueInput | ExamAttemptWhereUniqueInput[]
    disconnect?: ExamAttemptWhereUniqueInput | ExamAttemptWhereUniqueInput[]
    delete?: ExamAttemptWhereUniqueInput | ExamAttemptWhereUniqueInput[]
    connect?: ExamAttemptWhereUniqueInput | ExamAttemptWhereUniqueInput[]
    update?: ExamAttemptUpdateWithWhereUniqueWithoutUserInput | ExamAttemptUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ExamAttemptUpdateManyWithWhereWithoutUserInput | ExamAttemptUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ExamAttemptScalarWhereInput | ExamAttemptScalarWhereInput[]
  }

  export type EnrollmentUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<EnrollmentCreateWithoutUserInput, EnrollmentUncheckedCreateWithoutUserInput> | EnrollmentCreateWithoutUserInput[] | EnrollmentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: EnrollmentCreateOrConnectWithoutUserInput | EnrollmentCreateOrConnectWithoutUserInput[]
    upsert?: EnrollmentUpsertWithWhereUniqueWithoutUserInput | EnrollmentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: EnrollmentCreateManyUserInputEnvelope
    set?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[]
    disconnect?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[]
    delete?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[]
    connect?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[]
    update?: EnrollmentUpdateWithWhereUniqueWithoutUserInput | EnrollmentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: EnrollmentUpdateManyWithWhereWithoutUserInput | EnrollmentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: EnrollmentScalarWhereInput | EnrollmentScalarWhereInput[]
  }

  export type OplDocumentUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<OplDocumentCreateWithoutUserInput, OplDocumentUncheckedCreateWithoutUserInput> | OplDocumentCreateWithoutUserInput[] | OplDocumentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: OplDocumentCreateOrConnectWithoutUserInput | OplDocumentCreateOrConnectWithoutUserInput[]
    upsert?: OplDocumentUpsertWithWhereUniqueWithoutUserInput | OplDocumentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: OplDocumentCreateManyUserInputEnvelope
    set?: OplDocumentWhereUniqueInput | OplDocumentWhereUniqueInput[]
    disconnect?: OplDocumentWhereUniqueInput | OplDocumentWhereUniqueInput[]
    delete?: OplDocumentWhereUniqueInput | OplDocumentWhereUniqueInput[]
    connect?: OplDocumentWhereUniqueInput | OplDocumentWhereUniqueInput[]
    update?: OplDocumentUpdateWithWhereUniqueWithoutUserInput | OplDocumentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: OplDocumentUpdateManyWithWhereWithoutUserInput | OplDocumentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: OplDocumentScalarWhereInput | OplDocumentScalarWhereInput[]
  }

  export type FileUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<FileCreateWithoutUserInput, FileUncheckedCreateWithoutUserInput> | FileCreateWithoutUserInput[] | FileUncheckedCreateWithoutUserInput[]
    connectOrCreate?: FileCreateOrConnectWithoutUserInput | FileCreateOrConnectWithoutUserInput[]
    upsert?: FileUpsertWithWhereUniqueWithoutUserInput | FileUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: FileCreateManyUserInputEnvelope
    set?: FileWhereUniqueInput | FileWhereUniqueInput[]
    disconnect?: FileWhereUniqueInput | FileWhereUniqueInput[]
    delete?: FileWhereUniqueInput | FileWhereUniqueInput[]
    connect?: FileWhereUniqueInput | FileWhereUniqueInput[]
    update?: FileUpdateWithWhereUniqueWithoutUserInput | FileUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: FileUpdateManyWithWhereWithoutUserInput | FileUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: FileScalarWhereInput | FileScalarWhereInput[]
  }

  export type CourseUncheckedUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<CourseCreateWithoutCreatorInput, CourseUncheckedCreateWithoutCreatorInput> | CourseCreateWithoutCreatorInput[] | CourseUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: CourseCreateOrConnectWithoutCreatorInput | CourseCreateOrConnectWithoutCreatorInput[]
    upsert?: CourseUpsertWithWhereUniqueWithoutCreatorInput | CourseUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: CourseCreateManyCreatorInputEnvelope
    set?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
    disconnect?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
    delete?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
    connect?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
    update?: CourseUpdateWithWhereUniqueWithoutCreatorInput | CourseUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: CourseUpdateManyWithWhereWithoutCreatorInput | CourseUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: CourseScalarWhereInput | CourseScalarWhereInput[]
  }

  export type CourseUncheckedUpdateManyWithoutDeleterNestedInput = {
    create?: XOR<CourseCreateWithoutDeleterInput, CourseUncheckedCreateWithoutDeleterInput> | CourseCreateWithoutDeleterInput[] | CourseUncheckedCreateWithoutDeleterInput[]
    connectOrCreate?: CourseCreateOrConnectWithoutDeleterInput | CourseCreateOrConnectWithoutDeleterInput[]
    upsert?: CourseUpsertWithWhereUniqueWithoutDeleterInput | CourseUpsertWithWhereUniqueWithoutDeleterInput[]
    createMany?: CourseCreateManyDeleterInputEnvelope
    set?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
    disconnect?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
    delete?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
    connect?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
    update?: CourseUpdateWithWhereUniqueWithoutDeleterInput | CourseUpdateWithWhereUniqueWithoutDeleterInput[]
    updateMany?: CourseUpdateManyWithWhereWithoutDeleterInput | CourseUpdateManyWithWhereWithoutDeleterInput[]
    deleteMany?: CourseScalarWhereInput | CourseScalarWhereInput[]
  }

  export type UserCourseCompletionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserCourseCompletionCreateWithoutUserInput, UserCourseCompletionUncheckedCreateWithoutUserInput> | UserCourseCompletionCreateWithoutUserInput[] | UserCourseCompletionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserCourseCompletionCreateOrConnectWithoutUserInput | UserCourseCompletionCreateOrConnectWithoutUserInput[]
    upsert?: UserCourseCompletionUpsertWithWhereUniqueWithoutUserInput | UserCourseCompletionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserCourseCompletionCreateManyUserInputEnvelope
    set?: UserCourseCompletionWhereUniqueInput | UserCourseCompletionWhereUniqueInput[]
    disconnect?: UserCourseCompletionWhereUniqueInput | UserCourseCompletionWhereUniqueInput[]
    delete?: UserCourseCompletionWhereUniqueInput | UserCourseCompletionWhereUniqueInput[]
    connect?: UserCourseCompletionWhereUniqueInput | UserCourseCompletionWhereUniqueInput[]
    update?: UserCourseCompletionUpdateWithWhereUniqueWithoutUserInput | UserCourseCompletionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserCourseCompletionUpdateManyWithWhereWithoutUserInput | UserCourseCompletionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserCourseCompletionScalarWhereInput | UserCourseCompletionScalarWhereInput[]
  }

  export type ProjectUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ProjectCreateWithoutUserInput, ProjectUncheckedCreateWithoutUserInput> | ProjectCreateWithoutUserInput[] | ProjectUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutUserInput | ProjectCreateOrConnectWithoutUserInput[]
    upsert?: ProjectUpsertWithWhereUniqueWithoutUserInput | ProjectUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ProjectCreateManyUserInputEnvelope
    set?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    disconnect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    delete?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    update?: ProjectUpdateWithWhereUniqueWithoutUserInput | ProjectUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ProjectUpdateManyWithWhereWithoutUserInput | ProjectUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ProjectScalarWhereInput | ProjectScalarWhereInput[]
  }

  export type CompanyBranchCreateNestedManyWithoutCompanyInput = {
    create?: XOR<CompanyBranchCreateWithoutCompanyInput, CompanyBranchUncheckedCreateWithoutCompanyInput> | CompanyBranchCreateWithoutCompanyInput[] | CompanyBranchUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: CompanyBranchCreateOrConnectWithoutCompanyInput | CompanyBranchCreateOrConnectWithoutCompanyInput[]
    createMany?: CompanyBranchCreateManyCompanyInputEnvelope
    connect?: CompanyBranchWhereUniqueInput | CompanyBranchWhereUniqueInput[]
  }

  export type CompanyBranchUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<CompanyBranchCreateWithoutCompanyInput, CompanyBranchUncheckedCreateWithoutCompanyInput> | CompanyBranchCreateWithoutCompanyInput[] | CompanyBranchUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: CompanyBranchCreateOrConnectWithoutCompanyInput | CompanyBranchCreateOrConnectWithoutCompanyInput[]
    createMany?: CompanyBranchCreateManyCompanyInputEnvelope
    connect?: CompanyBranchWhereUniqueInput | CompanyBranchWhereUniqueInput[]
  }

  export type CompanyBranchUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<CompanyBranchCreateWithoutCompanyInput, CompanyBranchUncheckedCreateWithoutCompanyInput> | CompanyBranchCreateWithoutCompanyInput[] | CompanyBranchUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: CompanyBranchCreateOrConnectWithoutCompanyInput | CompanyBranchCreateOrConnectWithoutCompanyInput[]
    upsert?: CompanyBranchUpsertWithWhereUniqueWithoutCompanyInput | CompanyBranchUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: CompanyBranchCreateManyCompanyInputEnvelope
    set?: CompanyBranchWhereUniqueInput | CompanyBranchWhereUniqueInput[]
    disconnect?: CompanyBranchWhereUniqueInput | CompanyBranchWhereUniqueInput[]
    delete?: CompanyBranchWhereUniqueInput | CompanyBranchWhereUniqueInput[]
    connect?: CompanyBranchWhereUniqueInput | CompanyBranchWhereUniqueInput[]
    update?: CompanyBranchUpdateWithWhereUniqueWithoutCompanyInput | CompanyBranchUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: CompanyBranchUpdateManyWithWhereWithoutCompanyInput | CompanyBranchUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: CompanyBranchScalarWhereInput | CompanyBranchScalarWhereInput[]
  }

  export type CompanyBranchUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<CompanyBranchCreateWithoutCompanyInput, CompanyBranchUncheckedCreateWithoutCompanyInput> | CompanyBranchCreateWithoutCompanyInput[] | CompanyBranchUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: CompanyBranchCreateOrConnectWithoutCompanyInput | CompanyBranchCreateOrConnectWithoutCompanyInput[]
    upsert?: CompanyBranchUpsertWithWhereUniqueWithoutCompanyInput | CompanyBranchUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: CompanyBranchCreateManyCompanyInputEnvelope
    set?: CompanyBranchWhereUniqueInput | CompanyBranchWhereUniqueInput[]
    disconnect?: CompanyBranchWhereUniqueInput | CompanyBranchWhereUniqueInput[]
    delete?: CompanyBranchWhereUniqueInput | CompanyBranchWhereUniqueInput[]
    connect?: CompanyBranchWhereUniqueInput | CompanyBranchWhereUniqueInput[]
    update?: CompanyBranchUpdateWithWhereUniqueWithoutCompanyInput | CompanyBranchUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: CompanyBranchUpdateManyWithWhereWithoutCompanyInput | CompanyBranchUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: CompanyBranchScalarWhereInput | CompanyBranchScalarWhereInput[]
  }

  export type CompanyCreateNestedOneWithoutCompanyBranchInput = {
    create?: XOR<CompanyCreateWithoutCompanyBranchInput, CompanyUncheckedCreateWithoutCompanyBranchInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutCompanyBranchInput
    connect?: CompanyWhereUniqueInput
  }

  export type CompanyUpdateOneRequiredWithoutCompanyBranchNestedInput = {
    create?: XOR<CompanyCreateWithoutCompanyBranchInput, CompanyUncheckedCreateWithoutCompanyBranchInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutCompanyBranchInput
    upsert?: CompanyUpsertWithoutCompanyBranchInput
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutCompanyBranchInput, CompanyUpdateWithoutCompanyBranchInput>, CompanyUncheckedUpdateWithoutCompanyBranchInput>
  }

  export type UserCreateNestedManyWithoutDepartmentInput = {
    create?: XOR<UserCreateWithoutDepartmentInput, UserUncheckedCreateWithoutDepartmentInput> | UserCreateWithoutDepartmentInput[] | UserUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: UserCreateOrConnectWithoutDepartmentInput | UserCreateOrConnectWithoutDepartmentInput[]
    createMany?: UserCreateManyDepartmentInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type CourseCreateNestedManyWithoutDepartmentInput = {
    create?: XOR<CourseCreateWithoutDepartmentInput, CourseUncheckedCreateWithoutDepartmentInput> | CourseCreateWithoutDepartmentInput[] | CourseUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: CourseCreateOrConnectWithoutDepartmentInput | CourseCreateOrConnectWithoutDepartmentInput[]
    createMany?: CourseCreateManyDepartmentInputEnvelope
    connect?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedManyWithoutDepartmentInput = {
    create?: XOR<UserCreateWithoutDepartmentInput, UserUncheckedCreateWithoutDepartmentInput> | UserCreateWithoutDepartmentInput[] | UserUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: UserCreateOrConnectWithoutDepartmentInput | UserCreateOrConnectWithoutDepartmentInput[]
    createMany?: UserCreateManyDepartmentInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type CourseUncheckedCreateNestedManyWithoutDepartmentInput = {
    create?: XOR<CourseCreateWithoutDepartmentInput, CourseUncheckedCreateWithoutDepartmentInput> | CourseCreateWithoutDepartmentInput[] | CourseUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: CourseCreateOrConnectWithoutDepartmentInput | CourseCreateOrConnectWithoutDepartmentInput[]
    createMany?: CourseCreateManyDepartmentInputEnvelope
    connect?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
  }

  export type UserUpdateManyWithoutDepartmentNestedInput = {
    create?: XOR<UserCreateWithoutDepartmentInput, UserUncheckedCreateWithoutDepartmentInput> | UserCreateWithoutDepartmentInput[] | UserUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: UserCreateOrConnectWithoutDepartmentInput | UserCreateOrConnectWithoutDepartmentInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutDepartmentInput | UserUpsertWithWhereUniqueWithoutDepartmentInput[]
    createMany?: UserCreateManyDepartmentInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutDepartmentInput | UserUpdateWithWhereUniqueWithoutDepartmentInput[]
    updateMany?: UserUpdateManyWithWhereWithoutDepartmentInput | UserUpdateManyWithWhereWithoutDepartmentInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type CourseUpdateManyWithoutDepartmentNestedInput = {
    create?: XOR<CourseCreateWithoutDepartmentInput, CourseUncheckedCreateWithoutDepartmentInput> | CourseCreateWithoutDepartmentInput[] | CourseUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: CourseCreateOrConnectWithoutDepartmentInput | CourseCreateOrConnectWithoutDepartmentInput[]
    upsert?: CourseUpsertWithWhereUniqueWithoutDepartmentInput | CourseUpsertWithWhereUniqueWithoutDepartmentInput[]
    createMany?: CourseCreateManyDepartmentInputEnvelope
    set?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
    disconnect?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
    delete?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
    connect?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
    update?: CourseUpdateWithWhereUniqueWithoutDepartmentInput | CourseUpdateWithWhereUniqueWithoutDepartmentInput[]
    updateMany?: CourseUpdateManyWithWhereWithoutDepartmentInput | CourseUpdateManyWithWhereWithoutDepartmentInput[]
    deleteMany?: CourseScalarWhereInput | CourseScalarWhereInput[]
  }

  export type UserUncheckedUpdateManyWithoutDepartmentNestedInput = {
    create?: XOR<UserCreateWithoutDepartmentInput, UserUncheckedCreateWithoutDepartmentInput> | UserCreateWithoutDepartmentInput[] | UserUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: UserCreateOrConnectWithoutDepartmentInput | UserCreateOrConnectWithoutDepartmentInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutDepartmentInput | UserUpsertWithWhereUniqueWithoutDepartmentInput[]
    createMany?: UserCreateManyDepartmentInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutDepartmentInput | UserUpdateWithWhereUniqueWithoutDepartmentInput[]
    updateMany?: UserUpdateManyWithWhereWithoutDepartmentInput | UserUpdateManyWithWhereWithoutDepartmentInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type CourseUncheckedUpdateManyWithoutDepartmentNestedInput = {
    create?: XOR<CourseCreateWithoutDepartmentInput, CourseUncheckedCreateWithoutDepartmentInput> | CourseCreateWithoutDepartmentInput[] | CourseUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: CourseCreateOrConnectWithoutDepartmentInput | CourseCreateOrConnectWithoutDepartmentInput[]
    upsert?: CourseUpsertWithWhereUniqueWithoutDepartmentInput | CourseUpsertWithWhereUniqueWithoutDepartmentInput[]
    createMany?: CourseCreateManyDepartmentInputEnvelope
    set?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
    disconnect?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
    delete?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
    connect?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
    update?: CourseUpdateWithWhereUniqueWithoutDepartmentInput | CourseUpdateWithWhereUniqueWithoutDepartmentInput[]
    updateMany?: CourseUpdateManyWithWhereWithoutDepartmentInput | CourseUpdateManyWithWhereWithoutDepartmentInput[]
    deleteMany?: CourseScalarWhereInput | CourseScalarWhereInput[]
  }

  export type DepartmentCreateNestedOneWithoutCourseInput = {
    create?: XOR<DepartmentCreateWithoutCourseInput, DepartmentUncheckedCreateWithoutCourseInput>
    connectOrCreate?: DepartmentCreateOrConnectWithoutCourseInput
    connect?: DepartmentWhereUniqueInput
  }

  export type ProcessCreateNestedOneWithoutCoursesInput = {
    create?: XOR<ProcessCreateWithoutCoursesInput, ProcessUncheckedCreateWithoutCoursesInput>
    connectOrCreate?: ProcessCreateOrConnectWithoutCoursesInput
    connect?: ProcessWhereUniqueInput
  }

  export type EnrollmentCreateNestedManyWithoutCourseInput = {
    create?: XOR<EnrollmentCreateWithoutCourseInput, EnrollmentUncheckedCreateWithoutCourseInput> | EnrollmentCreateWithoutCourseInput[] | EnrollmentUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: EnrollmentCreateOrConnectWithoutCourseInput | EnrollmentCreateOrConnectWithoutCourseInput[]
    createMany?: EnrollmentCreateManyCourseInputEnvelope
    connect?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[]
  }

  export type FileCreateNestedManyWithoutCourseInput = {
    create?: XOR<FileCreateWithoutCourseInput, FileUncheckedCreateWithoutCourseInput> | FileCreateWithoutCourseInput[] | FileUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: FileCreateOrConnectWithoutCourseInput | FileCreateOrConnectWithoutCourseInput[]
    createMany?: FileCreateManyCourseInputEnvelope
    connect?: FileWhereUniqueInput | FileWhereUniqueInput[]
  }

  export type ExamCreateNestedManyWithoutCourseInput = {
    create?: XOR<ExamCreateWithoutCourseInput, ExamUncheckedCreateWithoutCourseInput> | ExamCreateWithoutCourseInput[] | ExamUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: ExamCreateOrConnectWithoutCourseInput | ExamCreateOrConnectWithoutCourseInput[]
    createMany?: ExamCreateManyCourseInputEnvelope
    connect?: ExamWhereUniqueInput | ExamWhereUniqueInput[]
  }

  export type UserCourseCompletionCreateNestedManyWithoutCourseInput = {
    create?: XOR<UserCourseCompletionCreateWithoutCourseInput, UserCourseCompletionUncheckedCreateWithoutCourseInput> | UserCourseCompletionCreateWithoutCourseInput[] | UserCourseCompletionUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: UserCourseCompletionCreateOrConnectWithoutCourseInput | UserCourseCompletionCreateOrConnectWithoutCourseInput[]
    createMany?: UserCourseCompletionCreateManyCourseInputEnvelope
    connect?: UserCourseCompletionWhereUniqueInput | UserCourseCompletionWhereUniqueInput[]
  }

  export type UserCreateNestedOneWithoutCreatedCoursesInput = {
    create?: XOR<UserCreateWithoutCreatedCoursesInput, UserUncheckedCreateWithoutCreatedCoursesInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedCoursesInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutDeletedCoursesInput = {
    create?: XOR<UserCreateWithoutDeletedCoursesInput, UserUncheckedCreateWithoutDeletedCoursesInput>
    connectOrCreate?: UserCreateOrConnectWithoutDeletedCoursesInput
    connect?: UserWhereUniqueInput
  }

  export type EnrollmentUncheckedCreateNestedManyWithoutCourseInput = {
    create?: XOR<EnrollmentCreateWithoutCourseInput, EnrollmentUncheckedCreateWithoutCourseInput> | EnrollmentCreateWithoutCourseInput[] | EnrollmentUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: EnrollmentCreateOrConnectWithoutCourseInput | EnrollmentCreateOrConnectWithoutCourseInput[]
    createMany?: EnrollmentCreateManyCourseInputEnvelope
    connect?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[]
  }

  export type FileUncheckedCreateNestedManyWithoutCourseInput = {
    create?: XOR<FileCreateWithoutCourseInput, FileUncheckedCreateWithoutCourseInput> | FileCreateWithoutCourseInput[] | FileUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: FileCreateOrConnectWithoutCourseInput | FileCreateOrConnectWithoutCourseInput[]
    createMany?: FileCreateManyCourseInputEnvelope
    connect?: FileWhereUniqueInput | FileWhereUniqueInput[]
  }

  export type ExamUncheckedCreateNestedManyWithoutCourseInput = {
    create?: XOR<ExamCreateWithoutCourseInput, ExamUncheckedCreateWithoutCourseInput> | ExamCreateWithoutCourseInput[] | ExamUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: ExamCreateOrConnectWithoutCourseInput | ExamCreateOrConnectWithoutCourseInput[]
    createMany?: ExamCreateManyCourseInputEnvelope
    connect?: ExamWhereUniqueInput | ExamWhereUniqueInput[]
  }

  export type UserCourseCompletionUncheckedCreateNestedManyWithoutCourseInput = {
    create?: XOR<UserCourseCompletionCreateWithoutCourseInput, UserCourseCompletionUncheckedCreateWithoutCourseInput> | UserCourseCompletionCreateWithoutCourseInput[] | UserCourseCompletionUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: UserCourseCompletionCreateOrConnectWithoutCourseInput | UserCourseCompletionCreateOrConnectWithoutCourseInput[]
    createMany?: UserCourseCompletionCreateManyCourseInputEnvelope
    connect?: UserCourseCompletionWhereUniqueInput | UserCourseCompletionWhereUniqueInput[]
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type DepartmentUpdateOneWithoutCourseNestedInput = {
    create?: XOR<DepartmentCreateWithoutCourseInput, DepartmentUncheckedCreateWithoutCourseInput>
    connectOrCreate?: DepartmentCreateOrConnectWithoutCourseInput
    upsert?: DepartmentUpsertWithoutCourseInput
    disconnect?: DepartmentWhereInput | boolean
    delete?: DepartmentWhereInput | boolean
    connect?: DepartmentWhereUniqueInput
    update?: XOR<XOR<DepartmentUpdateToOneWithWhereWithoutCourseInput, DepartmentUpdateWithoutCourseInput>, DepartmentUncheckedUpdateWithoutCourseInput>
  }

  export type ProcessUpdateOneWithoutCoursesNestedInput = {
    create?: XOR<ProcessCreateWithoutCoursesInput, ProcessUncheckedCreateWithoutCoursesInput>
    connectOrCreate?: ProcessCreateOrConnectWithoutCoursesInput
    upsert?: ProcessUpsertWithoutCoursesInput
    disconnect?: ProcessWhereInput | boolean
    delete?: ProcessWhereInput | boolean
    connect?: ProcessWhereUniqueInput
    update?: XOR<XOR<ProcessUpdateToOneWithWhereWithoutCoursesInput, ProcessUpdateWithoutCoursesInput>, ProcessUncheckedUpdateWithoutCoursesInput>
  }

  export type EnrollmentUpdateManyWithoutCourseNestedInput = {
    create?: XOR<EnrollmentCreateWithoutCourseInput, EnrollmentUncheckedCreateWithoutCourseInput> | EnrollmentCreateWithoutCourseInput[] | EnrollmentUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: EnrollmentCreateOrConnectWithoutCourseInput | EnrollmentCreateOrConnectWithoutCourseInput[]
    upsert?: EnrollmentUpsertWithWhereUniqueWithoutCourseInput | EnrollmentUpsertWithWhereUniqueWithoutCourseInput[]
    createMany?: EnrollmentCreateManyCourseInputEnvelope
    set?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[]
    disconnect?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[]
    delete?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[]
    connect?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[]
    update?: EnrollmentUpdateWithWhereUniqueWithoutCourseInput | EnrollmentUpdateWithWhereUniqueWithoutCourseInput[]
    updateMany?: EnrollmentUpdateManyWithWhereWithoutCourseInput | EnrollmentUpdateManyWithWhereWithoutCourseInput[]
    deleteMany?: EnrollmentScalarWhereInput | EnrollmentScalarWhereInput[]
  }

  export type FileUpdateManyWithoutCourseNestedInput = {
    create?: XOR<FileCreateWithoutCourseInput, FileUncheckedCreateWithoutCourseInput> | FileCreateWithoutCourseInput[] | FileUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: FileCreateOrConnectWithoutCourseInput | FileCreateOrConnectWithoutCourseInput[]
    upsert?: FileUpsertWithWhereUniqueWithoutCourseInput | FileUpsertWithWhereUniqueWithoutCourseInput[]
    createMany?: FileCreateManyCourseInputEnvelope
    set?: FileWhereUniqueInput | FileWhereUniqueInput[]
    disconnect?: FileWhereUniqueInput | FileWhereUniqueInput[]
    delete?: FileWhereUniqueInput | FileWhereUniqueInput[]
    connect?: FileWhereUniqueInput | FileWhereUniqueInput[]
    update?: FileUpdateWithWhereUniqueWithoutCourseInput | FileUpdateWithWhereUniqueWithoutCourseInput[]
    updateMany?: FileUpdateManyWithWhereWithoutCourseInput | FileUpdateManyWithWhereWithoutCourseInput[]
    deleteMany?: FileScalarWhereInput | FileScalarWhereInput[]
  }

  export type ExamUpdateManyWithoutCourseNestedInput = {
    create?: XOR<ExamCreateWithoutCourseInput, ExamUncheckedCreateWithoutCourseInput> | ExamCreateWithoutCourseInput[] | ExamUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: ExamCreateOrConnectWithoutCourseInput | ExamCreateOrConnectWithoutCourseInput[]
    upsert?: ExamUpsertWithWhereUniqueWithoutCourseInput | ExamUpsertWithWhereUniqueWithoutCourseInput[]
    createMany?: ExamCreateManyCourseInputEnvelope
    set?: ExamWhereUniqueInput | ExamWhereUniqueInput[]
    disconnect?: ExamWhereUniqueInput | ExamWhereUniqueInput[]
    delete?: ExamWhereUniqueInput | ExamWhereUniqueInput[]
    connect?: ExamWhereUniqueInput | ExamWhereUniqueInput[]
    update?: ExamUpdateWithWhereUniqueWithoutCourseInput | ExamUpdateWithWhereUniqueWithoutCourseInput[]
    updateMany?: ExamUpdateManyWithWhereWithoutCourseInput | ExamUpdateManyWithWhereWithoutCourseInput[]
    deleteMany?: ExamScalarWhereInput | ExamScalarWhereInput[]
  }

  export type UserCourseCompletionUpdateManyWithoutCourseNestedInput = {
    create?: XOR<UserCourseCompletionCreateWithoutCourseInput, UserCourseCompletionUncheckedCreateWithoutCourseInput> | UserCourseCompletionCreateWithoutCourseInput[] | UserCourseCompletionUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: UserCourseCompletionCreateOrConnectWithoutCourseInput | UserCourseCompletionCreateOrConnectWithoutCourseInput[]
    upsert?: UserCourseCompletionUpsertWithWhereUniqueWithoutCourseInput | UserCourseCompletionUpsertWithWhereUniqueWithoutCourseInput[]
    createMany?: UserCourseCompletionCreateManyCourseInputEnvelope
    set?: UserCourseCompletionWhereUniqueInput | UserCourseCompletionWhereUniqueInput[]
    disconnect?: UserCourseCompletionWhereUniqueInput | UserCourseCompletionWhereUniqueInput[]
    delete?: UserCourseCompletionWhereUniqueInput | UserCourseCompletionWhereUniqueInput[]
    connect?: UserCourseCompletionWhereUniqueInput | UserCourseCompletionWhereUniqueInput[]
    update?: UserCourseCompletionUpdateWithWhereUniqueWithoutCourseInput | UserCourseCompletionUpdateWithWhereUniqueWithoutCourseInput[]
    updateMany?: UserCourseCompletionUpdateManyWithWhereWithoutCourseInput | UserCourseCompletionUpdateManyWithWhereWithoutCourseInput[]
    deleteMany?: UserCourseCompletionScalarWhereInput | UserCourseCompletionScalarWhereInput[]
  }

  export type UserUpdateOneRequiredWithoutCreatedCoursesNestedInput = {
    create?: XOR<UserCreateWithoutCreatedCoursesInput, UserUncheckedCreateWithoutCreatedCoursesInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedCoursesInput
    upsert?: UserUpsertWithoutCreatedCoursesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCreatedCoursesInput, UserUpdateWithoutCreatedCoursesInput>, UserUncheckedUpdateWithoutCreatedCoursesInput>
  }

  export type UserUpdateOneWithoutDeletedCoursesNestedInput = {
    create?: XOR<UserCreateWithoutDeletedCoursesInput, UserUncheckedCreateWithoutDeletedCoursesInput>
    connectOrCreate?: UserCreateOrConnectWithoutDeletedCoursesInput
    upsert?: UserUpsertWithoutDeletedCoursesInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutDeletedCoursesInput, UserUpdateWithoutDeletedCoursesInput>, UserUncheckedUpdateWithoutDeletedCoursesInput>
  }

  export type EnrollmentUncheckedUpdateManyWithoutCourseNestedInput = {
    create?: XOR<EnrollmentCreateWithoutCourseInput, EnrollmentUncheckedCreateWithoutCourseInput> | EnrollmentCreateWithoutCourseInput[] | EnrollmentUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: EnrollmentCreateOrConnectWithoutCourseInput | EnrollmentCreateOrConnectWithoutCourseInput[]
    upsert?: EnrollmentUpsertWithWhereUniqueWithoutCourseInput | EnrollmentUpsertWithWhereUniqueWithoutCourseInput[]
    createMany?: EnrollmentCreateManyCourseInputEnvelope
    set?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[]
    disconnect?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[]
    delete?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[]
    connect?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[]
    update?: EnrollmentUpdateWithWhereUniqueWithoutCourseInput | EnrollmentUpdateWithWhereUniqueWithoutCourseInput[]
    updateMany?: EnrollmentUpdateManyWithWhereWithoutCourseInput | EnrollmentUpdateManyWithWhereWithoutCourseInput[]
    deleteMany?: EnrollmentScalarWhereInput | EnrollmentScalarWhereInput[]
  }

  export type FileUncheckedUpdateManyWithoutCourseNestedInput = {
    create?: XOR<FileCreateWithoutCourseInput, FileUncheckedCreateWithoutCourseInput> | FileCreateWithoutCourseInput[] | FileUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: FileCreateOrConnectWithoutCourseInput | FileCreateOrConnectWithoutCourseInput[]
    upsert?: FileUpsertWithWhereUniqueWithoutCourseInput | FileUpsertWithWhereUniqueWithoutCourseInput[]
    createMany?: FileCreateManyCourseInputEnvelope
    set?: FileWhereUniqueInput | FileWhereUniqueInput[]
    disconnect?: FileWhereUniqueInput | FileWhereUniqueInput[]
    delete?: FileWhereUniqueInput | FileWhereUniqueInput[]
    connect?: FileWhereUniqueInput | FileWhereUniqueInput[]
    update?: FileUpdateWithWhereUniqueWithoutCourseInput | FileUpdateWithWhereUniqueWithoutCourseInput[]
    updateMany?: FileUpdateManyWithWhereWithoutCourseInput | FileUpdateManyWithWhereWithoutCourseInput[]
    deleteMany?: FileScalarWhereInput | FileScalarWhereInput[]
  }

  export type ExamUncheckedUpdateManyWithoutCourseNestedInput = {
    create?: XOR<ExamCreateWithoutCourseInput, ExamUncheckedCreateWithoutCourseInput> | ExamCreateWithoutCourseInput[] | ExamUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: ExamCreateOrConnectWithoutCourseInput | ExamCreateOrConnectWithoutCourseInput[]
    upsert?: ExamUpsertWithWhereUniqueWithoutCourseInput | ExamUpsertWithWhereUniqueWithoutCourseInput[]
    createMany?: ExamCreateManyCourseInputEnvelope
    set?: ExamWhereUniqueInput | ExamWhereUniqueInput[]
    disconnect?: ExamWhereUniqueInput | ExamWhereUniqueInput[]
    delete?: ExamWhereUniqueInput | ExamWhereUniqueInput[]
    connect?: ExamWhereUniqueInput | ExamWhereUniqueInput[]
    update?: ExamUpdateWithWhereUniqueWithoutCourseInput | ExamUpdateWithWhereUniqueWithoutCourseInput[]
    updateMany?: ExamUpdateManyWithWhereWithoutCourseInput | ExamUpdateManyWithWhereWithoutCourseInput[]
    deleteMany?: ExamScalarWhereInput | ExamScalarWhereInput[]
  }

  export type UserCourseCompletionUncheckedUpdateManyWithoutCourseNestedInput = {
    create?: XOR<UserCourseCompletionCreateWithoutCourseInput, UserCourseCompletionUncheckedCreateWithoutCourseInput> | UserCourseCompletionCreateWithoutCourseInput[] | UserCourseCompletionUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: UserCourseCompletionCreateOrConnectWithoutCourseInput | UserCourseCompletionCreateOrConnectWithoutCourseInput[]
    upsert?: UserCourseCompletionUpsertWithWhereUniqueWithoutCourseInput | UserCourseCompletionUpsertWithWhereUniqueWithoutCourseInput[]
    createMany?: UserCourseCompletionCreateManyCourseInputEnvelope
    set?: UserCourseCompletionWhereUniqueInput | UserCourseCompletionWhereUniqueInput[]
    disconnect?: UserCourseCompletionWhereUniqueInput | UserCourseCompletionWhereUniqueInput[]
    delete?: UserCourseCompletionWhereUniqueInput | UserCourseCompletionWhereUniqueInput[]
    connect?: UserCourseCompletionWhereUniqueInput | UserCourseCompletionWhereUniqueInput[]
    update?: UserCourseCompletionUpdateWithWhereUniqueWithoutCourseInput | UserCourseCompletionUpdateWithWhereUniqueWithoutCourseInput[]
    updateMany?: UserCourseCompletionUpdateManyWithWhereWithoutCourseInput | UserCourseCompletionUpdateManyWithWhereWithoutCourseInput[]
    deleteMany?: UserCourseCompletionScalarWhereInput | UserCourseCompletionScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutCourseCompletionsInput = {
    create?: XOR<UserCreateWithoutCourseCompletionsInput, UserUncheckedCreateWithoutCourseCompletionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCourseCompletionsInput
    connect?: UserWhereUniqueInput
  }

  export type CourseCreateNestedOneWithoutCompletionsInput = {
    create?: XOR<CourseCreateWithoutCompletionsInput, CourseUncheckedCreateWithoutCompletionsInput>
    connectOrCreate?: CourseCreateOrConnectWithoutCompletionsInput
    connect?: CourseWhereUniqueInput
  }

  export type ExamCreateNestedOneWithoutCompletionsInput = {
    create?: XOR<ExamCreateWithoutCompletionsInput, ExamUncheckedCreateWithoutCompletionsInput>
    connectOrCreate?: ExamCreateOrConnectWithoutCompletionsInput
    connect?: ExamWhereUniqueInput
  }

  export type ProcessCreateNestedOneWithoutCompletionsInput = {
    create?: XOR<ProcessCreateWithoutCompletionsInput, ProcessUncheckedCreateWithoutCompletionsInput>
    connectOrCreate?: ProcessCreateOrConnectWithoutCompletionsInput
    connect?: ProcessWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutCourseCompletionsNestedInput = {
    create?: XOR<UserCreateWithoutCourseCompletionsInput, UserUncheckedCreateWithoutCourseCompletionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCourseCompletionsInput
    upsert?: UserUpsertWithoutCourseCompletionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCourseCompletionsInput, UserUpdateWithoutCourseCompletionsInput>, UserUncheckedUpdateWithoutCourseCompletionsInput>
  }

  export type CourseUpdateOneRequiredWithoutCompletionsNestedInput = {
    create?: XOR<CourseCreateWithoutCompletionsInput, CourseUncheckedCreateWithoutCompletionsInput>
    connectOrCreate?: CourseCreateOrConnectWithoutCompletionsInput
    upsert?: CourseUpsertWithoutCompletionsInput
    connect?: CourseWhereUniqueInput
    update?: XOR<XOR<CourseUpdateToOneWithWhereWithoutCompletionsInput, CourseUpdateWithoutCompletionsInput>, CourseUncheckedUpdateWithoutCompletionsInput>
  }

  export type ExamUpdateOneRequiredWithoutCompletionsNestedInput = {
    create?: XOR<ExamCreateWithoutCompletionsInput, ExamUncheckedCreateWithoutCompletionsInput>
    connectOrCreate?: ExamCreateOrConnectWithoutCompletionsInput
    upsert?: ExamUpsertWithoutCompletionsInput
    connect?: ExamWhereUniqueInput
    update?: XOR<XOR<ExamUpdateToOneWithWhereWithoutCompletionsInput, ExamUpdateWithoutCompletionsInput>, ExamUncheckedUpdateWithoutCompletionsInput>
  }

  export type ProcessUpdateOneRequiredWithoutCompletionsNestedInput = {
    create?: XOR<ProcessCreateWithoutCompletionsInput, ProcessUncheckedCreateWithoutCompletionsInput>
    connectOrCreate?: ProcessCreateOrConnectWithoutCompletionsInput
    upsert?: ProcessUpsertWithoutCompletionsInput
    connect?: ProcessWhereUniqueInput
    update?: XOR<XOR<ProcessUpdateToOneWithWhereWithoutCompletionsInput, ProcessUpdateWithoutCompletionsInput>, ProcessUncheckedUpdateWithoutCompletionsInput>
  }

  export type UserCreateNestedOneWithoutEnrollmentsInput = {
    create?: XOR<UserCreateWithoutEnrollmentsInput, UserUncheckedCreateWithoutEnrollmentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutEnrollmentsInput
    connect?: UserWhereUniqueInput
  }

  export type CourseCreateNestedOneWithoutEnrollmentsInput = {
    create?: XOR<CourseCreateWithoutEnrollmentsInput, CourseUncheckedCreateWithoutEnrollmentsInput>
    connectOrCreate?: CourseCreateOrConnectWithoutEnrollmentsInput
    connect?: CourseWhereUniqueInput
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserUpdateOneRequiredWithoutEnrollmentsNestedInput = {
    create?: XOR<UserCreateWithoutEnrollmentsInput, UserUncheckedCreateWithoutEnrollmentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutEnrollmentsInput
    upsert?: UserUpsertWithoutEnrollmentsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutEnrollmentsInput, UserUpdateWithoutEnrollmentsInput>, UserUncheckedUpdateWithoutEnrollmentsInput>
  }

  export type CourseUpdateOneRequiredWithoutEnrollmentsNestedInput = {
    create?: XOR<CourseCreateWithoutEnrollmentsInput, CourseUncheckedCreateWithoutEnrollmentsInput>
    connectOrCreate?: CourseCreateOrConnectWithoutEnrollmentsInput
    upsert?: CourseUpsertWithoutEnrollmentsInput
    connect?: CourseWhereUniqueInput
    update?: XOR<XOR<CourseUpdateToOneWithWhereWithoutEnrollmentsInput, CourseUpdateWithoutEnrollmentsInput>, CourseUncheckedUpdateWithoutEnrollmentsInput>
  }

  export type QuestionCreateNestedManyWithoutExamInput = {
    create?: XOR<QuestionCreateWithoutExamInput, QuestionUncheckedCreateWithoutExamInput> | QuestionCreateWithoutExamInput[] | QuestionUncheckedCreateWithoutExamInput[]
    connectOrCreate?: QuestionCreateOrConnectWithoutExamInput | QuestionCreateOrConnectWithoutExamInput[]
    createMany?: QuestionCreateManyExamInputEnvelope
    connect?: QuestionWhereUniqueInput | QuestionWhereUniqueInput[]
  }

  export type ExamAttemptCreateNestedManyWithoutExamInput = {
    create?: XOR<ExamAttemptCreateWithoutExamInput, ExamAttemptUncheckedCreateWithoutExamInput> | ExamAttemptCreateWithoutExamInput[] | ExamAttemptUncheckedCreateWithoutExamInput[]
    connectOrCreate?: ExamAttemptCreateOrConnectWithoutExamInput | ExamAttemptCreateOrConnectWithoutExamInput[]
    createMany?: ExamAttemptCreateManyExamInputEnvelope
    connect?: ExamAttemptWhereUniqueInput | ExamAttemptWhereUniqueInput[]
  }

  export type UserCourseCompletionCreateNestedManyWithoutExamInput = {
    create?: XOR<UserCourseCompletionCreateWithoutExamInput, UserCourseCompletionUncheckedCreateWithoutExamInput> | UserCourseCompletionCreateWithoutExamInput[] | UserCourseCompletionUncheckedCreateWithoutExamInput[]
    connectOrCreate?: UserCourseCompletionCreateOrConnectWithoutExamInput | UserCourseCompletionCreateOrConnectWithoutExamInput[]
    createMany?: UserCourseCompletionCreateManyExamInputEnvelope
    connect?: UserCourseCompletionWhereUniqueInput | UserCourseCompletionWhereUniqueInput[]
  }

  export type CourseCreateNestedOneWithoutExamsInput = {
    create?: XOR<CourseCreateWithoutExamsInput, CourseUncheckedCreateWithoutExamsInput>
    connectOrCreate?: CourseCreateOrConnectWithoutExamsInput
    connect?: CourseWhereUniqueInput
  }

  export type QuestionUncheckedCreateNestedManyWithoutExamInput = {
    create?: XOR<QuestionCreateWithoutExamInput, QuestionUncheckedCreateWithoutExamInput> | QuestionCreateWithoutExamInput[] | QuestionUncheckedCreateWithoutExamInput[]
    connectOrCreate?: QuestionCreateOrConnectWithoutExamInput | QuestionCreateOrConnectWithoutExamInput[]
    createMany?: QuestionCreateManyExamInputEnvelope
    connect?: QuestionWhereUniqueInput | QuestionWhereUniqueInput[]
  }

  export type ExamAttemptUncheckedCreateNestedManyWithoutExamInput = {
    create?: XOR<ExamAttemptCreateWithoutExamInput, ExamAttemptUncheckedCreateWithoutExamInput> | ExamAttemptCreateWithoutExamInput[] | ExamAttemptUncheckedCreateWithoutExamInput[]
    connectOrCreate?: ExamAttemptCreateOrConnectWithoutExamInput | ExamAttemptCreateOrConnectWithoutExamInput[]
    createMany?: ExamAttemptCreateManyExamInputEnvelope
    connect?: ExamAttemptWhereUniqueInput | ExamAttemptWhereUniqueInput[]
  }

  export type UserCourseCompletionUncheckedCreateNestedManyWithoutExamInput = {
    create?: XOR<UserCourseCompletionCreateWithoutExamInput, UserCourseCompletionUncheckedCreateWithoutExamInput> | UserCourseCompletionCreateWithoutExamInput[] | UserCourseCompletionUncheckedCreateWithoutExamInput[]
    connectOrCreate?: UserCourseCompletionCreateOrConnectWithoutExamInput | UserCourseCompletionCreateOrConnectWithoutExamInput[]
    createMany?: UserCourseCompletionCreateManyExamInputEnvelope
    connect?: UserCourseCompletionWhereUniqueInput | UserCourseCompletionWhereUniqueInput[]
  }

  export type QuestionUpdateManyWithoutExamNestedInput = {
    create?: XOR<QuestionCreateWithoutExamInput, QuestionUncheckedCreateWithoutExamInput> | QuestionCreateWithoutExamInput[] | QuestionUncheckedCreateWithoutExamInput[]
    connectOrCreate?: QuestionCreateOrConnectWithoutExamInput | QuestionCreateOrConnectWithoutExamInput[]
    upsert?: QuestionUpsertWithWhereUniqueWithoutExamInput | QuestionUpsertWithWhereUniqueWithoutExamInput[]
    createMany?: QuestionCreateManyExamInputEnvelope
    set?: QuestionWhereUniqueInput | QuestionWhereUniqueInput[]
    disconnect?: QuestionWhereUniqueInput | QuestionWhereUniqueInput[]
    delete?: QuestionWhereUniqueInput | QuestionWhereUniqueInput[]
    connect?: QuestionWhereUniqueInput | QuestionWhereUniqueInput[]
    update?: QuestionUpdateWithWhereUniqueWithoutExamInput | QuestionUpdateWithWhereUniqueWithoutExamInput[]
    updateMany?: QuestionUpdateManyWithWhereWithoutExamInput | QuestionUpdateManyWithWhereWithoutExamInput[]
    deleteMany?: QuestionScalarWhereInput | QuestionScalarWhereInput[]
  }

  export type ExamAttemptUpdateManyWithoutExamNestedInput = {
    create?: XOR<ExamAttemptCreateWithoutExamInput, ExamAttemptUncheckedCreateWithoutExamInput> | ExamAttemptCreateWithoutExamInput[] | ExamAttemptUncheckedCreateWithoutExamInput[]
    connectOrCreate?: ExamAttemptCreateOrConnectWithoutExamInput | ExamAttemptCreateOrConnectWithoutExamInput[]
    upsert?: ExamAttemptUpsertWithWhereUniqueWithoutExamInput | ExamAttemptUpsertWithWhereUniqueWithoutExamInput[]
    createMany?: ExamAttemptCreateManyExamInputEnvelope
    set?: ExamAttemptWhereUniqueInput | ExamAttemptWhereUniqueInput[]
    disconnect?: ExamAttemptWhereUniqueInput | ExamAttemptWhereUniqueInput[]
    delete?: ExamAttemptWhereUniqueInput | ExamAttemptWhereUniqueInput[]
    connect?: ExamAttemptWhereUniqueInput | ExamAttemptWhereUniqueInput[]
    update?: ExamAttemptUpdateWithWhereUniqueWithoutExamInput | ExamAttemptUpdateWithWhereUniqueWithoutExamInput[]
    updateMany?: ExamAttemptUpdateManyWithWhereWithoutExamInput | ExamAttemptUpdateManyWithWhereWithoutExamInput[]
    deleteMany?: ExamAttemptScalarWhereInput | ExamAttemptScalarWhereInput[]
  }

  export type UserCourseCompletionUpdateManyWithoutExamNestedInput = {
    create?: XOR<UserCourseCompletionCreateWithoutExamInput, UserCourseCompletionUncheckedCreateWithoutExamInput> | UserCourseCompletionCreateWithoutExamInput[] | UserCourseCompletionUncheckedCreateWithoutExamInput[]
    connectOrCreate?: UserCourseCompletionCreateOrConnectWithoutExamInput | UserCourseCompletionCreateOrConnectWithoutExamInput[]
    upsert?: UserCourseCompletionUpsertWithWhereUniqueWithoutExamInput | UserCourseCompletionUpsertWithWhereUniqueWithoutExamInput[]
    createMany?: UserCourseCompletionCreateManyExamInputEnvelope
    set?: UserCourseCompletionWhereUniqueInput | UserCourseCompletionWhereUniqueInput[]
    disconnect?: UserCourseCompletionWhereUniqueInput | UserCourseCompletionWhereUniqueInput[]
    delete?: UserCourseCompletionWhereUniqueInput | UserCourseCompletionWhereUniqueInput[]
    connect?: UserCourseCompletionWhereUniqueInput | UserCourseCompletionWhereUniqueInput[]
    update?: UserCourseCompletionUpdateWithWhereUniqueWithoutExamInput | UserCourseCompletionUpdateWithWhereUniqueWithoutExamInput[]
    updateMany?: UserCourseCompletionUpdateManyWithWhereWithoutExamInput | UserCourseCompletionUpdateManyWithWhereWithoutExamInput[]
    deleteMany?: UserCourseCompletionScalarWhereInput | UserCourseCompletionScalarWhereInput[]
  }

  export type CourseUpdateOneWithoutExamsNestedInput = {
    create?: XOR<CourseCreateWithoutExamsInput, CourseUncheckedCreateWithoutExamsInput>
    connectOrCreate?: CourseCreateOrConnectWithoutExamsInput
    upsert?: CourseUpsertWithoutExamsInput
    disconnect?: CourseWhereInput | boolean
    delete?: CourseWhereInput | boolean
    connect?: CourseWhereUniqueInput
    update?: XOR<XOR<CourseUpdateToOneWithWhereWithoutExamsInput, CourseUpdateWithoutExamsInput>, CourseUncheckedUpdateWithoutExamsInput>
  }

  export type QuestionUncheckedUpdateManyWithoutExamNestedInput = {
    create?: XOR<QuestionCreateWithoutExamInput, QuestionUncheckedCreateWithoutExamInput> | QuestionCreateWithoutExamInput[] | QuestionUncheckedCreateWithoutExamInput[]
    connectOrCreate?: QuestionCreateOrConnectWithoutExamInput | QuestionCreateOrConnectWithoutExamInput[]
    upsert?: QuestionUpsertWithWhereUniqueWithoutExamInput | QuestionUpsertWithWhereUniqueWithoutExamInput[]
    createMany?: QuestionCreateManyExamInputEnvelope
    set?: QuestionWhereUniqueInput | QuestionWhereUniqueInput[]
    disconnect?: QuestionWhereUniqueInput | QuestionWhereUniqueInput[]
    delete?: QuestionWhereUniqueInput | QuestionWhereUniqueInput[]
    connect?: QuestionWhereUniqueInput | QuestionWhereUniqueInput[]
    update?: QuestionUpdateWithWhereUniqueWithoutExamInput | QuestionUpdateWithWhereUniqueWithoutExamInput[]
    updateMany?: QuestionUpdateManyWithWhereWithoutExamInput | QuestionUpdateManyWithWhereWithoutExamInput[]
    deleteMany?: QuestionScalarWhereInput | QuestionScalarWhereInput[]
  }

  export type ExamAttemptUncheckedUpdateManyWithoutExamNestedInput = {
    create?: XOR<ExamAttemptCreateWithoutExamInput, ExamAttemptUncheckedCreateWithoutExamInput> | ExamAttemptCreateWithoutExamInput[] | ExamAttemptUncheckedCreateWithoutExamInput[]
    connectOrCreate?: ExamAttemptCreateOrConnectWithoutExamInput | ExamAttemptCreateOrConnectWithoutExamInput[]
    upsert?: ExamAttemptUpsertWithWhereUniqueWithoutExamInput | ExamAttemptUpsertWithWhereUniqueWithoutExamInput[]
    createMany?: ExamAttemptCreateManyExamInputEnvelope
    set?: ExamAttemptWhereUniqueInput | ExamAttemptWhereUniqueInput[]
    disconnect?: ExamAttemptWhereUniqueInput | ExamAttemptWhereUniqueInput[]
    delete?: ExamAttemptWhereUniqueInput | ExamAttemptWhereUniqueInput[]
    connect?: ExamAttemptWhereUniqueInput | ExamAttemptWhereUniqueInput[]
    update?: ExamAttemptUpdateWithWhereUniqueWithoutExamInput | ExamAttemptUpdateWithWhereUniqueWithoutExamInput[]
    updateMany?: ExamAttemptUpdateManyWithWhereWithoutExamInput | ExamAttemptUpdateManyWithWhereWithoutExamInput[]
    deleteMany?: ExamAttemptScalarWhereInput | ExamAttemptScalarWhereInput[]
  }

  export type UserCourseCompletionUncheckedUpdateManyWithoutExamNestedInput = {
    create?: XOR<UserCourseCompletionCreateWithoutExamInput, UserCourseCompletionUncheckedCreateWithoutExamInput> | UserCourseCompletionCreateWithoutExamInput[] | UserCourseCompletionUncheckedCreateWithoutExamInput[]
    connectOrCreate?: UserCourseCompletionCreateOrConnectWithoutExamInput | UserCourseCompletionCreateOrConnectWithoutExamInput[]
    upsert?: UserCourseCompletionUpsertWithWhereUniqueWithoutExamInput | UserCourseCompletionUpsertWithWhereUniqueWithoutExamInput[]
    createMany?: UserCourseCompletionCreateManyExamInputEnvelope
    set?: UserCourseCompletionWhereUniqueInput | UserCourseCompletionWhereUniqueInput[]
    disconnect?: UserCourseCompletionWhereUniqueInput | UserCourseCompletionWhereUniqueInput[]
    delete?: UserCourseCompletionWhereUniqueInput | UserCourseCompletionWhereUniqueInput[]
    connect?: UserCourseCompletionWhereUniqueInput | UserCourseCompletionWhereUniqueInput[]
    update?: UserCourseCompletionUpdateWithWhereUniqueWithoutExamInput | UserCourseCompletionUpdateWithWhereUniqueWithoutExamInput[]
    updateMany?: UserCourseCompletionUpdateManyWithWhereWithoutExamInput | UserCourseCompletionUpdateManyWithWhereWithoutExamInput[]
    deleteMany?: UserCourseCompletionScalarWhereInput | UserCourseCompletionScalarWhereInput[]
  }

  export type ExamCreateNestedOneWithoutQuestionsInput = {
    create?: XOR<ExamCreateWithoutQuestionsInput, ExamUncheckedCreateWithoutQuestionsInput>
    connectOrCreate?: ExamCreateOrConnectWithoutQuestionsInput
    connect?: ExamWhereUniqueInput
  }

  export type ChoiceCreateNestedManyWithoutQuestionInput = {
    create?: XOR<ChoiceCreateWithoutQuestionInput, ChoiceUncheckedCreateWithoutQuestionInput> | ChoiceCreateWithoutQuestionInput[] | ChoiceUncheckedCreateWithoutQuestionInput[]
    connectOrCreate?: ChoiceCreateOrConnectWithoutQuestionInput | ChoiceCreateOrConnectWithoutQuestionInput[]
    createMany?: ChoiceCreateManyQuestionInputEnvelope
    connect?: ChoiceWhereUniqueInput | ChoiceWhereUniqueInput[]
  }

  export type UserAnswerCreateNestedManyWithoutQuestionInput = {
    create?: XOR<UserAnswerCreateWithoutQuestionInput, UserAnswerUncheckedCreateWithoutQuestionInput> | UserAnswerCreateWithoutQuestionInput[] | UserAnswerUncheckedCreateWithoutQuestionInput[]
    connectOrCreate?: UserAnswerCreateOrConnectWithoutQuestionInput | UserAnswerCreateOrConnectWithoutQuestionInput[]
    createMany?: UserAnswerCreateManyQuestionInputEnvelope
    connect?: UserAnswerWhereUniqueInput | UserAnswerWhereUniqueInput[]
  }

  export type ChoiceUncheckedCreateNestedManyWithoutQuestionInput = {
    create?: XOR<ChoiceCreateWithoutQuestionInput, ChoiceUncheckedCreateWithoutQuestionInput> | ChoiceCreateWithoutQuestionInput[] | ChoiceUncheckedCreateWithoutQuestionInput[]
    connectOrCreate?: ChoiceCreateOrConnectWithoutQuestionInput | ChoiceCreateOrConnectWithoutQuestionInput[]
    createMany?: ChoiceCreateManyQuestionInputEnvelope
    connect?: ChoiceWhereUniqueInput | ChoiceWhereUniqueInput[]
  }

  export type UserAnswerUncheckedCreateNestedManyWithoutQuestionInput = {
    create?: XOR<UserAnswerCreateWithoutQuestionInput, UserAnswerUncheckedCreateWithoutQuestionInput> | UserAnswerCreateWithoutQuestionInput[] | UserAnswerUncheckedCreateWithoutQuestionInput[]
    connectOrCreate?: UserAnswerCreateOrConnectWithoutQuestionInput | UserAnswerCreateOrConnectWithoutQuestionInput[]
    createMany?: UserAnswerCreateManyQuestionInputEnvelope
    connect?: UserAnswerWhereUniqueInput | UserAnswerWhereUniqueInput[]
  }

  export type ExamUpdateOneRequiredWithoutQuestionsNestedInput = {
    create?: XOR<ExamCreateWithoutQuestionsInput, ExamUncheckedCreateWithoutQuestionsInput>
    connectOrCreate?: ExamCreateOrConnectWithoutQuestionsInput
    upsert?: ExamUpsertWithoutQuestionsInput
    connect?: ExamWhereUniqueInput
    update?: XOR<XOR<ExamUpdateToOneWithWhereWithoutQuestionsInput, ExamUpdateWithoutQuestionsInput>, ExamUncheckedUpdateWithoutQuestionsInput>
  }

  export type ChoiceUpdateManyWithoutQuestionNestedInput = {
    create?: XOR<ChoiceCreateWithoutQuestionInput, ChoiceUncheckedCreateWithoutQuestionInput> | ChoiceCreateWithoutQuestionInput[] | ChoiceUncheckedCreateWithoutQuestionInput[]
    connectOrCreate?: ChoiceCreateOrConnectWithoutQuestionInput | ChoiceCreateOrConnectWithoutQuestionInput[]
    upsert?: ChoiceUpsertWithWhereUniqueWithoutQuestionInput | ChoiceUpsertWithWhereUniqueWithoutQuestionInput[]
    createMany?: ChoiceCreateManyQuestionInputEnvelope
    set?: ChoiceWhereUniqueInput | ChoiceWhereUniqueInput[]
    disconnect?: ChoiceWhereUniqueInput | ChoiceWhereUniqueInput[]
    delete?: ChoiceWhereUniqueInput | ChoiceWhereUniqueInput[]
    connect?: ChoiceWhereUniqueInput | ChoiceWhereUniqueInput[]
    update?: ChoiceUpdateWithWhereUniqueWithoutQuestionInput | ChoiceUpdateWithWhereUniqueWithoutQuestionInput[]
    updateMany?: ChoiceUpdateManyWithWhereWithoutQuestionInput | ChoiceUpdateManyWithWhereWithoutQuestionInput[]
    deleteMany?: ChoiceScalarWhereInput | ChoiceScalarWhereInput[]
  }

  export type UserAnswerUpdateManyWithoutQuestionNestedInput = {
    create?: XOR<UserAnswerCreateWithoutQuestionInput, UserAnswerUncheckedCreateWithoutQuestionInput> | UserAnswerCreateWithoutQuestionInput[] | UserAnswerUncheckedCreateWithoutQuestionInput[]
    connectOrCreate?: UserAnswerCreateOrConnectWithoutQuestionInput | UserAnswerCreateOrConnectWithoutQuestionInput[]
    upsert?: UserAnswerUpsertWithWhereUniqueWithoutQuestionInput | UserAnswerUpsertWithWhereUniqueWithoutQuestionInput[]
    createMany?: UserAnswerCreateManyQuestionInputEnvelope
    set?: UserAnswerWhereUniqueInput | UserAnswerWhereUniqueInput[]
    disconnect?: UserAnswerWhereUniqueInput | UserAnswerWhereUniqueInput[]
    delete?: UserAnswerWhereUniqueInput | UserAnswerWhereUniqueInput[]
    connect?: UserAnswerWhereUniqueInput | UserAnswerWhereUniqueInput[]
    update?: UserAnswerUpdateWithWhereUniqueWithoutQuestionInput | UserAnswerUpdateWithWhereUniqueWithoutQuestionInput[]
    updateMany?: UserAnswerUpdateManyWithWhereWithoutQuestionInput | UserAnswerUpdateManyWithWhereWithoutQuestionInput[]
    deleteMany?: UserAnswerScalarWhereInput | UserAnswerScalarWhereInput[]
  }

  export type ChoiceUncheckedUpdateManyWithoutQuestionNestedInput = {
    create?: XOR<ChoiceCreateWithoutQuestionInput, ChoiceUncheckedCreateWithoutQuestionInput> | ChoiceCreateWithoutQuestionInput[] | ChoiceUncheckedCreateWithoutQuestionInput[]
    connectOrCreate?: ChoiceCreateOrConnectWithoutQuestionInput | ChoiceCreateOrConnectWithoutQuestionInput[]
    upsert?: ChoiceUpsertWithWhereUniqueWithoutQuestionInput | ChoiceUpsertWithWhereUniqueWithoutQuestionInput[]
    createMany?: ChoiceCreateManyQuestionInputEnvelope
    set?: ChoiceWhereUniqueInput | ChoiceWhereUniqueInput[]
    disconnect?: ChoiceWhereUniqueInput | ChoiceWhereUniqueInput[]
    delete?: ChoiceWhereUniqueInput | ChoiceWhereUniqueInput[]
    connect?: ChoiceWhereUniqueInput | ChoiceWhereUniqueInput[]
    update?: ChoiceUpdateWithWhereUniqueWithoutQuestionInput | ChoiceUpdateWithWhereUniqueWithoutQuestionInput[]
    updateMany?: ChoiceUpdateManyWithWhereWithoutQuestionInput | ChoiceUpdateManyWithWhereWithoutQuestionInput[]
    deleteMany?: ChoiceScalarWhereInput | ChoiceScalarWhereInput[]
  }

  export type UserAnswerUncheckedUpdateManyWithoutQuestionNestedInput = {
    create?: XOR<UserAnswerCreateWithoutQuestionInput, UserAnswerUncheckedCreateWithoutQuestionInput> | UserAnswerCreateWithoutQuestionInput[] | UserAnswerUncheckedCreateWithoutQuestionInput[]
    connectOrCreate?: UserAnswerCreateOrConnectWithoutQuestionInput | UserAnswerCreateOrConnectWithoutQuestionInput[]
    upsert?: UserAnswerUpsertWithWhereUniqueWithoutQuestionInput | UserAnswerUpsertWithWhereUniqueWithoutQuestionInput[]
    createMany?: UserAnswerCreateManyQuestionInputEnvelope
    set?: UserAnswerWhereUniqueInput | UserAnswerWhereUniqueInput[]
    disconnect?: UserAnswerWhereUniqueInput | UserAnswerWhereUniqueInput[]
    delete?: UserAnswerWhereUniqueInput | UserAnswerWhereUniqueInput[]
    connect?: UserAnswerWhereUniqueInput | UserAnswerWhereUniqueInput[]
    update?: UserAnswerUpdateWithWhereUniqueWithoutQuestionInput | UserAnswerUpdateWithWhereUniqueWithoutQuestionInput[]
    updateMany?: UserAnswerUpdateManyWithWhereWithoutQuestionInput | UserAnswerUpdateManyWithWhereWithoutQuestionInput[]
    deleteMany?: UserAnswerScalarWhereInput | UserAnswerScalarWhereInput[]
  }

  export type QuestionCreateNestedOneWithoutChoicesInput = {
    create?: XOR<QuestionCreateWithoutChoicesInput, QuestionUncheckedCreateWithoutChoicesInput>
    connectOrCreate?: QuestionCreateOrConnectWithoutChoicesInput
    connect?: QuestionWhereUniqueInput
  }

  export type UserAnswerCreateNestedManyWithoutSelectedChoiceInput = {
    create?: XOR<UserAnswerCreateWithoutSelectedChoiceInput, UserAnswerUncheckedCreateWithoutSelectedChoiceInput> | UserAnswerCreateWithoutSelectedChoiceInput[] | UserAnswerUncheckedCreateWithoutSelectedChoiceInput[]
    connectOrCreate?: UserAnswerCreateOrConnectWithoutSelectedChoiceInput | UserAnswerCreateOrConnectWithoutSelectedChoiceInput[]
    createMany?: UserAnswerCreateManySelectedChoiceInputEnvelope
    connect?: UserAnswerWhereUniqueInput | UserAnswerWhereUniqueInput[]
  }

  export type UserAnswerUncheckedCreateNestedManyWithoutSelectedChoiceInput = {
    create?: XOR<UserAnswerCreateWithoutSelectedChoiceInput, UserAnswerUncheckedCreateWithoutSelectedChoiceInput> | UserAnswerCreateWithoutSelectedChoiceInput[] | UserAnswerUncheckedCreateWithoutSelectedChoiceInput[]
    connectOrCreate?: UserAnswerCreateOrConnectWithoutSelectedChoiceInput | UserAnswerCreateOrConnectWithoutSelectedChoiceInput[]
    createMany?: UserAnswerCreateManySelectedChoiceInputEnvelope
    connect?: UserAnswerWhereUniqueInput | UserAnswerWhereUniqueInput[]
  }

  export type QuestionUpdateOneRequiredWithoutChoicesNestedInput = {
    create?: XOR<QuestionCreateWithoutChoicesInput, QuestionUncheckedCreateWithoutChoicesInput>
    connectOrCreate?: QuestionCreateOrConnectWithoutChoicesInput
    upsert?: QuestionUpsertWithoutChoicesInput
    connect?: QuestionWhereUniqueInput
    update?: XOR<XOR<QuestionUpdateToOneWithWhereWithoutChoicesInput, QuestionUpdateWithoutChoicesInput>, QuestionUncheckedUpdateWithoutChoicesInput>
  }

  export type UserAnswerUpdateManyWithoutSelectedChoiceNestedInput = {
    create?: XOR<UserAnswerCreateWithoutSelectedChoiceInput, UserAnswerUncheckedCreateWithoutSelectedChoiceInput> | UserAnswerCreateWithoutSelectedChoiceInput[] | UserAnswerUncheckedCreateWithoutSelectedChoiceInput[]
    connectOrCreate?: UserAnswerCreateOrConnectWithoutSelectedChoiceInput | UserAnswerCreateOrConnectWithoutSelectedChoiceInput[]
    upsert?: UserAnswerUpsertWithWhereUniqueWithoutSelectedChoiceInput | UserAnswerUpsertWithWhereUniqueWithoutSelectedChoiceInput[]
    createMany?: UserAnswerCreateManySelectedChoiceInputEnvelope
    set?: UserAnswerWhereUniqueInput | UserAnswerWhereUniqueInput[]
    disconnect?: UserAnswerWhereUniqueInput | UserAnswerWhereUniqueInput[]
    delete?: UserAnswerWhereUniqueInput | UserAnswerWhereUniqueInput[]
    connect?: UserAnswerWhereUniqueInput | UserAnswerWhereUniqueInput[]
    update?: UserAnswerUpdateWithWhereUniqueWithoutSelectedChoiceInput | UserAnswerUpdateWithWhereUniqueWithoutSelectedChoiceInput[]
    updateMany?: UserAnswerUpdateManyWithWhereWithoutSelectedChoiceInput | UserAnswerUpdateManyWithWhereWithoutSelectedChoiceInput[]
    deleteMany?: UserAnswerScalarWhereInput | UserAnswerScalarWhereInput[]
  }

  export type UserAnswerUncheckedUpdateManyWithoutSelectedChoiceNestedInput = {
    create?: XOR<UserAnswerCreateWithoutSelectedChoiceInput, UserAnswerUncheckedCreateWithoutSelectedChoiceInput> | UserAnswerCreateWithoutSelectedChoiceInput[] | UserAnswerUncheckedCreateWithoutSelectedChoiceInput[]
    connectOrCreate?: UserAnswerCreateOrConnectWithoutSelectedChoiceInput | UserAnswerCreateOrConnectWithoutSelectedChoiceInput[]
    upsert?: UserAnswerUpsertWithWhereUniqueWithoutSelectedChoiceInput | UserAnswerUpsertWithWhereUniqueWithoutSelectedChoiceInput[]
    createMany?: UserAnswerCreateManySelectedChoiceInputEnvelope
    set?: UserAnswerWhereUniqueInput | UserAnswerWhereUniqueInput[]
    disconnect?: UserAnswerWhereUniqueInput | UserAnswerWhereUniqueInput[]
    delete?: UserAnswerWhereUniqueInput | UserAnswerWhereUniqueInput[]
    connect?: UserAnswerWhereUniqueInput | UserAnswerWhereUniqueInput[]
    update?: UserAnswerUpdateWithWhereUniqueWithoutSelectedChoiceInput | UserAnswerUpdateWithWhereUniqueWithoutSelectedChoiceInput[]
    updateMany?: UserAnswerUpdateManyWithWhereWithoutSelectedChoiceInput | UserAnswerUpdateManyWithWhereWithoutSelectedChoiceInput[]
    deleteMany?: UserAnswerScalarWhereInput | UserAnswerScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutExamsInput = {
    create?: XOR<UserCreateWithoutExamsInput, UserUncheckedCreateWithoutExamsInput>
    connectOrCreate?: UserCreateOrConnectWithoutExamsInput
    connect?: UserWhereUniqueInput
  }

  export type ExamCreateNestedOneWithoutAttemptsInput = {
    create?: XOR<ExamCreateWithoutAttemptsInput, ExamUncheckedCreateWithoutAttemptsInput>
    connectOrCreate?: ExamCreateOrConnectWithoutAttemptsInput
    connect?: ExamWhereUniqueInput
  }

  export type UserAnswerCreateNestedManyWithoutExamAttemptInput = {
    create?: XOR<UserAnswerCreateWithoutExamAttemptInput, UserAnswerUncheckedCreateWithoutExamAttemptInput> | UserAnswerCreateWithoutExamAttemptInput[] | UserAnswerUncheckedCreateWithoutExamAttemptInput[]
    connectOrCreate?: UserAnswerCreateOrConnectWithoutExamAttemptInput | UserAnswerCreateOrConnectWithoutExamAttemptInput[]
    createMany?: UserAnswerCreateManyExamAttemptInputEnvelope
    connect?: UserAnswerWhereUniqueInput | UserAnswerWhereUniqueInput[]
  }

  export type UserAnswerUncheckedCreateNestedManyWithoutExamAttemptInput = {
    create?: XOR<UserAnswerCreateWithoutExamAttemptInput, UserAnswerUncheckedCreateWithoutExamAttemptInput> | UserAnswerCreateWithoutExamAttemptInput[] | UserAnswerUncheckedCreateWithoutExamAttemptInput[]
    connectOrCreate?: UserAnswerCreateOrConnectWithoutExamAttemptInput | UserAnswerCreateOrConnectWithoutExamAttemptInput[]
    createMany?: UserAnswerCreateManyExamAttemptInputEnvelope
    connect?: UserAnswerWhereUniqueInput | UserAnswerWhereUniqueInput[]
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableBoolFieldUpdateOperationsInput = {
    set?: boolean | null
  }

  export type UserUpdateOneRequiredWithoutExamsNestedInput = {
    create?: XOR<UserCreateWithoutExamsInput, UserUncheckedCreateWithoutExamsInput>
    connectOrCreate?: UserCreateOrConnectWithoutExamsInput
    upsert?: UserUpsertWithoutExamsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutExamsInput, UserUpdateWithoutExamsInput>, UserUncheckedUpdateWithoutExamsInput>
  }

  export type ExamUpdateOneRequiredWithoutAttemptsNestedInput = {
    create?: XOR<ExamCreateWithoutAttemptsInput, ExamUncheckedCreateWithoutAttemptsInput>
    connectOrCreate?: ExamCreateOrConnectWithoutAttemptsInput
    upsert?: ExamUpsertWithoutAttemptsInput
    connect?: ExamWhereUniqueInput
    update?: XOR<XOR<ExamUpdateToOneWithWhereWithoutAttemptsInput, ExamUpdateWithoutAttemptsInput>, ExamUncheckedUpdateWithoutAttemptsInput>
  }

  export type UserAnswerUpdateManyWithoutExamAttemptNestedInput = {
    create?: XOR<UserAnswerCreateWithoutExamAttemptInput, UserAnswerUncheckedCreateWithoutExamAttemptInput> | UserAnswerCreateWithoutExamAttemptInput[] | UserAnswerUncheckedCreateWithoutExamAttemptInput[]
    connectOrCreate?: UserAnswerCreateOrConnectWithoutExamAttemptInput | UserAnswerCreateOrConnectWithoutExamAttemptInput[]
    upsert?: UserAnswerUpsertWithWhereUniqueWithoutExamAttemptInput | UserAnswerUpsertWithWhereUniqueWithoutExamAttemptInput[]
    createMany?: UserAnswerCreateManyExamAttemptInputEnvelope
    set?: UserAnswerWhereUniqueInput | UserAnswerWhereUniqueInput[]
    disconnect?: UserAnswerWhereUniqueInput | UserAnswerWhereUniqueInput[]
    delete?: UserAnswerWhereUniqueInput | UserAnswerWhereUniqueInput[]
    connect?: UserAnswerWhereUniqueInput | UserAnswerWhereUniqueInput[]
    update?: UserAnswerUpdateWithWhereUniqueWithoutExamAttemptInput | UserAnswerUpdateWithWhereUniqueWithoutExamAttemptInput[]
    updateMany?: UserAnswerUpdateManyWithWhereWithoutExamAttemptInput | UserAnswerUpdateManyWithWhereWithoutExamAttemptInput[]
    deleteMany?: UserAnswerScalarWhereInput | UserAnswerScalarWhereInput[]
  }

  export type UserAnswerUncheckedUpdateManyWithoutExamAttemptNestedInput = {
    create?: XOR<UserAnswerCreateWithoutExamAttemptInput, UserAnswerUncheckedCreateWithoutExamAttemptInput> | UserAnswerCreateWithoutExamAttemptInput[] | UserAnswerUncheckedCreateWithoutExamAttemptInput[]
    connectOrCreate?: UserAnswerCreateOrConnectWithoutExamAttemptInput | UserAnswerCreateOrConnectWithoutExamAttemptInput[]
    upsert?: UserAnswerUpsertWithWhereUniqueWithoutExamAttemptInput | UserAnswerUpsertWithWhereUniqueWithoutExamAttemptInput[]
    createMany?: UserAnswerCreateManyExamAttemptInputEnvelope
    set?: UserAnswerWhereUniqueInput | UserAnswerWhereUniqueInput[]
    disconnect?: UserAnswerWhereUniqueInput | UserAnswerWhereUniqueInput[]
    delete?: UserAnswerWhereUniqueInput | UserAnswerWhereUniqueInput[]
    connect?: UserAnswerWhereUniqueInput | UserAnswerWhereUniqueInput[]
    update?: UserAnswerUpdateWithWhereUniqueWithoutExamAttemptInput | UserAnswerUpdateWithWhereUniqueWithoutExamAttemptInput[]
    updateMany?: UserAnswerUpdateManyWithWhereWithoutExamAttemptInput | UserAnswerUpdateManyWithWhereWithoutExamAttemptInput[]
    deleteMany?: UserAnswerScalarWhereInput | UserAnswerScalarWhereInput[]
  }

  export type ExamAttemptCreateNestedOneWithoutAnswersInput = {
    create?: XOR<ExamAttemptCreateWithoutAnswersInput, ExamAttemptUncheckedCreateWithoutAnswersInput>
    connectOrCreate?: ExamAttemptCreateOrConnectWithoutAnswersInput
    connect?: ExamAttemptWhereUniqueInput
  }

  export type QuestionCreateNestedOneWithoutUserAnswersInput = {
    create?: XOR<QuestionCreateWithoutUserAnswersInput, QuestionUncheckedCreateWithoutUserAnswersInput>
    connectOrCreate?: QuestionCreateOrConnectWithoutUserAnswersInput
    connect?: QuestionWhereUniqueInput
  }

  export type ChoiceCreateNestedOneWithoutUserAnswerInput = {
    create?: XOR<ChoiceCreateWithoutUserAnswerInput, ChoiceUncheckedCreateWithoutUserAnswerInput>
    connectOrCreate?: ChoiceCreateOrConnectWithoutUserAnswerInput
    connect?: ChoiceWhereUniqueInput
  }

  export type ExamAttemptUpdateOneRequiredWithoutAnswersNestedInput = {
    create?: XOR<ExamAttemptCreateWithoutAnswersInput, ExamAttemptUncheckedCreateWithoutAnswersInput>
    connectOrCreate?: ExamAttemptCreateOrConnectWithoutAnswersInput
    upsert?: ExamAttemptUpsertWithoutAnswersInput
    connect?: ExamAttemptWhereUniqueInput
    update?: XOR<XOR<ExamAttemptUpdateToOneWithWhereWithoutAnswersInput, ExamAttemptUpdateWithoutAnswersInput>, ExamAttemptUncheckedUpdateWithoutAnswersInput>
  }

  export type QuestionUpdateOneRequiredWithoutUserAnswersNestedInput = {
    create?: XOR<QuestionCreateWithoutUserAnswersInput, QuestionUncheckedCreateWithoutUserAnswersInput>
    connectOrCreate?: QuestionCreateOrConnectWithoutUserAnswersInput
    upsert?: QuestionUpsertWithoutUserAnswersInput
    connect?: QuestionWhereUniqueInput
    update?: XOR<XOR<QuestionUpdateToOneWithWhereWithoutUserAnswersInput, QuestionUpdateWithoutUserAnswersInput>, QuestionUncheckedUpdateWithoutUserAnswersInput>
  }

  export type ChoiceUpdateOneRequiredWithoutUserAnswerNestedInput = {
    create?: XOR<ChoiceCreateWithoutUserAnswerInput, ChoiceUncheckedCreateWithoutUserAnswerInput>
    connectOrCreate?: ChoiceCreateOrConnectWithoutUserAnswerInput
    upsert?: ChoiceUpsertWithoutUserAnswerInput
    connect?: ChoiceWhereUniqueInput
    update?: XOR<XOR<ChoiceUpdateToOneWithWhereWithoutUserAnswerInput, ChoiceUpdateWithoutUserAnswerInput>, ChoiceUncheckedUpdateWithoutUserAnswerInput>
  }

  export type UserCreateNestedOneWithoutOplDocumentsInput = {
    create?: XOR<UserCreateWithoutOplDocumentsInput, UserUncheckedCreateWithoutOplDocumentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutOplDocumentsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutOplDocumentsNestedInput = {
    create?: XOR<UserCreateWithoutOplDocumentsInput, UserUncheckedCreateWithoutOplDocumentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutOplDocumentsInput
    upsert?: UserUpsertWithoutOplDocumentsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutOplDocumentsInput, UserUpdateWithoutOplDocumentsInput>, UserUncheckedUpdateWithoutOplDocumentsInput>
  }

  export type UserCreateNestedOneWithoutFilesInput = {
    create?: XOR<UserCreateWithoutFilesInput, UserUncheckedCreateWithoutFilesInput>
    connectOrCreate?: UserCreateOrConnectWithoutFilesInput
    connect?: UserWhereUniqueInput
  }

  export type CourseCreateNestedOneWithoutFilesInput = {
    create?: XOR<CourseCreateWithoutFilesInput, CourseUncheckedCreateWithoutFilesInput>
    connectOrCreate?: CourseCreateOrConnectWithoutFilesInput
    connect?: CourseWhereUniqueInput
  }

  export type BigIntFieldUpdateOperationsInput = {
    set?: bigint | number
    increment?: bigint | number
    decrement?: bigint | number
    multiply?: bigint | number
    divide?: bigint | number
  }

  export type UserUpdateOneWithoutFilesNestedInput = {
    create?: XOR<UserCreateWithoutFilesInput, UserUncheckedCreateWithoutFilesInput>
    connectOrCreate?: UserCreateOrConnectWithoutFilesInput
    upsert?: UserUpsertWithoutFilesInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutFilesInput, UserUpdateWithoutFilesInput>, UserUncheckedUpdateWithoutFilesInput>
  }

  export type CourseUpdateOneWithoutFilesNestedInput = {
    create?: XOR<CourseCreateWithoutFilesInput, CourseUncheckedCreateWithoutFilesInput>
    connectOrCreate?: CourseCreateOrConnectWithoutFilesInput
    upsert?: CourseUpsertWithoutFilesInput
    disconnect?: CourseWhereInput | boolean
    delete?: CourseWhereInput | boolean
    connect?: CourseWhereUniqueInput
    update?: XOR<XOR<CourseUpdateToOneWithWhereWithoutFilesInput, CourseUpdateWithoutFilesInput>, CourseUncheckedUpdateWithoutFilesInput>
  }

  export type UserCreateNestedOneWithoutProcessesInput = {
    create?: XOR<UserCreateWithoutProcessesInput, UserUncheckedCreateWithoutProcessesInput>
    connectOrCreate?: UserCreateOrConnectWithoutProcessesInput
    connect?: UserWhereUniqueInput
  }

  export type CourseCreateNestedManyWithoutProcessInput = {
    create?: XOR<CourseCreateWithoutProcessInput, CourseUncheckedCreateWithoutProcessInput> | CourseCreateWithoutProcessInput[] | CourseUncheckedCreateWithoutProcessInput[]
    connectOrCreate?: CourseCreateOrConnectWithoutProcessInput | CourseCreateOrConnectWithoutProcessInput[]
    createMany?: CourseCreateManyProcessInputEnvelope
    connect?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
  }

  export type UserCourseCompletionCreateNestedManyWithoutProcessInput = {
    create?: XOR<UserCourseCompletionCreateWithoutProcessInput, UserCourseCompletionUncheckedCreateWithoutProcessInput> | UserCourseCompletionCreateWithoutProcessInput[] | UserCourseCompletionUncheckedCreateWithoutProcessInput[]
    connectOrCreate?: UserCourseCompletionCreateOrConnectWithoutProcessInput | UserCourseCompletionCreateOrConnectWithoutProcessInput[]
    createMany?: UserCourseCompletionCreateManyProcessInputEnvelope
    connect?: UserCourseCompletionWhereUniqueInput | UserCourseCompletionWhereUniqueInput[]
  }

  export type ProcessDetailCreateNestedManyWithoutProcessInput = {
    create?: XOR<ProcessDetailCreateWithoutProcessInput, ProcessDetailUncheckedCreateWithoutProcessInput> | ProcessDetailCreateWithoutProcessInput[] | ProcessDetailUncheckedCreateWithoutProcessInput[]
    connectOrCreate?: ProcessDetailCreateOrConnectWithoutProcessInput | ProcessDetailCreateOrConnectWithoutProcessInput[]
    createMany?: ProcessDetailCreateManyProcessInputEnvelope
    connect?: ProcessDetailWhereUniqueInput | ProcessDetailWhereUniqueInput[]
  }

  export type CourseUncheckedCreateNestedManyWithoutProcessInput = {
    create?: XOR<CourseCreateWithoutProcessInput, CourseUncheckedCreateWithoutProcessInput> | CourseCreateWithoutProcessInput[] | CourseUncheckedCreateWithoutProcessInput[]
    connectOrCreate?: CourseCreateOrConnectWithoutProcessInput | CourseCreateOrConnectWithoutProcessInput[]
    createMany?: CourseCreateManyProcessInputEnvelope
    connect?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
  }

  export type UserCourseCompletionUncheckedCreateNestedManyWithoutProcessInput = {
    create?: XOR<UserCourseCompletionCreateWithoutProcessInput, UserCourseCompletionUncheckedCreateWithoutProcessInput> | UserCourseCompletionCreateWithoutProcessInput[] | UserCourseCompletionUncheckedCreateWithoutProcessInput[]
    connectOrCreate?: UserCourseCompletionCreateOrConnectWithoutProcessInput | UserCourseCompletionCreateOrConnectWithoutProcessInput[]
    createMany?: UserCourseCompletionCreateManyProcessInputEnvelope
    connect?: UserCourseCompletionWhereUniqueInput | UserCourseCompletionWhereUniqueInput[]
  }

  export type ProcessDetailUncheckedCreateNestedManyWithoutProcessInput = {
    create?: XOR<ProcessDetailCreateWithoutProcessInput, ProcessDetailUncheckedCreateWithoutProcessInput> | ProcessDetailCreateWithoutProcessInput[] | ProcessDetailUncheckedCreateWithoutProcessInput[]
    connectOrCreate?: ProcessDetailCreateOrConnectWithoutProcessInput | ProcessDetailCreateOrConnectWithoutProcessInput[]
    createMany?: ProcessDetailCreateManyProcessInputEnvelope
    connect?: ProcessDetailWhereUniqueInput | ProcessDetailWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutProcessesNestedInput = {
    create?: XOR<UserCreateWithoutProcessesInput, UserUncheckedCreateWithoutProcessesInput>
    connectOrCreate?: UserCreateOrConnectWithoutProcessesInput
    upsert?: UserUpsertWithoutProcessesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutProcessesInput, UserUpdateWithoutProcessesInput>, UserUncheckedUpdateWithoutProcessesInput>
  }

  export type CourseUpdateManyWithoutProcessNestedInput = {
    create?: XOR<CourseCreateWithoutProcessInput, CourseUncheckedCreateWithoutProcessInput> | CourseCreateWithoutProcessInput[] | CourseUncheckedCreateWithoutProcessInput[]
    connectOrCreate?: CourseCreateOrConnectWithoutProcessInput | CourseCreateOrConnectWithoutProcessInput[]
    upsert?: CourseUpsertWithWhereUniqueWithoutProcessInput | CourseUpsertWithWhereUniqueWithoutProcessInput[]
    createMany?: CourseCreateManyProcessInputEnvelope
    set?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
    disconnect?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
    delete?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
    connect?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
    update?: CourseUpdateWithWhereUniqueWithoutProcessInput | CourseUpdateWithWhereUniqueWithoutProcessInput[]
    updateMany?: CourseUpdateManyWithWhereWithoutProcessInput | CourseUpdateManyWithWhereWithoutProcessInput[]
    deleteMany?: CourseScalarWhereInput | CourseScalarWhereInput[]
  }

  export type UserCourseCompletionUpdateManyWithoutProcessNestedInput = {
    create?: XOR<UserCourseCompletionCreateWithoutProcessInput, UserCourseCompletionUncheckedCreateWithoutProcessInput> | UserCourseCompletionCreateWithoutProcessInput[] | UserCourseCompletionUncheckedCreateWithoutProcessInput[]
    connectOrCreate?: UserCourseCompletionCreateOrConnectWithoutProcessInput | UserCourseCompletionCreateOrConnectWithoutProcessInput[]
    upsert?: UserCourseCompletionUpsertWithWhereUniqueWithoutProcessInput | UserCourseCompletionUpsertWithWhereUniqueWithoutProcessInput[]
    createMany?: UserCourseCompletionCreateManyProcessInputEnvelope
    set?: UserCourseCompletionWhereUniqueInput | UserCourseCompletionWhereUniqueInput[]
    disconnect?: UserCourseCompletionWhereUniqueInput | UserCourseCompletionWhereUniqueInput[]
    delete?: UserCourseCompletionWhereUniqueInput | UserCourseCompletionWhereUniqueInput[]
    connect?: UserCourseCompletionWhereUniqueInput | UserCourseCompletionWhereUniqueInput[]
    update?: UserCourseCompletionUpdateWithWhereUniqueWithoutProcessInput | UserCourseCompletionUpdateWithWhereUniqueWithoutProcessInput[]
    updateMany?: UserCourseCompletionUpdateManyWithWhereWithoutProcessInput | UserCourseCompletionUpdateManyWithWhereWithoutProcessInput[]
    deleteMany?: UserCourseCompletionScalarWhereInput | UserCourseCompletionScalarWhereInput[]
  }

  export type ProcessDetailUpdateManyWithoutProcessNestedInput = {
    create?: XOR<ProcessDetailCreateWithoutProcessInput, ProcessDetailUncheckedCreateWithoutProcessInput> | ProcessDetailCreateWithoutProcessInput[] | ProcessDetailUncheckedCreateWithoutProcessInput[]
    connectOrCreate?: ProcessDetailCreateOrConnectWithoutProcessInput | ProcessDetailCreateOrConnectWithoutProcessInput[]
    upsert?: ProcessDetailUpsertWithWhereUniqueWithoutProcessInput | ProcessDetailUpsertWithWhereUniqueWithoutProcessInput[]
    createMany?: ProcessDetailCreateManyProcessInputEnvelope
    set?: ProcessDetailWhereUniqueInput | ProcessDetailWhereUniqueInput[]
    disconnect?: ProcessDetailWhereUniqueInput | ProcessDetailWhereUniqueInput[]
    delete?: ProcessDetailWhereUniqueInput | ProcessDetailWhereUniqueInput[]
    connect?: ProcessDetailWhereUniqueInput | ProcessDetailWhereUniqueInput[]
    update?: ProcessDetailUpdateWithWhereUniqueWithoutProcessInput | ProcessDetailUpdateWithWhereUniqueWithoutProcessInput[]
    updateMany?: ProcessDetailUpdateManyWithWhereWithoutProcessInput | ProcessDetailUpdateManyWithWhereWithoutProcessInput[]
    deleteMany?: ProcessDetailScalarWhereInput | ProcessDetailScalarWhereInput[]
  }

  export type CourseUncheckedUpdateManyWithoutProcessNestedInput = {
    create?: XOR<CourseCreateWithoutProcessInput, CourseUncheckedCreateWithoutProcessInput> | CourseCreateWithoutProcessInput[] | CourseUncheckedCreateWithoutProcessInput[]
    connectOrCreate?: CourseCreateOrConnectWithoutProcessInput | CourseCreateOrConnectWithoutProcessInput[]
    upsert?: CourseUpsertWithWhereUniqueWithoutProcessInput | CourseUpsertWithWhereUniqueWithoutProcessInput[]
    createMany?: CourseCreateManyProcessInputEnvelope
    set?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
    disconnect?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
    delete?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
    connect?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
    update?: CourseUpdateWithWhereUniqueWithoutProcessInput | CourseUpdateWithWhereUniqueWithoutProcessInput[]
    updateMany?: CourseUpdateManyWithWhereWithoutProcessInput | CourseUpdateManyWithWhereWithoutProcessInput[]
    deleteMany?: CourseScalarWhereInput | CourseScalarWhereInput[]
  }

  export type UserCourseCompletionUncheckedUpdateManyWithoutProcessNestedInput = {
    create?: XOR<UserCourseCompletionCreateWithoutProcessInput, UserCourseCompletionUncheckedCreateWithoutProcessInput> | UserCourseCompletionCreateWithoutProcessInput[] | UserCourseCompletionUncheckedCreateWithoutProcessInput[]
    connectOrCreate?: UserCourseCompletionCreateOrConnectWithoutProcessInput | UserCourseCompletionCreateOrConnectWithoutProcessInput[]
    upsert?: UserCourseCompletionUpsertWithWhereUniqueWithoutProcessInput | UserCourseCompletionUpsertWithWhereUniqueWithoutProcessInput[]
    createMany?: UserCourseCompletionCreateManyProcessInputEnvelope
    set?: UserCourseCompletionWhereUniqueInput | UserCourseCompletionWhereUniqueInput[]
    disconnect?: UserCourseCompletionWhereUniqueInput | UserCourseCompletionWhereUniqueInput[]
    delete?: UserCourseCompletionWhereUniqueInput | UserCourseCompletionWhereUniqueInput[]
    connect?: UserCourseCompletionWhereUniqueInput | UserCourseCompletionWhereUniqueInput[]
    update?: UserCourseCompletionUpdateWithWhereUniqueWithoutProcessInput | UserCourseCompletionUpdateWithWhereUniqueWithoutProcessInput[]
    updateMany?: UserCourseCompletionUpdateManyWithWhereWithoutProcessInput | UserCourseCompletionUpdateManyWithWhereWithoutProcessInput[]
    deleteMany?: UserCourseCompletionScalarWhereInput | UserCourseCompletionScalarWhereInput[]
  }

  export type ProcessDetailUncheckedUpdateManyWithoutProcessNestedInput = {
    create?: XOR<ProcessDetailCreateWithoutProcessInput, ProcessDetailUncheckedCreateWithoutProcessInput> | ProcessDetailCreateWithoutProcessInput[] | ProcessDetailUncheckedCreateWithoutProcessInput[]
    connectOrCreate?: ProcessDetailCreateOrConnectWithoutProcessInput | ProcessDetailCreateOrConnectWithoutProcessInput[]
    upsert?: ProcessDetailUpsertWithWhereUniqueWithoutProcessInput | ProcessDetailUpsertWithWhereUniqueWithoutProcessInput[]
    createMany?: ProcessDetailCreateManyProcessInputEnvelope
    set?: ProcessDetailWhereUniqueInput | ProcessDetailWhereUniqueInput[]
    disconnect?: ProcessDetailWhereUniqueInput | ProcessDetailWhereUniqueInput[]
    delete?: ProcessDetailWhereUniqueInput | ProcessDetailWhereUniqueInput[]
    connect?: ProcessDetailWhereUniqueInput | ProcessDetailWhereUniqueInput[]
    update?: ProcessDetailUpdateWithWhereUniqueWithoutProcessInput | ProcessDetailUpdateWithWhereUniqueWithoutProcessInput[]
    updateMany?: ProcessDetailUpdateManyWithWhereWithoutProcessInput | ProcessDetailUpdateManyWithWhereWithoutProcessInput[]
    deleteMany?: ProcessDetailScalarWhereInput | ProcessDetailScalarWhereInput[]
  }

  export type ProcessCreateNestedOneWithoutProcessDetailInput = {
    create?: XOR<ProcessCreateWithoutProcessDetailInput, ProcessUncheckedCreateWithoutProcessDetailInput>
    connectOrCreate?: ProcessCreateOrConnectWithoutProcessDetailInput
    connect?: ProcessWhereUniqueInput
  }

  export type ProcessBranchCreateNestedManyWithoutProcessDetailInput = {
    create?: XOR<ProcessBranchCreateWithoutProcessDetailInput, ProcessBranchUncheckedCreateWithoutProcessDetailInput> | ProcessBranchCreateWithoutProcessDetailInput[] | ProcessBranchUncheckedCreateWithoutProcessDetailInput[]
    connectOrCreate?: ProcessBranchCreateOrConnectWithoutProcessDetailInput | ProcessBranchCreateOrConnectWithoutProcessDetailInput[]
    createMany?: ProcessBranchCreateManyProcessDetailInputEnvelope
    connect?: ProcessBranchWhereUniqueInput | ProcessBranchWhereUniqueInput[]
  }

  export type ProcessMatCreateNestedManyWithoutProcessDetailInput = {
    create?: XOR<ProcessMatCreateWithoutProcessDetailInput, ProcessMatUncheckedCreateWithoutProcessDetailInput> | ProcessMatCreateWithoutProcessDetailInput[] | ProcessMatUncheckedCreateWithoutProcessDetailInput[]
    connectOrCreate?: ProcessMatCreateOrConnectWithoutProcessDetailInput | ProcessMatCreateOrConnectWithoutProcessDetailInput[]
    createMany?: ProcessMatCreateManyProcessDetailInputEnvelope
    connect?: ProcessMatWhereUniqueInput | ProcessMatWhereUniqueInput[]
  }

  export type ProcessBomCreateNestedManyWithoutProcessDetailInput = {
    create?: XOR<ProcessBomCreateWithoutProcessDetailInput, ProcessBomUncheckedCreateWithoutProcessDetailInput> | ProcessBomCreateWithoutProcessDetailInput[] | ProcessBomUncheckedCreateWithoutProcessDetailInput[]
    connectOrCreate?: ProcessBomCreateOrConnectWithoutProcessDetailInput | ProcessBomCreateOrConnectWithoutProcessDetailInput[]
    createMany?: ProcessBomCreateManyProcessDetailInputEnvelope
    connect?: ProcessBomWhereUniqueInput | ProcessBomWhereUniqueInput[]
  }

  export type ProcessBranchUncheckedCreateNestedManyWithoutProcessDetailInput = {
    create?: XOR<ProcessBranchCreateWithoutProcessDetailInput, ProcessBranchUncheckedCreateWithoutProcessDetailInput> | ProcessBranchCreateWithoutProcessDetailInput[] | ProcessBranchUncheckedCreateWithoutProcessDetailInput[]
    connectOrCreate?: ProcessBranchCreateOrConnectWithoutProcessDetailInput | ProcessBranchCreateOrConnectWithoutProcessDetailInput[]
    createMany?: ProcessBranchCreateManyProcessDetailInputEnvelope
    connect?: ProcessBranchWhereUniqueInput | ProcessBranchWhereUniqueInput[]
  }

  export type ProcessMatUncheckedCreateNestedManyWithoutProcessDetailInput = {
    create?: XOR<ProcessMatCreateWithoutProcessDetailInput, ProcessMatUncheckedCreateWithoutProcessDetailInput> | ProcessMatCreateWithoutProcessDetailInput[] | ProcessMatUncheckedCreateWithoutProcessDetailInput[]
    connectOrCreate?: ProcessMatCreateOrConnectWithoutProcessDetailInput | ProcessMatCreateOrConnectWithoutProcessDetailInput[]
    createMany?: ProcessMatCreateManyProcessDetailInputEnvelope
    connect?: ProcessMatWhereUniqueInput | ProcessMatWhereUniqueInput[]
  }

  export type ProcessBomUncheckedCreateNestedManyWithoutProcessDetailInput = {
    create?: XOR<ProcessBomCreateWithoutProcessDetailInput, ProcessBomUncheckedCreateWithoutProcessDetailInput> | ProcessBomCreateWithoutProcessDetailInput[] | ProcessBomUncheckedCreateWithoutProcessDetailInput[]
    connectOrCreate?: ProcessBomCreateOrConnectWithoutProcessDetailInput | ProcessBomCreateOrConnectWithoutProcessDetailInput[]
    createMany?: ProcessBomCreateManyProcessDetailInputEnvelope
    connect?: ProcessBomWhereUniqueInput | ProcessBomWhereUniqueInput[]
  }

  export type ProcessUpdateOneRequiredWithoutProcessDetailNestedInput = {
    create?: XOR<ProcessCreateWithoutProcessDetailInput, ProcessUncheckedCreateWithoutProcessDetailInput>
    connectOrCreate?: ProcessCreateOrConnectWithoutProcessDetailInput
    upsert?: ProcessUpsertWithoutProcessDetailInput
    connect?: ProcessWhereUniqueInput
    update?: XOR<XOR<ProcessUpdateToOneWithWhereWithoutProcessDetailInput, ProcessUpdateWithoutProcessDetailInput>, ProcessUncheckedUpdateWithoutProcessDetailInput>
  }

  export type ProcessBranchUpdateManyWithoutProcessDetailNestedInput = {
    create?: XOR<ProcessBranchCreateWithoutProcessDetailInput, ProcessBranchUncheckedCreateWithoutProcessDetailInput> | ProcessBranchCreateWithoutProcessDetailInput[] | ProcessBranchUncheckedCreateWithoutProcessDetailInput[]
    connectOrCreate?: ProcessBranchCreateOrConnectWithoutProcessDetailInput | ProcessBranchCreateOrConnectWithoutProcessDetailInput[]
    upsert?: ProcessBranchUpsertWithWhereUniqueWithoutProcessDetailInput | ProcessBranchUpsertWithWhereUniqueWithoutProcessDetailInput[]
    createMany?: ProcessBranchCreateManyProcessDetailInputEnvelope
    set?: ProcessBranchWhereUniqueInput | ProcessBranchWhereUniqueInput[]
    disconnect?: ProcessBranchWhereUniqueInput | ProcessBranchWhereUniqueInput[]
    delete?: ProcessBranchWhereUniqueInput | ProcessBranchWhereUniqueInput[]
    connect?: ProcessBranchWhereUniqueInput | ProcessBranchWhereUniqueInput[]
    update?: ProcessBranchUpdateWithWhereUniqueWithoutProcessDetailInput | ProcessBranchUpdateWithWhereUniqueWithoutProcessDetailInput[]
    updateMany?: ProcessBranchUpdateManyWithWhereWithoutProcessDetailInput | ProcessBranchUpdateManyWithWhereWithoutProcessDetailInput[]
    deleteMany?: ProcessBranchScalarWhereInput | ProcessBranchScalarWhereInput[]
  }

  export type ProcessMatUpdateManyWithoutProcessDetailNestedInput = {
    create?: XOR<ProcessMatCreateWithoutProcessDetailInput, ProcessMatUncheckedCreateWithoutProcessDetailInput> | ProcessMatCreateWithoutProcessDetailInput[] | ProcessMatUncheckedCreateWithoutProcessDetailInput[]
    connectOrCreate?: ProcessMatCreateOrConnectWithoutProcessDetailInput | ProcessMatCreateOrConnectWithoutProcessDetailInput[]
    upsert?: ProcessMatUpsertWithWhereUniqueWithoutProcessDetailInput | ProcessMatUpsertWithWhereUniqueWithoutProcessDetailInput[]
    createMany?: ProcessMatCreateManyProcessDetailInputEnvelope
    set?: ProcessMatWhereUniqueInput | ProcessMatWhereUniqueInput[]
    disconnect?: ProcessMatWhereUniqueInput | ProcessMatWhereUniqueInput[]
    delete?: ProcessMatWhereUniqueInput | ProcessMatWhereUniqueInput[]
    connect?: ProcessMatWhereUniqueInput | ProcessMatWhereUniqueInput[]
    update?: ProcessMatUpdateWithWhereUniqueWithoutProcessDetailInput | ProcessMatUpdateWithWhereUniqueWithoutProcessDetailInput[]
    updateMany?: ProcessMatUpdateManyWithWhereWithoutProcessDetailInput | ProcessMatUpdateManyWithWhereWithoutProcessDetailInput[]
    deleteMany?: ProcessMatScalarWhereInput | ProcessMatScalarWhereInput[]
  }

  export type ProcessBomUpdateManyWithoutProcessDetailNestedInput = {
    create?: XOR<ProcessBomCreateWithoutProcessDetailInput, ProcessBomUncheckedCreateWithoutProcessDetailInput> | ProcessBomCreateWithoutProcessDetailInput[] | ProcessBomUncheckedCreateWithoutProcessDetailInput[]
    connectOrCreate?: ProcessBomCreateOrConnectWithoutProcessDetailInput | ProcessBomCreateOrConnectWithoutProcessDetailInput[]
    upsert?: ProcessBomUpsertWithWhereUniqueWithoutProcessDetailInput | ProcessBomUpsertWithWhereUniqueWithoutProcessDetailInput[]
    createMany?: ProcessBomCreateManyProcessDetailInputEnvelope
    set?: ProcessBomWhereUniqueInput | ProcessBomWhereUniqueInput[]
    disconnect?: ProcessBomWhereUniqueInput | ProcessBomWhereUniqueInput[]
    delete?: ProcessBomWhereUniqueInput | ProcessBomWhereUniqueInput[]
    connect?: ProcessBomWhereUniqueInput | ProcessBomWhereUniqueInput[]
    update?: ProcessBomUpdateWithWhereUniqueWithoutProcessDetailInput | ProcessBomUpdateWithWhereUniqueWithoutProcessDetailInput[]
    updateMany?: ProcessBomUpdateManyWithWhereWithoutProcessDetailInput | ProcessBomUpdateManyWithWhereWithoutProcessDetailInput[]
    deleteMany?: ProcessBomScalarWhereInput | ProcessBomScalarWhereInput[]
  }

  export type ProcessBranchUncheckedUpdateManyWithoutProcessDetailNestedInput = {
    create?: XOR<ProcessBranchCreateWithoutProcessDetailInput, ProcessBranchUncheckedCreateWithoutProcessDetailInput> | ProcessBranchCreateWithoutProcessDetailInput[] | ProcessBranchUncheckedCreateWithoutProcessDetailInput[]
    connectOrCreate?: ProcessBranchCreateOrConnectWithoutProcessDetailInput | ProcessBranchCreateOrConnectWithoutProcessDetailInput[]
    upsert?: ProcessBranchUpsertWithWhereUniqueWithoutProcessDetailInput | ProcessBranchUpsertWithWhereUniqueWithoutProcessDetailInput[]
    createMany?: ProcessBranchCreateManyProcessDetailInputEnvelope
    set?: ProcessBranchWhereUniqueInput | ProcessBranchWhereUniqueInput[]
    disconnect?: ProcessBranchWhereUniqueInput | ProcessBranchWhereUniqueInput[]
    delete?: ProcessBranchWhereUniqueInput | ProcessBranchWhereUniqueInput[]
    connect?: ProcessBranchWhereUniqueInput | ProcessBranchWhereUniqueInput[]
    update?: ProcessBranchUpdateWithWhereUniqueWithoutProcessDetailInput | ProcessBranchUpdateWithWhereUniqueWithoutProcessDetailInput[]
    updateMany?: ProcessBranchUpdateManyWithWhereWithoutProcessDetailInput | ProcessBranchUpdateManyWithWhereWithoutProcessDetailInput[]
    deleteMany?: ProcessBranchScalarWhereInput | ProcessBranchScalarWhereInput[]
  }

  export type ProcessMatUncheckedUpdateManyWithoutProcessDetailNestedInput = {
    create?: XOR<ProcessMatCreateWithoutProcessDetailInput, ProcessMatUncheckedCreateWithoutProcessDetailInput> | ProcessMatCreateWithoutProcessDetailInput[] | ProcessMatUncheckedCreateWithoutProcessDetailInput[]
    connectOrCreate?: ProcessMatCreateOrConnectWithoutProcessDetailInput | ProcessMatCreateOrConnectWithoutProcessDetailInput[]
    upsert?: ProcessMatUpsertWithWhereUniqueWithoutProcessDetailInput | ProcessMatUpsertWithWhereUniqueWithoutProcessDetailInput[]
    createMany?: ProcessMatCreateManyProcessDetailInputEnvelope
    set?: ProcessMatWhereUniqueInput | ProcessMatWhereUniqueInput[]
    disconnect?: ProcessMatWhereUniqueInput | ProcessMatWhereUniqueInput[]
    delete?: ProcessMatWhereUniqueInput | ProcessMatWhereUniqueInput[]
    connect?: ProcessMatWhereUniqueInput | ProcessMatWhereUniqueInput[]
    update?: ProcessMatUpdateWithWhereUniqueWithoutProcessDetailInput | ProcessMatUpdateWithWhereUniqueWithoutProcessDetailInput[]
    updateMany?: ProcessMatUpdateManyWithWhereWithoutProcessDetailInput | ProcessMatUpdateManyWithWhereWithoutProcessDetailInput[]
    deleteMany?: ProcessMatScalarWhereInput | ProcessMatScalarWhereInput[]
  }

  export type ProcessBomUncheckedUpdateManyWithoutProcessDetailNestedInput = {
    create?: XOR<ProcessBomCreateWithoutProcessDetailInput, ProcessBomUncheckedCreateWithoutProcessDetailInput> | ProcessBomCreateWithoutProcessDetailInput[] | ProcessBomUncheckedCreateWithoutProcessDetailInput[]
    connectOrCreate?: ProcessBomCreateOrConnectWithoutProcessDetailInput | ProcessBomCreateOrConnectWithoutProcessDetailInput[]
    upsert?: ProcessBomUpsertWithWhereUniqueWithoutProcessDetailInput | ProcessBomUpsertWithWhereUniqueWithoutProcessDetailInput[]
    createMany?: ProcessBomCreateManyProcessDetailInputEnvelope
    set?: ProcessBomWhereUniqueInput | ProcessBomWhereUniqueInput[]
    disconnect?: ProcessBomWhereUniqueInput | ProcessBomWhereUniqueInput[]
    delete?: ProcessBomWhereUniqueInput | ProcessBomWhereUniqueInput[]
    connect?: ProcessBomWhereUniqueInput | ProcessBomWhereUniqueInput[]
    update?: ProcessBomUpdateWithWhereUniqueWithoutProcessDetailInput | ProcessBomUpdateWithWhereUniqueWithoutProcessDetailInput[]
    updateMany?: ProcessBomUpdateManyWithWhereWithoutProcessDetailInput | ProcessBomUpdateManyWithWhereWithoutProcessDetailInput[]
    deleteMany?: ProcessBomScalarWhereInput | ProcessBomScalarWhereInput[]
  }

  export type ProcessDetailCreateNestedOneWithoutProcessBranchInput = {
    create?: XOR<ProcessDetailCreateWithoutProcessBranchInput, ProcessDetailUncheckedCreateWithoutProcessBranchInput>
    connectOrCreate?: ProcessDetailCreateOrConnectWithoutProcessBranchInput
    connect?: ProcessDetailWhereUniqueInput
  }

  export type ProcessDetailUpdateOneRequiredWithoutProcessBranchNestedInput = {
    create?: XOR<ProcessDetailCreateWithoutProcessBranchInput, ProcessDetailUncheckedCreateWithoutProcessBranchInput>
    connectOrCreate?: ProcessDetailCreateOrConnectWithoutProcessBranchInput
    upsert?: ProcessDetailUpsertWithoutProcessBranchInput
    connect?: ProcessDetailWhereUniqueInput
    update?: XOR<XOR<ProcessDetailUpdateToOneWithWhereWithoutProcessBranchInput, ProcessDetailUpdateWithoutProcessBranchInput>, ProcessDetailUncheckedUpdateWithoutProcessBranchInput>
  }

  export type StockCreateNestedOneWithoutProcessMatInput = {
    create?: XOR<StockCreateWithoutProcessMatInput, StockUncheckedCreateWithoutProcessMatInput>
    connectOrCreate?: StockCreateOrConnectWithoutProcessMatInput
    connect?: StockWhereUniqueInput
  }

  export type ProcessDetailCreateNestedOneWithoutProcessMatInput = {
    create?: XOR<ProcessDetailCreateWithoutProcessMatInput, ProcessDetailUncheckedCreateWithoutProcessMatInput>
    connectOrCreate?: ProcessDetailCreateOrConnectWithoutProcessMatInput
    connect?: ProcessDetailWhereUniqueInput
  }

  export type StockUpdateOneRequiredWithoutProcessMatNestedInput = {
    create?: XOR<StockCreateWithoutProcessMatInput, StockUncheckedCreateWithoutProcessMatInput>
    connectOrCreate?: StockCreateOrConnectWithoutProcessMatInput
    upsert?: StockUpsertWithoutProcessMatInput
    connect?: StockWhereUniqueInput
    update?: XOR<XOR<StockUpdateToOneWithWhereWithoutProcessMatInput, StockUpdateWithoutProcessMatInput>, StockUncheckedUpdateWithoutProcessMatInput>
  }

  export type ProcessDetailUpdateOneRequiredWithoutProcessMatNestedInput = {
    create?: XOR<ProcessDetailCreateWithoutProcessMatInput, ProcessDetailUncheckedCreateWithoutProcessMatInput>
    connectOrCreate?: ProcessDetailCreateOrConnectWithoutProcessMatInput
    upsert?: ProcessDetailUpsertWithoutProcessMatInput
    connect?: ProcessDetailWhereUniqueInput
    update?: XOR<XOR<ProcessDetailUpdateToOneWithWhereWithoutProcessMatInput, ProcessDetailUpdateWithoutProcessMatInput>, ProcessDetailUncheckedUpdateWithoutProcessMatInput>
  }

  export type StockCreateNestedOneWithoutProcessBomInput = {
    create?: XOR<StockCreateWithoutProcessBomInput, StockUncheckedCreateWithoutProcessBomInput>
    connectOrCreate?: StockCreateOrConnectWithoutProcessBomInput
    connect?: StockWhereUniqueInput
  }

  export type ProcessDetailCreateNestedOneWithoutProcessBomInput = {
    create?: XOR<ProcessDetailCreateWithoutProcessBomInput, ProcessDetailUncheckedCreateWithoutProcessBomInput>
    connectOrCreate?: ProcessDetailCreateOrConnectWithoutProcessBomInput
    connect?: ProcessDetailWhereUniqueInput
  }

  export type StockUpdateOneRequiredWithoutProcessBomNestedInput = {
    create?: XOR<StockCreateWithoutProcessBomInput, StockUncheckedCreateWithoutProcessBomInput>
    connectOrCreate?: StockCreateOrConnectWithoutProcessBomInput
    upsert?: StockUpsertWithoutProcessBomInput
    connect?: StockWhereUniqueInput
    update?: XOR<XOR<StockUpdateToOneWithWhereWithoutProcessBomInput, StockUpdateWithoutProcessBomInput>, StockUncheckedUpdateWithoutProcessBomInput>
  }

  export type ProcessDetailUpdateOneRequiredWithoutProcessBomNestedInput = {
    create?: XOR<ProcessDetailCreateWithoutProcessBomInput, ProcessDetailUncheckedCreateWithoutProcessBomInput>
    connectOrCreate?: ProcessDetailCreateOrConnectWithoutProcessBomInput
    upsert?: ProcessDetailUpsertWithoutProcessBomInput
    connect?: ProcessDetailWhereUniqueInput
    update?: XOR<XOR<ProcessDetailUpdateToOneWithWhereWithoutProcessBomInput, ProcessDetailUpdateWithoutProcessBomInput>, ProcessDetailUncheckedUpdateWithoutProcessBomInput>
  }

  export type UserCreateNestedOneWithoutProjectInput = {
    create?: XOR<UserCreateWithoutProjectInput, UserUncheckedCreateWithoutProjectInput>
    connectOrCreate?: UserCreateOrConnectWithoutProjectInput
    connect?: UserWhereUniqueInput
  }

  export type ProjectDetailCreateNestedManyWithoutProjectInput = {
    create?: XOR<ProjectDetailCreateWithoutProjectInput, ProjectDetailUncheckedCreateWithoutProjectInput> | ProjectDetailCreateWithoutProjectInput[] | ProjectDetailUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ProjectDetailCreateOrConnectWithoutProjectInput | ProjectDetailCreateOrConnectWithoutProjectInput[]
    createMany?: ProjectDetailCreateManyProjectInputEnvelope
    connect?: ProjectDetailWhereUniqueInput | ProjectDetailWhereUniqueInput[]
  }

  export type ProjectDetailUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<ProjectDetailCreateWithoutProjectInput, ProjectDetailUncheckedCreateWithoutProjectInput> | ProjectDetailCreateWithoutProjectInput[] | ProjectDetailUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ProjectDetailCreateOrConnectWithoutProjectInput | ProjectDetailCreateOrConnectWithoutProjectInput[]
    createMany?: ProjectDetailCreateManyProjectInputEnvelope
    connect?: ProjectDetailWhereUniqueInput | ProjectDetailWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutProjectNestedInput = {
    create?: XOR<UserCreateWithoutProjectInput, UserUncheckedCreateWithoutProjectInput>
    connectOrCreate?: UserCreateOrConnectWithoutProjectInput
    upsert?: UserUpsertWithoutProjectInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutProjectInput, UserUpdateWithoutProjectInput>, UserUncheckedUpdateWithoutProjectInput>
  }

  export type ProjectDetailUpdateManyWithoutProjectNestedInput = {
    create?: XOR<ProjectDetailCreateWithoutProjectInput, ProjectDetailUncheckedCreateWithoutProjectInput> | ProjectDetailCreateWithoutProjectInput[] | ProjectDetailUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ProjectDetailCreateOrConnectWithoutProjectInput | ProjectDetailCreateOrConnectWithoutProjectInput[]
    upsert?: ProjectDetailUpsertWithWhereUniqueWithoutProjectInput | ProjectDetailUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: ProjectDetailCreateManyProjectInputEnvelope
    set?: ProjectDetailWhereUniqueInput | ProjectDetailWhereUniqueInput[]
    disconnect?: ProjectDetailWhereUniqueInput | ProjectDetailWhereUniqueInput[]
    delete?: ProjectDetailWhereUniqueInput | ProjectDetailWhereUniqueInput[]
    connect?: ProjectDetailWhereUniqueInput | ProjectDetailWhereUniqueInput[]
    update?: ProjectDetailUpdateWithWhereUniqueWithoutProjectInput | ProjectDetailUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: ProjectDetailUpdateManyWithWhereWithoutProjectInput | ProjectDetailUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: ProjectDetailScalarWhereInput | ProjectDetailScalarWhereInput[]
  }

  export type ProjectDetailUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<ProjectDetailCreateWithoutProjectInput, ProjectDetailUncheckedCreateWithoutProjectInput> | ProjectDetailCreateWithoutProjectInput[] | ProjectDetailUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ProjectDetailCreateOrConnectWithoutProjectInput | ProjectDetailCreateOrConnectWithoutProjectInput[]
    upsert?: ProjectDetailUpsertWithWhereUniqueWithoutProjectInput | ProjectDetailUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: ProjectDetailCreateManyProjectInputEnvelope
    set?: ProjectDetailWhereUniqueInput | ProjectDetailWhereUniqueInput[]
    disconnect?: ProjectDetailWhereUniqueInput | ProjectDetailWhereUniqueInput[]
    delete?: ProjectDetailWhereUniqueInput | ProjectDetailWhereUniqueInput[]
    connect?: ProjectDetailWhereUniqueInput | ProjectDetailWhereUniqueInput[]
    update?: ProjectDetailUpdateWithWhereUniqueWithoutProjectInput | ProjectDetailUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: ProjectDetailUpdateManyWithWhereWithoutProjectInput | ProjectDetailUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: ProjectDetailScalarWhereInput | ProjectDetailScalarWhereInput[]
  }

  export type ProjectCreateNestedOneWithoutProjectDetailInput = {
    create?: XOR<ProjectCreateWithoutProjectDetailInput, ProjectUncheckedCreateWithoutProjectDetailInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutProjectDetailInput
    connect?: ProjectWhereUniqueInput
  }

  export type ProjectBranchCreateNestedManyWithoutProjectDetailInput = {
    create?: XOR<ProjectBranchCreateWithoutProjectDetailInput, ProjectBranchUncheckedCreateWithoutProjectDetailInput> | ProjectBranchCreateWithoutProjectDetailInput[] | ProjectBranchUncheckedCreateWithoutProjectDetailInput[]
    connectOrCreate?: ProjectBranchCreateOrConnectWithoutProjectDetailInput | ProjectBranchCreateOrConnectWithoutProjectDetailInput[]
    createMany?: ProjectBranchCreateManyProjectDetailInputEnvelope
    connect?: ProjectBranchWhereUniqueInput | ProjectBranchWhereUniqueInput[]
  }

  export type ProjectMatCreateNestedManyWithoutProjectDetailInput = {
    create?: XOR<ProjectMatCreateWithoutProjectDetailInput, ProjectMatUncheckedCreateWithoutProjectDetailInput> | ProjectMatCreateWithoutProjectDetailInput[] | ProjectMatUncheckedCreateWithoutProjectDetailInput[]
    connectOrCreate?: ProjectMatCreateOrConnectWithoutProjectDetailInput | ProjectMatCreateOrConnectWithoutProjectDetailInput[]
    createMany?: ProjectMatCreateManyProjectDetailInputEnvelope
    connect?: ProjectMatWhereUniqueInput | ProjectMatWhereUniqueInput[]
  }

  export type ProjectBomCreateNestedManyWithoutProjectDetailInput = {
    create?: XOR<ProjectBomCreateWithoutProjectDetailInput, ProjectBomUncheckedCreateWithoutProjectDetailInput> | ProjectBomCreateWithoutProjectDetailInput[] | ProjectBomUncheckedCreateWithoutProjectDetailInput[]
    connectOrCreate?: ProjectBomCreateOrConnectWithoutProjectDetailInput | ProjectBomCreateOrConnectWithoutProjectDetailInput[]
    createMany?: ProjectBomCreateManyProjectDetailInputEnvelope
    connect?: ProjectBomWhereUniqueInput | ProjectBomWhereUniqueInput[]
  }

  export type ProjectResUserCreateNestedManyWithoutProjectDetailInput = {
    create?: XOR<ProjectResUserCreateWithoutProjectDetailInput, ProjectResUserUncheckedCreateWithoutProjectDetailInput> | ProjectResUserCreateWithoutProjectDetailInput[] | ProjectResUserUncheckedCreateWithoutProjectDetailInput[]
    connectOrCreate?: ProjectResUserCreateOrConnectWithoutProjectDetailInput | ProjectResUserCreateOrConnectWithoutProjectDetailInput[]
    createMany?: ProjectResUserCreateManyProjectDetailInputEnvelope
    connect?: ProjectResUserWhereUniqueInput | ProjectResUserWhereUniqueInput[]
  }

  export type ProjectBranchUncheckedCreateNestedManyWithoutProjectDetailInput = {
    create?: XOR<ProjectBranchCreateWithoutProjectDetailInput, ProjectBranchUncheckedCreateWithoutProjectDetailInput> | ProjectBranchCreateWithoutProjectDetailInput[] | ProjectBranchUncheckedCreateWithoutProjectDetailInput[]
    connectOrCreate?: ProjectBranchCreateOrConnectWithoutProjectDetailInput | ProjectBranchCreateOrConnectWithoutProjectDetailInput[]
    createMany?: ProjectBranchCreateManyProjectDetailInputEnvelope
    connect?: ProjectBranchWhereUniqueInput | ProjectBranchWhereUniqueInput[]
  }

  export type ProjectMatUncheckedCreateNestedManyWithoutProjectDetailInput = {
    create?: XOR<ProjectMatCreateWithoutProjectDetailInput, ProjectMatUncheckedCreateWithoutProjectDetailInput> | ProjectMatCreateWithoutProjectDetailInput[] | ProjectMatUncheckedCreateWithoutProjectDetailInput[]
    connectOrCreate?: ProjectMatCreateOrConnectWithoutProjectDetailInput | ProjectMatCreateOrConnectWithoutProjectDetailInput[]
    createMany?: ProjectMatCreateManyProjectDetailInputEnvelope
    connect?: ProjectMatWhereUniqueInput | ProjectMatWhereUniqueInput[]
  }

  export type ProjectBomUncheckedCreateNestedManyWithoutProjectDetailInput = {
    create?: XOR<ProjectBomCreateWithoutProjectDetailInput, ProjectBomUncheckedCreateWithoutProjectDetailInput> | ProjectBomCreateWithoutProjectDetailInput[] | ProjectBomUncheckedCreateWithoutProjectDetailInput[]
    connectOrCreate?: ProjectBomCreateOrConnectWithoutProjectDetailInput | ProjectBomCreateOrConnectWithoutProjectDetailInput[]
    createMany?: ProjectBomCreateManyProjectDetailInputEnvelope
    connect?: ProjectBomWhereUniqueInput | ProjectBomWhereUniqueInput[]
  }

  export type ProjectResUserUncheckedCreateNestedManyWithoutProjectDetailInput = {
    create?: XOR<ProjectResUserCreateWithoutProjectDetailInput, ProjectResUserUncheckedCreateWithoutProjectDetailInput> | ProjectResUserCreateWithoutProjectDetailInput[] | ProjectResUserUncheckedCreateWithoutProjectDetailInput[]
    connectOrCreate?: ProjectResUserCreateOrConnectWithoutProjectDetailInput | ProjectResUserCreateOrConnectWithoutProjectDetailInput[]
    createMany?: ProjectResUserCreateManyProjectDetailInputEnvelope
    connect?: ProjectResUserWhereUniqueInput | ProjectResUserWhereUniqueInput[]
  }

  export type ProjectUpdateOneRequiredWithoutProjectDetailNestedInput = {
    create?: XOR<ProjectCreateWithoutProjectDetailInput, ProjectUncheckedCreateWithoutProjectDetailInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutProjectDetailInput
    upsert?: ProjectUpsertWithoutProjectDetailInput
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutProjectDetailInput, ProjectUpdateWithoutProjectDetailInput>, ProjectUncheckedUpdateWithoutProjectDetailInput>
  }

  export type ProjectBranchUpdateManyWithoutProjectDetailNestedInput = {
    create?: XOR<ProjectBranchCreateWithoutProjectDetailInput, ProjectBranchUncheckedCreateWithoutProjectDetailInput> | ProjectBranchCreateWithoutProjectDetailInput[] | ProjectBranchUncheckedCreateWithoutProjectDetailInput[]
    connectOrCreate?: ProjectBranchCreateOrConnectWithoutProjectDetailInput | ProjectBranchCreateOrConnectWithoutProjectDetailInput[]
    upsert?: ProjectBranchUpsertWithWhereUniqueWithoutProjectDetailInput | ProjectBranchUpsertWithWhereUniqueWithoutProjectDetailInput[]
    createMany?: ProjectBranchCreateManyProjectDetailInputEnvelope
    set?: ProjectBranchWhereUniqueInput | ProjectBranchWhereUniqueInput[]
    disconnect?: ProjectBranchWhereUniqueInput | ProjectBranchWhereUniqueInput[]
    delete?: ProjectBranchWhereUniqueInput | ProjectBranchWhereUniqueInput[]
    connect?: ProjectBranchWhereUniqueInput | ProjectBranchWhereUniqueInput[]
    update?: ProjectBranchUpdateWithWhereUniqueWithoutProjectDetailInput | ProjectBranchUpdateWithWhereUniqueWithoutProjectDetailInput[]
    updateMany?: ProjectBranchUpdateManyWithWhereWithoutProjectDetailInput | ProjectBranchUpdateManyWithWhereWithoutProjectDetailInput[]
    deleteMany?: ProjectBranchScalarWhereInput | ProjectBranchScalarWhereInput[]
  }

  export type ProjectMatUpdateManyWithoutProjectDetailNestedInput = {
    create?: XOR<ProjectMatCreateWithoutProjectDetailInput, ProjectMatUncheckedCreateWithoutProjectDetailInput> | ProjectMatCreateWithoutProjectDetailInput[] | ProjectMatUncheckedCreateWithoutProjectDetailInput[]
    connectOrCreate?: ProjectMatCreateOrConnectWithoutProjectDetailInput | ProjectMatCreateOrConnectWithoutProjectDetailInput[]
    upsert?: ProjectMatUpsertWithWhereUniqueWithoutProjectDetailInput | ProjectMatUpsertWithWhereUniqueWithoutProjectDetailInput[]
    createMany?: ProjectMatCreateManyProjectDetailInputEnvelope
    set?: ProjectMatWhereUniqueInput | ProjectMatWhereUniqueInput[]
    disconnect?: ProjectMatWhereUniqueInput | ProjectMatWhereUniqueInput[]
    delete?: ProjectMatWhereUniqueInput | ProjectMatWhereUniqueInput[]
    connect?: ProjectMatWhereUniqueInput | ProjectMatWhereUniqueInput[]
    update?: ProjectMatUpdateWithWhereUniqueWithoutProjectDetailInput | ProjectMatUpdateWithWhereUniqueWithoutProjectDetailInput[]
    updateMany?: ProjectMatUpdateManyWithWhereWithoutProjectDetailInput | ProjectMatUpdateManyWithWhereWithoutProjectDetailInput[]
    deleteMany?: ProjectMatScalarWhereInput | ProjectMatScalarWhereInput[]
  }

  export type ProjectBomUpdateManyWithoutProjectDetailNestedInput = {
    create?: XOR<ProjectBomCreateWithoutProjectDetailInput, ProjectBomUncheckedCreateWithoutProjectDetailInput> | ProjectBomCreateWithoutProjectDetailInput[] | ProjectBomUncheckedCreateWithoutProjectDetailInput[]
    connectOrCreate?: ProjectBomCreateOrConnectWithoutProjectDetailInput | ProjectBomCreateOrConnectWithoutProjectDetailInput[]
    upsert?: ProjectBomUpsertWithWhereUniqueWithoutProjectDetailInput | ProjectBomUpsertWithWhereUniqueWithoutProjectDetailInput[]
    createMany?: ProjectBomCreateManyProjectDetailInputEnvelope
    set?: ProjectBomWhereUniqueInput | ProjectBomWhereUniqueInput[]
    disconnect?: ProjectBomWhereUniqueInput | ProjectBomWhereUniqueInput[]
    delete?: ProjectBomWhereUniqueInput | ProjectBomWhereUniqueInput[]
    connect?: ProjectBomWhereUniqueInput | ProjectBomWhereUniqueInput[]
    update?: ProjectBomUpdateWithWhereUniqueWithoutProjectDetailInput | ProjectBomUpdateWithWhereUniqueWithoutProjectDetailInput[]
    updateMany?: ProjectBomUpdateManyWithWhereWithoutProjectDetailInput | ProjectBomUpdateManyWithWhereWithoutProjectDetailInput[]
    deleteMany?: ProjectBomScalarWhereInput | ProjectBomScalarWhereInput[]
  }

  export type ProjectResUserUpdateManyWithoutProjectDetailNestedInput = {
    create?: XOR<ProjectResUserCreateWithoutProjectDetailInput, ProjectResUserUncheckedCreateWithoutProjectDetailInput> | ProjectResUserCreateWithoutProjectDetailInput[] | ProjectResUserUncheckedCreateWithoutProjectDetailInput[]
    connectOrCreate?: ProjectResUserCreateOrConnectWithoutProjectDetailInput | ProjectResUserCreateOrConnectWithoutProjectDetailInput[]
    upsert?: ProjectResUserUpsertWithWhereUniqueWithoutProjectDetailInput | ProjectResUserUpsertWithWhereUniqueWithoutProjectDetailInput[]
    createMany?: ProjectResUserCreateManyProjectDetailInputEnvelope
    set?: ProjectResUserWhereUniqueInput | ProjectResUserWhereUniqueInput[]
    disconnect?: ProjectResUserWhereUniqueInput | ProjectResUserWhereUniqueInput[]
    delete?: ProjectResUserWhereUniqueInput | ProjectResUserWhereUniqueInput[]
    connect?: ProjectResUserWhereUniqueInput | ProjectResUserWhereUniqueInput[]
    update?: ProjectResUserUpdateWithWhereUniqueWithoutProjectDetailInput | ProjectResUserUpdateWithWhereUniqueWithoutProjectDetailInput[]
    updateMany?: ProjectResUserUpdateManyWithWhereWithoutProjectDetailInput | ProjectResUserUpdateManyWithWhereWithoutProjectDetailInput[]
    deleteMany?: ProjectResUserScalarWhereInput | ProjectResUserScalarWhereInput[]
  }

  export type ProjectBranchUncheckedUpdateManyWithoutProjectDetailNestedInput = {
    create?: XOR<ProjectBranchCreateWithoutProjectDetailInput, ProjectBranchUncheckedCreateWithoutProjectDetailInput> | ProjectBranchCreateWithoutProjectDetailInput[] | ProjectBranchUncheckedCreateWithoutProjectDetailInput[]
    connectOrCreate?: ProjectBranchCreateOrConnectWithoutProjectDetailInput | ProjectBranchCreateOrConnectWithoutProjectDetailInput[]
    upsert?: ProjectBranchUpsertWithWhereUniqueWithoutProjectDetailInput | ProjectBranchUpsertWithWhereUniqueWithoutProjectDetailInput[]
    createMany?: ProjectBranchCreateManyProjectDetailInputEnvelope
    set?: ProjectBranchWhereUniqueInput | ProjectBranchWhereUniqueInput[]
    disconnect?: ProjectBranchWhereUniqueInput | ProjectBranchWhereUniqueInput[]
    delete?: ProjectBranchWhereUniqueInput | ProjectBranchWhereUniqueInput[]
    connect?: ProjectBranchWhereUniqueInput | ProjectBranchWhereUniqueInput[]
    update?: ProjectBranchUpdateWithWhereUniqueWithoutProjectDetailInput | ProjectBranchUpdateWithWhereUniqueWithoutProjectDetailInput[]
    updateMany?: ProjectBranchUpdateManyWithWhereWithoutProjectDetailInput | ProjectBranchUpdateManyWithWhereWithoutProjectDetailInput[]
    deleteMany?: ProjectBranchScalarWhereInput | ProjectBranchScalarWhereInput[]
  }

  export type ProjectMatUncheckedUpdateManyWithoutProjectDetailNestedInput = {
    create?: XOR<ProjectMatCreateWithoutProjectDetailInput, ProjectMatUncheckedCreateWithoutProjectDetailInput> | ProjectMatCreateWithoutProjectDetailInput[] | ProjectMatUncheckedCreateWithoutProjectDetailInput[]
    connectOrCreate?: ProjectMatCreateOrConnectWithoutProjectDetailInput | ProjectMatCreateOrConnectWithoutProjectDetailInput[]
    upsert?: ProjectMatUpsertWithWhereUniqueWithoutProjectDetailInput | ProjectMatUpsertWithWhereUniqueWithoutProjectDetailInput[]
    createMany?: ProjectMatCreateManyProjectDetailInputEnvelope
    set?: ProjectMatWhereUniqueInput | ProjectMatWhereUniqueInput[]
    disconnect?: ProjectMatWhereUniqueInput | ProjectMatWhereUniqueInput[]
    delete?: ProjectMatWhereUniqueInput | ProjectMatWhereUniqueInput[]
    connect?: ProjectMatWhereUniqueInput | ProjectMatWhereUniqueInput[]
    update?: ProjectMatUpdateWithWhereUniqueWithoutProjectDetailInput | ProjectMatUpdateWithWhereUniqueWithoutProjectDetailInput[]
    updateMany?: ProjectMatUpdateManyWithWhereWithoutProjectDetailInput | ProjectMatUpdateManyWithWhereWithoutProjectDetailInput[]
    deleteMany?: ProjectMatScalarWhereInput | ProjectMatScalarWhereInput[]
  }

  export type ProjectBomUncheckedUpdateManyWithoutProjectDetailNestedInput = {
    create?: XOR<ProjectBomCreateWithoutProjectDetailInput, ProjectBomUncheckedCreateWithoutProjectDetailInput> | ProjectBomCreateWithoutProjectDetailInput[] | ProjectBomUncheckedCreateWithoutProjectDetailInput[]
    connectOrCreate?: ProjectBomCreateOrConnectWithoutProjectDetailInput | ProjectBomCreateOrConnectWithoutProjectDetailInput[]
    upsert?: ProjectBomUpsertWithWhereUniqueWithoutProjectDetailInput | ProjectBomUpsertWithWhereUniqueWithoutProjectDetailInput[]
    createMany?: ProjectBomCreateManyProjectDetailInputEnvelope
    set?: ProjectBomWhereUniqueInput | ProjectBomWhereUniqueInput[]
    disconnect?: ProjectBomWhereUniqueInput | ProjectBomWhereUniqueInput[]
    delete?: ProjectBomWhereUniqueInput | ProjectBomWhereUniqueInput[]
    connect?: ProjectBomWhereUniqueInput | ProjectBomWhereUniqueInput[]
    update?: ProjectBomUpdateWithWhereUniqueWithoutProjectDetailInput | ProjectBomUpdateWithWhereUniqueWithoutProjectDetailInput[]
    updateMany?: ProjectBomUpdateManyWithWhereWithoutProjectDetailInput | ProjectBomUpdateManyWithWhereWithoutProjectDetailInput[]
    deleteMany?: ProjectBomScalarWhereInput | ProjectBomScalarWhereInput[]
  }

  export type ProjectResUserUncheckedUpdateManyWithoutProjectDetailNestedInput = {
    create?: XOR<ProjectResUserCreateWithoutProjectDetailInput, ProjectResUserUncheckedCreateWithoutProjectDetailInput> | ProjectResUserCreateWithoutProjectDetailInput[] | ProjectResUserUncheckedCreateWithoutProjectDetailInput[]
    connectOrCreate?: ProjectResUserCreateOrConnectWithoutProjectDetailInput | ProjectResUserCreateOrConnectWithoutProjectDetailInput[]
    upsert?: ProjectResUserUpsertWithWhereUniqueWithoutProjectDetailInput | ProjectResUserUpsertWithWhereUniqueWithoutProjectDetailInput[]
    createMany?: ProjectResUserCreateManyProjectDetailInputEnvelope
    set?: ProjectResUserWhereUniqueInput | ProjectResUserWhereUniqueInput[]
    disconnect?: ProjectResUserWhereUniqueInput | ProjectResUserWhereUniqueInput[]
    delete?: ProjectResUserWhereUniqueInput | ProjectResUserWhereUniqueInput[]
    connect?: ProjectResUserWhereUniqueInput | ProjectResUserWhereUniqueInput[]
    update?: ProjectResUserUpdateWithWhereUniqueWithoutProjectDetailInput | ProjectResUserUpdateWithWhereUniqueWithoutProjectDetailInput[]
    updateMany?: ProjectResUserUpdateManyWithWhereWithoutProjectDetailInput | ProjectResUserUpdateManyWithWhereWithoutProjectDetailInput[]
    deleteMany?: ProjectResUserScalarWhereInput | ProjectResUserScalarWhereInput[]
  }

  export type ProjectDetailCreateNestedOneWithoutProjectBranchInput = {
    create?: XOR<ProjectDetailCreateWithoutProjectBranchInput, ProjectDetailUncheckedCreateWithoutProjectBranchInput>
    connectOrCreate?: ProjectDetailCreateOrConnectWithoutProjectBranchInput
    connect?: ProjectDetailWhereUniqueInput
  }

  export type ProjectDetailUpdateOneRequiredWithoutProjectBranchNestedInput = {
    create?: XOR<ProjectDetailCreateWithoutProjectBranchInput, ProjectDetailUncheckedCreateWithoutProjectBranchInput>
    connectOrCreate?: ProjectDetailCreateOrConnectWithoutProjectBranchInput
    upsert?: ProjectDetailUpsertWithoutProjectBranchInput
    connect?: ProjectDetailWhereUniqueInput
    update?: XOR<XOR<ProjectDetailUpdateToOneWithWhereWithoutProjectBranchInput, ProjectDetailUpdateWithoutProjectBranchInput>, ProjectDetailUncheckedUpdateWithoutProjectBranchInput>
  }

  export type StockCreateNestedOneWithoutProjectMatInput = {
    create?: XOR<StockCreateWithoutProjectMatInput, StockUncheckedCreateWithoutProjectMatInput>
    connectOrCreate?: StockCreateOrConnectWithoutProjectMatInput
    connect?: StockWhereUniqueInput
  }

  export type ProjectDetailCreateNestedOneWithoutProjectMatInput = {
    create?: XOR<ProjectDetailCreateWithoutProjectMatInput, ProjectDetailUncheckedCreateWithoutProjectMatInput>
    connectOrCreate?: ProjectDetailCreateOrConnectWithoutProjectMatInput
    connect?: ProjectDetailWhereUniqueInput
  }

  export type StockUpdateOneRequiredWithoutProjectMatNestedInput = {
    create?: XOR<StockCreateWithoutProjectMatInput, StockUncheckedCreateWithoutProjectMatInput>
    connectOrCreate?: StockCreateOrConnectWithoutProjectMatInput
    upsert?: StockUpsertWithoutProjectMatInput
    connect?: StockWhereUniqueInput
    update?: XOR<XOR<StockUpdateToOneWithWhereWithoutProjectMatInput, StockUpdateWithoutProjectMatInput>, StockUncheckedUpdateWithoutProjectMatInput>
  }

  export type ProjectDetailUpdateOneRequiredWithoutProjectMatNestedInput = {
    create?: XOR<ProjectDetailCreateWithoutProjectMatInput, ProjectDetailUncheckedCreateWithoutProjectMatInput>
    connectOrCreate?: ProjectDetailCreateOrConnectWithoutProjectMatInput
    upsert?: ProjectDetailUpsertWithoutProjectMatInput
    connect?: ProjectDetailWhereUniqueInput
    update?: XOR<XOR<ProjectDetailUpdateToOneWithWhereWithoutProjectMatInput, ProjectDetailUpdateWithoutProjectMatInput>, ProjectDetailUncheckedUpdateWithoutProjectMatInput>
  }

  export type StockCreateNestedOneWithoutProjectBomInput = {
    create?: XOR<StockCreateWithoutProjectBomInput, StockUncheckedCreateWithoutProjectBomInput>
    connectOrCreate?: StockCreateOrConnectWithoutProjectBomInput
    connect?: StockWhereUniqueInput
  }

  export type ProjectDetailCreateNestedOneWithoutProjectBomInput = {
    create?: XOR<ProjectDetailCreateWithoutProjectBomInput, ProjectDetailUncheckedCreateWithoutProjectBomInput>
    connectOrCreate?: ProjectDetailCreateOrConnectWithoutProjectBomInput
    connect?: ProjectDetailWhereUniqueInput
  }

  export type StockUpdateOneRequiredWithoutProjectBomNestedInput = {
    create?: XOR<StockCreateWithoutProjectBomInput, StockUncheckedCreateWithoutProjectBomInput>
    connectOrCreate?: StockCreateOrConnectWithoutProjectBomInput
    upsert?: StockUpsertWithoutProjectBomInput
    connect?: StockWhereUniqueInput
    update?: XOR<XOR<StockUpdateToOneWithWhereWithoutProjectBomInput, StockUpdateWithoutProjectBomInput>, StockUncheckedUpdateWithoutProjectBomInput>
  }

  export type ProjectDetailUpdateOneRequiredWithoutProjectBomNestedInput = {
    create?: XOR<ProjectDetailCreateWithoutProjectBomInput, ProjectDetailUncheckedCreateWithoutProjectBomInput>
    connectOrCreate?: ProjectDetailCreateOrConnectWithoutProjectBomInput
    upsert?: ProjectDetailUpsertWithoutProjectBomInput
    connect?: ProjectDetailWhereUniqueInput
    update?: XOR<XOR<ProjectDetailUpdateToOneWithWhereWithoutProjectBomInput, ProjectDetailUpdateWithoutProjectBomInput>, ProjectDetailUncheckedUpdateWithoutProjectBomInput>
  }

  export type ProjectDetailCreateNestedOneWithoutProjectResUserInput = {
    create?: XOR<ProjectDetailCreateWithoutProjectResUserInput, ProjectDetailUncheckedCreateWithoutProjectResUserInput>
    connectOrCreate?: ProjectDetailCreateOrConnectWithoutProjectResUserInput
    connect?: ProjectDetailWhereUniqueInput
  }

  export type ProjectDetailUpdateOneRequiredWithoutProjectResUserNestedInput = {
    create?: XOR<ProjectDetailCreateWithoutProjectResUserInput, ProjectDetailUncheckedCreateWithoutProjectResUserInput>
    connectOrCreate?: ProjectDetailCreateOrConnectWithoutProjectResUserInput
    upsert?: ProjectDetailUpsertWithoutProjectResUserInput
    connect?: ProjectDetailWhereUniqueInput
    update?: XOR<XOR<ProjectDetailUpdateToOneWithWhereWithoutProjectResUserInput, ProjectDetailUpdateWithoutProjectResUserInput>, ProjectDetailUncheckedUpdateWithoutProjectResUserInput>
  }

  export type ProcessMatCreateNestedManyWithoutStockInput = {
    create?: XOR<ProcessMatCreateWithoutStockInput, ProcessMatUncheckedCreateWithoutStockInput> | ProcessMatCreateWithoutStockInput[] | ProcessMatUncheckedCreateWithoutStockInput[]
    connectOrCreate?: ProcessMatCreateOrConnectWithoutStockInput | ProcessMatCreateOrConnectWithoutStockInput[]
    createMany?: ProcessMatCreateManyStockInputEnvelope
    connect?: ProcessMatWhereUniqueInput | ProcessMatWhereUniqueInput[]
  }

  export type ProcessBomCreateNestedManyWithoutStockInput = {
    create?: XOR<ProcessBomCreateWithoutStockInput, ProcessBomUncheckedCreateWithoutStockInput> | ProcessBomCreateWithoutStockInput[] | ProcessBomUncheckedCreateWithoutStockInput[]
    connectOrCreate?: ProcessBomCreateOrConnectWithoutStockInput | ProcessBomCreateOrConnectWithoutStockInput[]
    createMany?: ProcessBomCreateManyStockInputEnvelope
    connect?: ProcessBomWhereUniqueInput | ProcessBomWhereUniqueInput[]
  }

  export type ProjectMatCreateNestedManyWithoutStockInput = {
    create?: XOR<ProjectMatCreateWithoutStockInput, ProjectMatUncheckedCreateWithoutStockInput> | ProjectMatCreateWithoutStockInput[] | ProjectMatUncheckedCreateWithoutStockInput[]
    connectOrCreate?: ProjectMatCreateOrConnectWithoutStockInput | ProjectMatCreateOrConnectWithoutStockInput[]
    createMany?: ProjectMatCreateManyStockInputEnvelope
    connect?: ProjectMatWhereUniqueInput | ProjectMatWhereUniqueInput[]
  }

  export type ProjectBomCreateNestedManyWithoutStockInput = {
    create?: XOR<ProjectBomCreateWithoutStockInput, ProjectBomUncheckedCreateWithoutStockInput> | ProjectBomCreateWithoutStockInput[] | ProjectBomUncheckedCreateWithoutStockInput[]
    connectOrCreate?: ProjectBomCreateOrConnectWithoutStockInput | ProjectBomCreateOrConnectWithoutStockInput[]
    createMany?: ProjectBomCreateManyStockInputEnvelope
    connect?: ProjectBomWhereUniqueInput | ProjectBomWhereUniqueInput[]
  }

  export type ProcessMatUncheckedCreateNestedManyWithoutStockInput = {
    create?: XOR<ProcessMatCreateWithoutStockInput, ProcessMatUncheckedCreateWithoutStockInput> | ProcessMatCreateWithoutStockInput[] | ProcessMatUncheckedCreateWithoutStockInput[]
    connectOrCreate?: ProcessMatCreateOrConnectWithoutStockInput | ProcessMatCreateOrConnectWithoutStockInput[]
    createMany?: ProcessMatCreateManyStockInputEnvelope
    connect?: ProcessMatWhereUniqueInput | ProcessMatWhereUniqueInput[]
  }

  export type ProcessBomUncheckedCreateNestedManyWithoutStockInput = {
    create?: XOR<ProcessBomCreateWithoutStockInput, ProcessBomUncheckedCreateWithoutStockInput> | ProcessBomCreateWithoutStockInput[] | ProcessBomUncheckedCreateWithoutStockInput[]
    connectOrCreate?: ProcessBomCreateOrConnectWithoutStockInput | ProcessBomCreateOrConnectWithoutStockInput[]
    createMany?: ProcessBomCreateManyStockInputEnvelope
    connect?: ProcessBomWhereUniqueInput | ProcessBomWhereUniqueInput[]
  }

  export type ProjectMatUncheckedCreateNestedManyWithoutStockInput = {
    create?: XOR<ProjectMatCreateWithoutStockInput, ProjectMatUncheckedCreateWithoutStockInput> | ProjectMatCreateWithoutStockInput[] | ProjectMatUncheckedCreateWithoutStockInput[]
    connectOrCreate?: ProjectMatCreateOrConnectWithoutStockInput | ProjectMatCreateOrConnectWithoutStockInput[]
    createMany?: ProjectMatCreateManyStockInputEnvelope
    connect?: ProjectMatWhereUniqueInput | ProjectMatWhereUniqueInput[]
  }

  export type ProjectBomUncheckedCreateNestedManyWithoutStockInput = {
    create?: XOR<ProjectBomCreateWithoutStockInput, ProjectBomUncheckedCreateWithoutStockInput> | ProjectBomCreateWithoutStockInput[] | ProjectBomUncheckedCreateWithoutStockInput[]
    connectOrCreate?: ProjectBomCreateOrConnectWithoutStockInput | ProjectBomCreateOrConnectWithoutStockInput[]
    createMany?: ProjectBomCreateManyStockInputEnvelope
    connect?: ProjectBomWhereUniqueInput | ProjectBomWhereUniqueInput[]
  }

  export type ProcessMatUpdateManyWithoutStockNestedInput = {
    create?: XOR<ProcessMatCreateWithoutStockInput, ProcessMatUncheckedCreateWithoutStockInput> | ProcessMatCreateWithoutStockInput[] | ProcessMatUncheckedCreateWithoutStockInput[]
    connectOrCreate?: ProcessMatCreateOrConnectWithoutStockInput | ProcessMatCreateOrConnectWithoutStockInput[]
    upsert?: ProcessMatUpsertWithWhereUniqueWithoutStockInput | ProcessMatUpsertWithWhereUniqueWithoutStockInput[]
    createMany?: ProcessMatCreateManyStockInputEnvelope
    set?: ProcessMatWhereUniqueInput | ProcessMatWhereUniqueInput[]
    disconnect?: ProcessMatWhereUniqueInput | ProcessMatWhereUniqueInput[]
    delete?: ProcessMatWhereUniqueInput | ProcessMatWhereUniqueInput[]
    connect?: ProcessMatWhereUniqueInput | ProcessMatWhereUniqueInput[]
    update?: ProcessMatUpdateWithWhereUniqueWithoutStockInput | ProcessMatUpdateWithWhereUniqueWithoutStockInput[]
    updateMany?: ProcessMatUpdateManyWithWhereWithoutStockInput | ProcessMatUpdateManyWithWhereWithoutStockInput[]
    deleteMany?: ProcessMatScalarWhereInput | ProcessMatScalarWhereInput[]
  }

  export type ProcessBomUpdateManyWithoutStockNestedInput = {
    create?: XOR<ProcessBomCreateWithoutStockInput, ProcessBomUncheckedCreateWithoutStockInput> | ProcessBomCreateWithoutStockInput[] | ProcessBomUncheckedCreateWithoutStockInput[]
    connectOrCreate?: ProcessBomCreateOrConnectWithoutStockInput | ProcessBomCreateOrConnectWithoutStockInput[]
    upsert?: ProcessBomUpsertWithWhereUniqueWithoutStockInput | ProcessBomUpsertWithWhereUniqueWithoutStockInput[]
    createMany?: ProcessBomCreateManyStockInputEnvelope
    set?: ProcessBomWhereUniqueInput | ProcessBomWhereUniqueInput[]
    disconnect?: ProcessBomWhereUniqueInput | ProcessBomWhereUniqueInput[]
    delete?: ProcessBomWhereUniqueInput | ProcessBomWhereUniqueInput[]
    connect?: ProcessBomWhereUniqueInput | ProcessBomWhereUniqueInput[]
    update?: ProcessBomUpdateWithWhereUniqueWithoutStockInput | ProcessBomUpdateWithWhereUniqueWithoutStockInput[]
    updateMany?: ProcessBomUpdateManyWithWhereWithoutStockInput | ProcessBomUpdateManyWithWhereWithoutStockInput[]
    deleteMany?: ProcessBomScalarWhereInput | ProcessBomScalarWhereInput[]
  }

  export type ProjectMatUpdateManyWithoutStockNestedInput = {
    create?: XOR<ProjectMatCreateWithoutStockInput, ProjectMatUncheckedCreateWithoutStockInput> | ProjectMatCreateWithoutStockInput[] | ProjectMatUncheckedCreateWithoutStockInput[]
    connectOrCreate?: ProjectMatCreateOrConnectWithoutStockInput | ProjectMatCreateOrConnectWithoutStockInput[]
    upsert?: ProjectMatUpsertWithWhereUniqueWithoutStockInput | ProjectMatUpsertWithWhereUniqueWithoutStockInput[]
    createMany?: ProjectMatCreateManyStockInputEnvelope
    set?: ProjectMatWhereUniqueInput | ProjectMatWhereUniqueInput[]
    disconnect?: ProjectMatWhereUniqueInput | ProjectMatWhereUniqueInput[]
    delete?: ProjectMatWhereUniqueInput | ProjectMatWhereUniqueInput[]
    connect?: ProjectMatWhereUniqueInput | ProjectMatWhereUniqueInput[]
    update?: ProjectMatUpdateWithWhereUniqueWithoutStockInput | ProjectMatUpdateWithWhereUniqueWithoutStockInput[]
    updateMany?: ProjectMatUpdateManyWithWhereWithoutStockInput | ProjectMatUpdateManyWithWhereWithoutStockInput[]
    deleteMany?: ProjectMatScalarWhereInput | ProjectMatScalarWhereInput[]
  }

  export type ProjectBomUpdateManyWithoutStockNestedInput = {
    create?: XOR<ProjectBomCreateWithoutStockInput, ProjectBomUncheckedCreateWithoutStockInput> | ProjectBomCreateWithoutStockInput[] | ProjectBomUncheckedCreateWithoutStockInput[]
    connectOrCreate?: ProjectBomCreateOrConnectWithoutStockInput | ProjectBomCreateOrConnectWithoutStockInput[]
    upsert?: ProjectBomUpsertWithWhereUniqueWithoutStockInput | ProjectBomUpsertWithWhereUniqueWithoutStockInput[]
    createMany?: ProjectBomCreateManyStockInputEnvelope
    set?: ProjectBomWhereUniqueInput | ProjectBomWhereUniqueInput[]
    disconnect?: ProjectBomWhereUniqueInput | ProjectBomWhereUniqueInput[]
    delete?: ProjectBomWhereUniqueInput | ProjectBomWhereUniqueInput[]
    connect?: ProjectBomWhereUniqueInput | ProjectBomWhereUniqueInput[]
    update?: ProjectBomUpdateWithWhereUniqueWithoutStockInput | ProjectBomUpdateWithWhereUniqueWithoutStockInput[]
    updateMany?: ProjectBomUpdateManyWithWhereWithoutStockInput | ProjectBomUpdateManyWithWhereWithoutStockInput[]
    deleteMany?: ProjectBomScalarWhereInput | ProjectBomScalarWhereInput[]
  }

  export type ProcessMatUncheckedUpdateManyWithoutStockNestedInput = {
    create?: XOR<ProcessMatCreateWithoutStockInput, ProcessMatUncheckedCreateWithoutStockInput> | ProcessMatCreateWithoutStockInput[] | ProcessMatUncheckedCreateWithoutStockInput[]
    connectOrCreate?: ProcessMatCreateOrConnectWithoutStockInput | ProcessMatCreateOrConnectWithoutStockInput[]
    upsert?: ProcessMatUpsertWithWhereUniqueWithoutStockInput | ProcessMatUpsertWithWhereUniqueWithoutStockInput[]
    createMany?: ProcessMatCreateManyStockInputEnvelope
    set?: ProcessMatWhereUniqueInput | ProcessMatWhereUniqueInput[]
    disconnect?: ProcessMatWhereUniqueInput | ProcessMatWhereUniqueInput[]
    delete?: ProcessMatWhereUniqueInput | ProcessMatWhereUniqueInput[]
    connect?: ProcessMatWhereUniqueInput | ProcessMatWhereUniqueInput[]
    update?: ProcessMatUpdateWithWhereUniqueWithoutStockInput | ProcessMatUpdateWithWhereUniqueWithoutStockInput[]
    updateMany?: ProcessMatUpdateManyWithWhereWithoutStockInput | ProcessMatUpdateManyWithWhereWithoutStockInput[]
    deleteMany?: ProcessMatScalarWhereInput | ProcessMatScalarWhereInput[]
  }

  export type ProcessBomUncheckedUpdateManyWithoutStockNestedInput = {
    create?: XOR<ProcessBomCreateWithoutStockInput, ProcessBomUncheckedCreateWithoutStockInput> | ProcessBomCreateWithoutStockInput[] | ProcessBomUncheckedCreateWithoutStockInput[]
    connectOrCreate?: ProcessBomCreateOrConnectWithoutStockInput | ProcessBomCreateOrConnectWithoutStockInput[]
    upsert?: ProcessBomUpsertWithWhereUniqueWithoutStockInput | ProcessBomUpsertWithWhereUniqueWithoutStockInput[]
    createMany?: ProcessBomCreateManyStockInputEnvelope
    set?: ProcessBomWhereUniqueInput | ProcessBomWhereUniqueInput[]
    disconnect?: ProcessBomWhereUniqueInput | ProcessBomWhereUniqueInput[]
    delete?: ProcessBomWhereUniqueInput | ProcessBomWhereUniqueInput[]
    connect?: ProcessBomWhereUniqueInput | ProcessBomWhereUniqueInput[]
    update?: ProcessBomUpdateWithWhereUniqueWithoutStockInput | ProcessBomUpdateWithWhereUniqueWithoutStockInput[]
    updateMany?: ProcessBomUpdateManyWithWhereWithoutStockInput | ProcessBomUpdateManyWithWhereWithoutStockInput[]
    deleteMany?: ProcessBomScalarWhereInput | ProcessBomScalarWhereInput[]
  }

  export type ProjectMatUncheckedUpdateManyWithoutStockNestedInput = {
    create?: XOR<ProjectMatCreateWithoutStockInput, ProjectMatUncheckedCreateWithoutStockInput> | ProjectMatCreateWithoutStockInput[] | ProjectMatUncheckedCreateWithoutStockInput[]
    connectOrCreate?: ProjectMatCreateOrConnectWithoutStockInput | ProjectMatCreateOrConnectWithoutStockInput[]
    upsert?: ProjectMatUpsertWithWhereUniqueWithoutStockInput | ProjectMatUpsertWithWhereUniqueWithoutStockInput[]
    createMany?: ProjectMatCreateManyStockInputEnvelope
    set?: ProjectMatWhereUniqueInput | ProjectMatWhereUniqueInput[]
    disconnect?: ProjectMatWhereUniqueInput | ProjectMatWhereUniqueInput[]
    delete?: ProjectMatWhereUniqueInput | ProjectMatWhereUniqueInput[]
    connect?: ProjectMatWhereUniqueInput | ProjectMatWhereUniqueInput[]
    update?: ProjectMatUpdateWithWhereUniqueWithoutStockInput | ProjectMatUpdateWithWhereUniqueWithoutStockInput[]
    updateMany?: ProjectMatUpdateManyWithWhereWithoutStockInput | ProjectMatUpdateManyWithWhereWithoutStockInput[]
    deleteMany?: ProjectMatScalarWhereInput | ProjectMatScalarWhereInput[]
  }

  export type ProjectBomUncheckedUpdateManyWithoutStockNestedInput = {
    create?: XOR<ProjectBomCreateWithoutStockInput, ProjectBomUncheckedCreateWithoutStockInput> | ProjectBomCreateWithoutStockInput[] | ProjectBomUncheckedCreateWithoutStockInput[]
    connectOrCreate?: ProjectBomCreateOrConnectWithoutStockInput | ProjectBomCreateOrConnectWithoutStockInput[]
    upsert?: ProjectBomUpsertWithWhereUniqueWithoutStockInput | ProjectBomUpsertWithWhereUniqueWithoutStockInput[]
    createMany?: ProjectBomCreateManyStockInputEnvelope
    set?: ProjectBomWhereUniqueInput | ProjectBomWhereUniqueInput[]
    disconnect?: ProjectBomWhereUniqueInput | ProjectBomWhereUniqueInput[]
    delete?: ProjectBomWhereUniqueInput | ProjectBomWhereUniqueInput[]
    connect?: ProjectBomWhereUniqueInput | ProjectBomWhereUniqueInput[]
    update?: ProjectBomUpdateWithWhereUniqueWithoutStockInput | ProjectBomUpdateWithWhereUniqueWithoutStockInput[]
    updateMany?: ProjectBomUpdateManyWithWhereWithoutStockInput | ProjectBomUpdateManyWithWhereWithoutStockInput[]
    deleteMany?: ProjectBomScalarWhereInput | ProjectBomScalarWhereInput[]
  }

  export type ReasonDetailCreateNestedManyWithoutReasonTypeNGInput = {
    create?: XOR<ReasonDetailCreateWithoutReasonTypeNGInput, ReasonDetailUncheckedCreateWithoutReasonTypeNGInput> | ReasonDetailCreateWithoutReasonTypeNGInput[] | ReasonDetailUncheckedCreateWithoutReasonTypeNGInput[]
    connectOrCreate?: ReasonDetailCreateOrConnectWithoutReasonTypeNGInput | ReasonDetailCreateOrConnectWithoutReasonTypeNGInput[]
    createMany?: ReasonDetailCreateManyReasonTypeNGInputEnvelope
    connect?: ReasonDetailWhereUniqueInput | ReasonDetailWhereUniqueInput[]
  }

  export type ReasonDetailUncheckedCreateNestedManyWithoutReasonTypeNGInput = {
    create?: XOR<ReasonDetailCreateWithoutReasonTypeNGInput, ReasonDetailUncheckedCreateWithoutReasonTypeNGInput> | ReasonDetailCreateWithoutReasonTypeNGInput[] | ReasonDetailUncheckedCreateWithoutReasonTypeNGInput[]
    connectOrCreate?: ReasonDetailCreateOrConnectWithoutReasonTypeNGInput | ReasonDetailCreateOrConnectWithoutReasonTypeNGInput[]
    createMany?: ReasonDetailCreateManyReasonTypeNGInputEnvelope
    connect?: ReasonDetailWhereUniqueInput | ReasonDetailWhereUniqueInput[]
  }

  export type ReasonDetailUpdateManyWithoutReasonTypeNGNestedInput = {
    create?: XOR<ReasonDetailCreateWithoutReasonTypeNGInput, ReasonDetailUncheckedCreateWithoutReasonTypeNGInput> | ReasonDetailCreateWithoutReasonTypeNGInput[] | ReasonDetailUncheckedCreateWithoutReasonTypeNGInput[]
    connectOrCreate?: ReasonDetailCreateOrConnectWithoutReasonTypeNGInput | ReasonDetailCreateOrConnectWithoutReasonTypeNGInput[]
    upsert?: ReasonDetailUpsertWithWhereUniqueWithoutReasonTypeNGInput | ReasonDetailUpsertWithWhereUniqueWithoutReasonTypeNGInput[]
    createMany?: ReasonDetailCreateManyReasonTypeNGInputEnvelope
    set?: ReasonDetailWhereUniqueInput | ReasonDetailWhereUniqueInput[]
    disconnect?: ReasonDetailWhereUniqueInput | ReasonDetailWhereUniqueInput[]
    delete?: ReasonDetailWhereUniqueInput | ReasonDetailWhereUniqueInput[]
    connect?: ReasonDetailWhereUniqueInput | ReasonDetailWhereUniqueInput[]
    update?: ReasonDetailUpdateWithWhereUniqueWithoutReasonTypeNGInput | ReasonDetailUpdateWithWhereUniqueWithoutReasonTypeNGInput[]
    updateMany?: ReasonDetailUpdateManyWithWhereWithoutReasonTypeNGInput | ReasonDetailUpdateManyWithWhereWithoutReasonTypeNGInput[]
    deleteMany?: ReasonDetailScalarWhereInput | ReasonDetailScalarWhereInput[]
  }

  export type ReasonDetailUncheckedUpdateManyWithoutReasonTypeNGNestedInput = {
    create?: XOR<ReasonDetailCreateWithoutReasonTypeNGInput, ReasonDetailUncheckedCreateWithoutReasonTypeNGInput> | ReasonDetailCreateWithoutReasonTypeNGInput[] | ReasonDetailUncheckedCreateWithoutReasonTypeNGInput[]
    connectOrCreate?: ReasonDetailCreateOrConnectWithoutReasonTypeNGInput | ReasonDetailCreateOrConnectWithoutReasonTypeNGInput[]
    upsert?: ReasonDetailUpsertWithWhereUniqueWithoutReasonTypeNGInput | ReasonDetailUpsertWithWhereUniqueWithoutReasonTypeNGInput[]
    createMany?: ReasonDetailCreateManyReasonTypeNGInputEnvelope
    set?: ReasonDetailWhereUniqueInput | ReasonDetailWhereUniqueInput[]
    disconnect?: ReasonDetailWhereUniqueInput | ReasonDetailWhereUniqueInput[]
    delete?: ReasonDetailWhereUniqueInput | ReasonDetailWhereUniqueInput[]
    connect?: ReasonDetailWhereUniqueInput | ReasonDetailWhereUniqueInput[]
    update?: ReasonDetailUpdateWithWhereUniqueWithoutReasonTypeNGInput | ReasonDetailUpdateWithWhereUniqueWithoutReasonTypeNGInput[]
    updateMany?: ReasonDetailUpdateManyWithWhereWithoutReasonTypeNGInput | ReasonDetailUpdateManyWithWhereWithoutReasonTypeNGInput[]
    deleteMany?: ReasonDetailScalarWhereInput | ReasonDetailScalarWhereInput[]
  }

  export type ReasonTypeNGCreateNestedOneWithoutReasondDetailInput = {
    create?: XOR<ReasonTypeNGCreateWithoutReasondDetailInput, ReasonTypeNGUncheckedCreateWithoutReasondDetailInput>
    connectOrCreate?: ReasonTypeNGCreateOrConnectWithoutReasondDetailInput
    connect?: ReasonTypeNGWhereUniqueInput
  }

  export type ReasonTypeNGUpdateOneRequiredWithoutReasondDetailNestedInput = {
    create?: XOR<ReasonTypeNGCreateWithoutReasondDetailInput, ReasonTypeNGUncheckedCreateWithoutReasondDetailInput>
    connectOrCreate?: ReasonTypeNGCreateOrConnectWithoutReasondDetailInput
    upsert?: ReasonTypeNGUpsertWithoutReasondDetailInput
    connect?: ReasonTypeNGWhereUniqueInput
    update?: XOR<XOR<ReasonTypeNGUpdateToOneWithWhereWithoutReasondDetailInput, ReasonTypeNGUpdateWithoutReasondDetailInput>, ReasonTypeNGUncheckedUpdateWithoutReasondDetailInput>
  }

  export type ReportProcessCreateNestedManyWithoutReportInput = {
    create?: XOR<ReportProcessCreateWithoutReportInput, ReportProcessUncheckedCreateWithoutReportInput> | ReportProcessCreateWithoutReportInput[] | ReportProcessUncheckedCreateWithoutReportInput[]
    connectOrCreate?: ReportProcessCreateOrConnectWithoutReportInput | ReportProcessCreateOrConnectWithoutReportInput[]
    createMany?: ReportProcessCreateManyReportInputEnvelope
    connect?: ReportProcessWhereUniqueInput | ReportProcessWhereUniqueInput[]
  }

  export type ReportProcessUncheckedCreateNestedManyWithoutReportInput = {
    create?: XOR<ReportProcessCreateWithoutReportInput, ReportProcessUncheckedCreateWithoutReportInput> | ReportProcessCreateWithoutReportInput[] | ReportProcessUncheckedCreateWithoutReportInput[]
    connectOrCreate?: ReportProcessCreateOrConnectWithoutReportInput | ReportProcessCreateOrConnectWithoutReportInput[]
    createMany?: ReportProcessCreateManyReportInputEnvelope
    connect?: ReportProcessWhereUniqueInput | ReportProcessWhereUniqueInput[]
  }

  export type ReportProcessUpdateManyWithoutReportNestedInput = {
    create?: XOR<ReportProcessCreateWithoutReportInput, ReportProcessUncheckedCreateWithoutReportInput> | ReportProcessCreateWithoutReportInput[] | ReportProcessUncheckedCreateWithoutReportInput[]
    connectOrCreate?: ReportProcessCreateOrConnectWithoutReportInput | ReportProcessCreateOrConnectWithoutReportInput[]
    upsert?: ReportProcessUpsertWithWhereUniqueWithoutReportInput | ReportProcessUpsertWithWhereUniqueWithoutReportInput[]
    createMany?: ReportProcessCreateManyReportInputEnvelope
    set?: ReportProcessWhereUniqueInput | ReportProcessWhereUniqueInput[]
    disconnect?: ReportProcessWhereUniqueInput | ReportProcessWhereUniqueInput[]
    delete?: ReportProcessWhereUniqueInput | ReportProcessWhereUniqueInput[]
    connect?: ReportProcessWhereUniqueInput | ReportProcessWhereUniqueInput[]
    update?: ReportProcessUpdateWithWhereUniqueWithoutReportInput | ReportProcessUpdateWithWhereUniqueWithoutReportInput[]
    updateMany?: ReportProcessUpdateManyWithWhereWithoutReportInput | ReportProcessUpdateManyWithWhereWithoutReportInput[]
    deleteMany?: ReportProcessScalarWhereInput | ReportProcessScalarWhereInput[]
  }

  export type ReportProcessUncheckedUpdateManyWithoutReportNestedInput = {
    create?: XOR<ReportProcessCreateWithoutReportInput, ReportProcessUncheckedCreateWithoutReportInput> | ReportProcessCreateWithoutReportInput[] | ReportProcessUncheckedCreateWithoutReportInput[]
    connectOrCreate?: ReportProcessCreateOrConnectWithoutReportInput | ReportProcessCreateOrConnectWithoutReportInput[]
    upsert?: ReportProcessUpsertWithWhereUniqueWithoutReportInput | ReportProcessUpsertWithWhereUniqueWithoutReportInput[]
    createMany?: ReportProcessCreateManyReportInputEnvelope
    set?: ReportProcessWhereUniqueInput | ReportProcessWhereUniqueInput[]
    disconnect?: ReportProcessWhereUniqueInput | ReportProcessWhereUniqueInput[]
    delete?: ReportProcessWhereUniqueInput | ReportProcessWhereUniqueInput[]
    connect?: ReportProcessWhereUniqueInput | ReportProcessWhereUniqueInput[]
    update?: ReportProcessUpdateWithWhereUniqueWithoutReportInput | ReportProcessUpdateWithWhereUniqueWithoutReportInput[]
    updateMany?: ReportProcessUpdateManyWithWhereWithoutReportInput | ReportProcessUpdateManyWithWhereWithoutReportInput[]
    deleteMany?: ReportProcessScalarWhereInput | ReportProcessScalarWhereInput[]
  }

  export type ReportCreateNestedOneWithoutReportProcessInput = {
    create?: XOR<ReportCreateWithoutReportProcessInput, ReportUncheckedCreateWithoutReportProcessInput>
    connectOrCreate?: ReportCreateOrConnectWithoutReportProcessInput
    connect?: ReportWhereUniqueInput
  }

  export type ReportStockCreateNestedManyWithoutReportProcessInput = {
    create?: XOR<ReportStockCreateWithoutReportProcessInput, ReportStockUncheckedCreateWithoutReportProcessInput> | ReportStockCreateWithoutReportProcessInput[] | ReportStockUncheckedCreateWithoutReportProcessInput[]
    connectOrCreate?: ReportStockCreateOrConnectWithoutReportProcessInput | ReportStockCreateOrConnectWithoutReportProcessInput[]
    createMany?: ReportStockCreateManyReportProcessInputEnvelope
    connect?: ReportStockWhereUniqueInput | ReportStockWhereUniqueInput[]
  }

  export type ReportStockUncheckedCreateNestedManyWithoutReportProcessInput = {
    create?: XOR<ReportStockCreateWithoutReportProcessInput, ReportStockUncheckedCreateWithoutReportProcessInput> | ReportStockCreateWithoutReportProcessInput[] | ReportStockUncheckedCreateWithoutReportProcessInput[]
    connectOrCreate?: ReportStockCreateOrConnectWithoutReportProcessInput | ReportStockCreateOrConnectWithoutReportProcessInput[]
    createMany?: ReportStockCreateManyReportProcessInputEnvelope
    connect?: ReportStockWhereUniqueInput | ReportStockWhereUniqueInput[]
  }

  export type ReportUpdateOneRequiredWithoutReportProcessNestedInput = {
    create?: XOR<ReportCreateWithoutReportProcessInput, ReportUncheckedCreateWithoutReportProcessInput>
    connectOrCreate?: ReportCreateOrConnectWithoutReportProcessInput
    upsert?: ReportUpsertWithoutReportProcessInput
    connect?: ReportWhereUniqueInput
    update?: XOR<XOR<ReportUpdateToOneWithWhereWithoutReportProcessInput, ReportUpdateWithoutReportProcessInput>, ReportUncheckedUpdateWithoutReportProcessInput>
  }

  export type ReportStockUpdateManyWithoutReportProcessNestedInput = {
    create?: XOR<ReportStockCreateWithoutReportProcessInput, ReportStockUncheckedCreateWithoutReportProcessInput> | ReportStockCreateWithoutReportProcessInput[] | ReportStockUncheckedCreateWithoutReportProcessInput[]
    connectOrCreate?: ReportStockCreateOrConnectWithoutReportProcessInput | ReportStockCreateOrConnectWithoutReportProcessInput[]
    upsert?: ReportStockUpsertWithWhereUniqueWithoutReportProcessInput | ReportStockUpsertWithWhereUniqueWithoutReportProcessInput[]
    createMany?: ReportStockCreateManyReportProcessInputEnvelope
    set?: ReportStockWhereUniqueInput | ReportStockWhereUniqueInput[]
    disconnect?: ReportStockWhereUniqueInput | ReportStockWhereUniqueInput[]
    delete?: ReportStockWhereUniqueInput | ReportStockWhereUniqueInput[]
    connect?: ReportStockWhereUniqueInput | ReportStockWhereUniqueInput[]
    update?: ReportStockUpdateWithWhereUniqueWithoutReportProcessInput | ReportStockUpdateWithWhereUniqueWithoutReportProcessInput[]
    updateMany?: ReportStockUpdateManyWithWhereWithoutReportProcessInput | ReportStockUpdateManyWithWhereWithoutReportProcessInput[]
    deleteMany?: ReportStockScalarWhereInput | ReportStockScalarWhereInput[]
  }

  export type ReportStockUncheckedUpdateManyWithoutReportProcessNestedInput = {
    create?: XOR<ReportStockCreateWithoutReportProcessInput, ReportStockUncheckedCreateWithoutReportProcessInput> | ReportStockCreateWithoutReportProcessInput[] | ReportStockUncheckedCreateWithoutReportProcessInput[]
    connectOrCreate?: ReportStockCreateOrConnectWithoutReportProcessInput | ReportStockCreateOrConnectWithoutReportProcessInput[]
    upsert?: ReportStockUpsertWithWhereUniqueWithoutReportProcessInput | ReportStockUpsertWithWhereUniqueWithoutReportProcessInput[]
    createMany?: ReportStockCreateManyReportProcessInputEnvelope
    set?: ReportStockWhereUniqueInput | ReportStockWhereUniqueInput[]
    disconnect?: ReportStockWhereUniqueInput | ReportStockWhereUniqueInput[]
    delete?: ReportStockWhereUniqueInput | ReportStockWhereUniqueInput[]
    connect?: ReportStockWhereUniqueInput | ReportStockWhereUniqueInput[]
    update?: ReportStockUpdateWithWhereUniqueWithoutReportProcessInput | ReportStockUpdateWithWhereUniqueWithoutReportProcessInput[]
    updateMany?: ReportStockUpdateManyWithWhereWithoutReportProcessInput | ReportStockUpdateManyWithWhereWithoutReportProcessInput[]
    deleteMany?: ReportStockScalarWhereInput | ReportStockScalarWhereInput[]
  }

  export type ReportProcessCreateNestedOneWithoutReportStockInput = {
    create?: XOR<ReportProcessCreateWithoutReportStockInput, ReportProcessUncheckedCreateWithoutReportStockInput>
    connectOrCreate?: ReportProcessCreateOrConnectWithoutReportStockInput
    connect?: ReportProcessWhereUniqueInput
  }

  export type ReportProcessUpdateOneRequiredWithoutReportStockNestedInput = {
    create?: XOR<ReportProcessCreateWithoutReportStockInput, ReportProcessUncheckedCreateWithoutReportStockInput>
    connectOrCreate?: ReportProcessCreateOrConnectWithoutReportStockInput
    upsert?: ReportProcessUpsertWithoutReportStockInput
    connect?: ReportProcessWhereUniqueInput
    update?: XOR<XOR<ReportProcessUpdateToOneWithWhereWithoutReportStockInput, ReportProcessUpdateWithoutReportStockInput>, ReportProcessUncheckedUpdateWithoutReportStockInput>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedBoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedBoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type NestedBigIntFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[]
    notIn?: bigint[] | number[]
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntFilter<$PrismaModel> | bigint | number
  }

  export type NestedBigIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[]
    notIn?: bigint[] | number[]
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntWithAggregatesFilter<$PrismaModel> | bigint | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedBigIntFilter<$PrismaModel>
    _min?: NestedBigIntFilter<$PrismaModel>
    _max?: NestedBigIntFilter<$PrismaModel>
  }

  export type DepartmentCreateWithoutUserInput = {
    departmentName: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    Course?: CourseCreateNestedManyWithoutDepartmentInput
  }

  export type DepartmentUncheckedCreateWithoutUserInput = {
    id?: number
    departmentName: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    Course?: CourseUncheckedCreateNestedManyWithoutDepartmentInput
  }

  export type DepartmentCreateOrConnectWithoutUserInput = {
    where: DepartmentWhereUniqueInput
    create: XOR<DepartmentCreateWithoutUserInput, DepartmentUncheckedCreateWithoutUserInput>
  }

  export type ProcessCreateWithoutUserInput = {
    pc_bluePrintNo: string
    pc_imageBluePrint: string
    pc_totalProcess: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    courses?: CourseCreateNestedManyWithoutProcessInput
    completions?: UserCourseCompletionCreateNestedManyWithoutProcessInput
    processDetail?: ProcessDetailCreateNestedManyWithoutProcessInput
  }

  export type ProcessUncheckedCreateWithoutUserInput = {
    id?: number
    pc_bluePrintNo: string
    pc_imageBluePrint: string
    pc_totalProcess: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    courses?: CourseUncheckedCreateNestedManyWithoutProcessInput
    completions?: UserCourseCompletionUncheckedCreateNestedManyWithoutProcessInput
    processDetail?: ProcessDetailUncheckedCreateNestedManyWithoutProcessInput
  }

  export type ProcessCreateOrConnectWithoutUserInput = {
    where: ProcessWhereUniqueInput
    create: XOR<ProcessCreateWithoutUserInput, ProcessUncheckedCreateWithoutUserInput>
  }

  export type ProcessCreateManyUserInputEnvelope = {
    data: ProcessCreateManyUserInput | ProcessCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ExamAttemptCreateWithoutUserInput = {
    startedAt?: Date | string
    endedAt?: Date | string | null
    grade?: number | null
    isPassed?: boolean | null
    exam: ExamCreateNestedOneWithoutAttemptsInput
    answers?: UserAnswerCreateNestedManyWithoutExamAttemptInput
  }

  export type ExamAttemptUncheckedCreateWithoutUserInput = {
    id?: number
    examId: number
    startedAt?: Date | string
    endedAt?: Date | string | null
    grade?: number | null
    isPassed?: boolean | null
    answers?: UserAnswerUncheckedCreateNestedManyWithoutExamAttemptInput
  }

  export type ExamAttemptCreateOrConnectWithoutUserInput = {
    where: ExamAttemptWhereUniqueInput
    create: XOR<ExamAttemptCreateWithoutUserInput, ExamAttemptUncheckedCreateWithoutUserInput>
  }

  export type ExamAttemptCreateManyUserInputEnvelope = {
    data: ExamAttemptCreateManyUserInput | ExamAttemptCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type EnrollmentCreateWithoutUserInput = {
    progress: number
    completed?: boolean
    isDownloaded?: number
    course: CourseCreateNestedOneWithoutEnrollmentsInput
  }

  export type EnrollmentUncheckedCreateWithoutUserInput = {
    id?: number
    courseId: number
    progress: number
    completed?: boolean
    isDownloaded?: number
  }

  export type EnrollmentCreateOrConnectWithoutUserInput = {
    where: EnrollmentWhereUniqueInput
    create: XOR<EnrollmentCreateWithoutUserInput, EnrollmentUncheckedCreateWithoutUserInput>
  }

  export type EnrollmentCreateManyUserInputEnvelope = {
    data: EnrollmentCreateManyUserInput | EnrollmentCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type OplDocumentCreateWithoutUserInput = {
    title: string
    description?: string | null
    fileName: string
    fileType: string
    filePath: string
    template?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type OplDocumentUncheckedCreateWithoutUserInput = {
    id?: number
    title: string
    description?: string | null
    fileName: string
    fileType: string
    filePath: string
    template?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type OplDocumentCreateOrConnectWithoutUserInput = {
    where: OplDocumentWhereUniqueInput
    create: XOR<OplDocumentCreateWithoutUserInput, OplDocumentUncheckedCreateWithoutUserInput>
  }

  export type OplDocumentCreateManyUserInputEnvelope = {
    data: OplDocumentCreateManyUserInput | OplDocumentCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type FileCreateWithoutUserInput = {
    originalName: string
    storedName: string
    fileType: string
    fileSize: bigint | number
    filePath: string
    uploadDate?: Date | string
    course?: CourseCreateNestedOneWithoutFilesInput
  }

  export type FileUncheckedCreateWithoutUserInput = {
    id?: number
    originalName: string
    storedName: string
    fileType: string
    fileSize: bigint | number
    filePath: string
    uploadDate?: Date | string
    courseId?: number | null
  }

  export type FileCreateOrConnectWithoutUserInput = {
    where: FileWhereUniqueInput
    create: XOR<FileCreateWithoutUserInput, FileUncheckedCreateWithoutUserInput>
  }

  export type FileCreateManyUserInputEnvelope = {
    data: FileCreateManyUserInput | FileCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type CourseCreateWithoutCreatorInput = {
    title: string
    description?: string | null
    pdfUrl?: string | null
    videoUrl?: string | null
    typeId: number
    template?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    department?: DepartmentCreateNestedOneWithoutCourseInput
    process?: ProcessCreateNestedOneWithoutCoursesInput
    enrollments?: EnrollmentCreateNestedManyWithoutCourseInput
    files?: FileCreateNestedManyWithoutCourseInput
    exams?: ExamCreateNestedManyWithoutCourseInput
    completions?: UserCourseCompletionCreateNestedManyWithoutCourseInput
    deleter?: UserCreateNestedOneWithoutDeletedCoursesInput
  }

  export type CourseUncheckedCreateWithoutCreatorInput = {
    id?: number
    title: string
    description?: string | null
    pdfUrl?: string | null
    videoUrl?: string | null
    typeId: number
    template?: boolean
    departmentId?: number | null
    processId?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedBy?: number | null
    isDeleted?: boolean
    enrollments?: EnrollmentUncheckedCreateNestedManyWithoutCourseInput
    files?: FileUncheckedCreateNestedManyWithoutCourseInput
    exams?: ExamUncheckedCreateNestedManyWithoutCourseInput
    completions?: UserCourseCompletionUncheckedCreateNestedManyWithoutCourseInput
  }

  export type CourseCreateOrConnectWithoutCreatorInput = {
    where: CourseWhereUniqueInput
    create: XOR<CourseCreateWithoutCreatorInput, CourseUncheckedCreateWithoutCreatorInput>
  }

  export type CourseCreateManyCreatorInputEnvelope = {
    data: CourseCreateManyCreatorInput | CourseCreateManyCreatorInput[]
    skipDuplicates?: boolean
  }

  export type CourseCreateWithoutDeleterInput = {
    title: string
    description?: string | null
    pdfUrl?: string | null
    videoUrl?: string | null
    typeId: number
    template?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    department?: DepartmentCreateNestedOneWithoutCourseInput
    process?: ProcessCreateNestedOneWithoutCoursesInput
    enrollments?: EnrollmentCreateNestedManyWithoutCourseInput
    files?: FileCreateNestedManyWithoutCourseInput
    exams?: ExamCreateNestedManyWithoutCourseInput
    completions?: UserCourseCompletionCreateNestedManyWithoutCourseInput
    creator: UserCreateNestedOneWithoutCreatedCoursesInput
  }

  export type CourseUncheckedCreateWithoutDeleterInput = {
    id?: number
    title: string
    description?: string | null
    pdfUrl?: string | null
    videoUrl?: string | null
    typeId: number
    template?: boolean
    departmentId?: number | null
    processId?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: number
    isDeleted?: boolean
    enrollments?: EnrollmentUncheckedCreateNestedManyWithoutCourseInput
    files?: FileUncheckedCreateNestedManyWithoutCourseInput
    exams?: ExamUncheckedCreateNestedManyWithoutCourseInput
    completions?: UserCourseCompletionUncheckedCreateNestedManyWithoutCourseInput
  }

  export type CourseCreateOrConnectWithoutDeleterInput = {
    where: CourseWhereUniqueInput
    create: XOR<CourseCreateWithoutDeleterInput, CourseUncheckedCreateWithoutDeleterInput>
  }

  export type CourseCreateManyDeleterInputEnvelope = {
    data: CourseCreateManyDeleterInput | CourseCreateManyDeleterInput[]
    skipDuplicates?: boolean
  }

  export type UserCourseCompletionCreateWithoutUserInput = {
    completedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    course: CourseCreateNestedOneWithoutCompletionsInput
    exam: ExamCreateNestedOneWithoutCompletionsInput
    process: ProcessCreateNestedOneWithoutCompletionsInput
  }

  export type UserCourseCompletionUncheckedCreateWithoutUserInput = {
    id?: number
    courseId: number
    examId: number
    processId: number
    completedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserCourseCompletionCreateOrConnectWithoutUserInput = {
    where: UserCourseCompletionWhereUniqueInput
    create: XOR<UserCourseCompletionCreateWithoutUserInput, UserCourseCompletionUncheckedCreateWithoutUserInput>
  }

  export type UserCourseCompletionCreateManyUserInputEnvelope = {
    data: UserCourseCompletionCreateManyUserInput | UserCourseCompletionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ProjectCreateWithoutUserInput = {
    pj_bluePrintNo: string
    pj_serialNumber: string
    pj_projectName: string
    pj_startDate: Date | string
    pj_endDate: Date | string
    pj_amountProduct: number
    pj_totalDay: number
    pj_imageProduct: string
    pj_remark: string
    pj_status: string
    pj_type: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    projectDetail?: ProjectDetailCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutUserInput = {
    id?: number
    pj_bluePrintNo: string
    pj_serialNumber: string
    pj_projectName: string
    pj_startDate: Date | string
    pj_endDate: Date | string
    pj_amountProduct: number
    pj_totalDay: number
    pj_imageProduct: string
    pj_remark: string
    pj_status: string
    pj_type: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    projectDetail?: ProjectDetailUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutUserInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutUserInput, ProjectUncheckedCreateWithoutUserInput>
  }

  export type ProjectCreateManyUserInputEnvelope = {
    data: ProjectCreateManyUserInput | ProjectCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type DepartmentUpsertWithoutUserInput = {
    update: XOR<DepartmentUpdateWithoutUserInput, DepartmentUncheckedUpdateWithoutUserInput>
    create: XOR<DepartmentCreateWithoutUserInput, DepartmentUncheckedCreateWithoutUserInput>
    where?: DepartmentWhereInput
  }

  export type DepartmentUpdateToOneWithWhereWithoutUserInput = {
    where?: DepartmentWhereInput
    data: XOR<DepartmentUpdateWithoutUserInput, DepartmentUncheckedUpdateWithoutUserInput>
  }

  export type DepartmentUpdateWithoutUserInput = {
    departmentName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Course?: CourseUpdateManyWithoutDepartmentNestedInput
  }

  export type DepartmentUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    departmentName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Course?: CourseUncheckedUpdateManyWithoutDepartmentNestedInput
  }

  export type ProcessUpsertWithWhereUniqueWithoutUserInput = {
    where: ProcessWhereUniqueInput
    update: XOR<ProcessUpdateWithoutUserInput, ProcessUncheckedUpdateWithoutUserInput>
    create: XOR<ProcessCreateWithoutUserInput, ProcessUncheckedCreateWithoutUserInput>
  }

  export type ProcessUpdateWithWhereUniqueWithoutUserInput = {
    where: ProcessWhereUniqueInput
    data: XOR<ProcessUpdateWithoutUserInput, ProcessUncheckedUpdateWithoutUserInput>
  }

  export type ProcessUpdateManyWithWhereWithoutUserInput = {
    where: ProcessScalarWhereInput
    data: XOR<ProcessUpdateManyMutationInput, ProcessUncheckedUpdateManyWithoutUserInput>
  }

  export type ProcessScalarWhereInput = {
    AND?: ProcessScalarWhereInput | ProcessScalarWhereInput[]
    OR?: ProcessScalarWhereInput[]
    NOT?: ProcessScalarWhereInput | ProcessScalarWhereInput[]
    id?: IntFilter<"Process"> | number
    pc_bluePrintNo?: StringFilter<"Process"> | string
    pc_imageBluePrint?: StringFilter<"Process"> | string
    pc_totalProcess?: IntFilter<"Process"> | number
    pc_userId?: StringFilter<"Process"> | string
    createdAt?: DateTimeFilter<"Process"> | Date | string
    updatedAt?: DateTimeFilter<"Process"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Process"> | Date | string | null
  }

  export type ExamAttemptUpsertWithWhereUniqueWithoutUserInput = {
    where: ExamAttemptWhereUniqueInput
    update: XOR<ExamAttemptUpdateWithoutUserInput, ExamAttemptUncheckedUpdateWithoutUserInput>
    create: XOR<ExamAttemptCreateWithoutUserInput, ExamAttemptUncheckedCreateWithoutUserInput>
  }

  export type ExamAttemptUpdateWithWhereUniqueWithoutUserInput = {
    where: ExamAttemptWhereUniqueInput
    data: XOR<ExamAttemptUpdateWithoutUserInput, ExamAttemptUncheckedUpdateWithoutUserInput>
  }

  export type ExamAttemptUpdateManyWithWhereWithoutUserInput = {
    where: ExamAttemptScalarWhereInput
    data: XOR<ExamAttemptUpdateManyMutationInput, ExamAttemptUncheckedUpdateManyWithoutUserInput>
  }

  export type ExamAttemptScalarWhereInput = {
    AND?: ExamAttemptScalarWhereInput | ExamAttemptScalarWhereInput[]
    OR?: ExamAttemptScalarWhereInput[]
    NOT?: ExamAttemptScalarWhereInput | ExamAttemptScalarWhereInput[]
    id?: IntFilter<"ExamAttempt"> | number
    userId?: IntFilter<"ExamAttempt"> | number
    examId?: IntFilter<"ExamAttempt"> | number
    startedAt?: DateTimeFilter<"ExamAttempt"> | Date | string
    endedAt?: DateTimeNullableFilter<"ExamAttempt"> | Date | string | null
    grade?: FloatNullableFilter<"ExamAttempt"> | number | null
    isPassed?: BoolNullableFilter<"ExamAttempt"> | boolean | null
  }

  export type EnrollmentUpsertWithWhereUniqueWithoutUserInput = {
    where: EnrollmentWhereUniqueInput
    update: XOR<EnrollmentUpdateWithoutUserInput, EnrollmentUncheckedUpdateWithoutUserInput>
    create: XOR<EnrollmentCreateWithoutUserInput, EnrollmentUncheckedCreateWithoutUserInput>
  }

  export type EnrollmentUpdateWithWhereUniqueWithoutUserInput = {
    where: EnrollmentWhereUniqueInput
    data: XOR<EnrollmentUpdateWithoutUserInput, EnrollmentUncheckedUpdateWithoutUserInput>
  }

  export type EnrollmentUpdateManyWithWhereWithoutUserInput = {
    where: EnrollmentScalarWhereInput
    data: XOR<EnrollmentUpdateManyMutationInput, EnrollmentUncheckedUpdateManyWithoutUserInput>
  }

  export type EnrollmentScalarWhereInput = {
    AND?: EnrollmentScalarWhereInput | EnrollmentScalarWhereInput[]
    OR?: EnrollmentScalarWhereInput[]
    NOT?: EnrollmentScalarWhereInput | EnrollmentScalarWhereInput[]
    id?: IntFilter<"Enrollment"> | number
    userId?: IntFilter<"Enrollment"> | number
    courseId?: IntFilter<"Enrollment"> | number
    progress?: FloatFilter<"Enrollment"> | number
    completed?: BoolFilter<"Enrollment"> | boolean
    isDownloaded?: FloatFilter<"Enrollment"> | number
  }

  export type OplDocumentUpsertWithWhereUniqueWithoutUserInput = {
    where: OplDocumentWhereUniqueInput
    update: XOR<OplDocumentUpdateWithoutUserInput, OplDocumentUncheckedUpdateWithoutUserInput>
    create: XOR<OplDocumentCreateWithoutUserInput, OplDocumentUncheckedCreateWithoutUserInput>
  }

  export type OplDocumentUpdateWithWhereUniqueWithoutUserInput = {
    where: OplDocumentWhereUniqueInput
    data: XOR<OplDocumentUpdateWithoutUserInput, OplDocumentUncheckedUpdateWithoutUserInput>
  }

  export type OplDocumentUpdateManyWithWhereWithoutUserInput = {
    where: OplDocumentScalarWhereInput
    data: XOR<OplDocumentUpdateManyMutationInput, OplDocumentUncheckedUpdateManyWithoutUserInput>
  }

  export type OplDocumentScalarWhereInput = {
    AND?: OplDocumentScalarWhereInput | OplDocumentScalarWhereInput[]
    OR?: OplDocumentScalarWhereInput[]
    NOT?: OplDocumentScalarWhereInput | OplDocumentScalarWhereInput[]
    id?: IntFilter<"OplDocument"> | number
    title?: StringFilter<"OplDocument"> | string
    description?: StringNullableFilter<"OplDocument"> | string | null
    fileName?: StringFilter<"OplDocument"> | string
    fileType?: StringFilter<"OplDocument"> | string
    filePath?: StringFilter<"OplDocument"> | string
    template?: BoolFilter<"OplDocument"> | boolean
    createdAt?: DateTimeFilter<"OplDocument"> | Date | string
    uploadedBy?: IntFilter<"OplDocument"> | number
    updatedAt?: DateTimeFilter<"OplDocument"> | Date | string
    deletedAt?: DateTimeNullableFilter<"OplDocument"> | Date | string | null
  }

  export type FileUpsertWithWhereUniqueWithoutUserInput = {
    where: FileWhereUniqueInput
    update: XOR<FileUpdateWithoutUserInput, FileUncheckedUpdateWithoutUserInput>
    create: XOR<FileCreateWithoutUserInput, FileUncheckedCreateWithoutUserInput>
  }

  export type FileUpdateWithWhereUniqueWithoutUserInput = {
    where: FileWhereUniqueInput
    data: XOR<FileUpdateWithoutUserInput, FileUncheckedUpdateWithoutUserInput>
  }

  export type FileUpdateManyWithWhereWithoutUserInput = {
    where: FileScalarWhereInput
    data: XOR<FileUpdateManyMutationInput, FileUncheckedUpdateManyWithoutUserInput>
  }

  export type FileScalarWhereInput = {
    AND?: FileScalarWhereInput | FileScalarWhereInput[]
    OR?: FileScalarWhereInput[]
    NOT?: FileScalarWhereInput | FileScalarWhereInput[]
    id?: IntFilter<"File"> | number
    originalName?: StringFilter<"File"> | string
    storedName?: StringFilter<"File"> | string
    fileType?: StringFilter<"File"> | string
    fileSize?: BigIntFilter<"File"> | bigint | number
    filePath?: StringFilter<"File"> | string
    uploadDate?: DateTimeFilter<"File"> | Date | string
    userId?: IntNullableFilter<"File"> | number | null
    courseId?: IntNullableFilter<"File"> | number | null
  }

  export type CourseUpsertWithWhereUniqueWithoutCreatorInput = {
    where: CourseWhereUniqueInput
    update: XOR<CourseUpdateWithoutCreatorInput, CourseUncheckedUpdateWithoutCreatorInput>
    create: XOR<CourseCreateWithoutCreatorInput, CourseUncheckedCreateWithoutCreatorInput>
  }

  export type CourseUpdateWithWhereUniqueWithoutCreatorInput = {
    where: CourseWhereUniqueInput
    data: XOR<CourseUpdateWithoutCreatorInput, CourseUncheckedUpdateWithoutCreatorInput>
  }

  export type CourseUpdateManyWithWhereWithoutCreatorInput = {
    where: CourseScalarWhereInput
    data: XOR<CourseUpdateManyMutationInput, CourseUncheckedUpdateManyWithoutCreatorInput>
  }

  export type CourseScalarWhereInput = {
    AND?: CourseScalarWhereInput | CourseScalarWhereInput[]
    OR?: CourseScalarWhereInput[]
    NOT?: CourseScalarWhereInput | CourseScalarWhereInput[]
    id?: IntFilter<"Course"> | number
    title?: StringFilter<"Course"> | string
    description?: StringNullableFilter<"Course"> | string | null
    pdfUrl?: StringNullableFilter<"Course"> | string | null
    videoUrl?: StringNullableFilter<"Course"> | string | null
    typeId?: IntFilter<"Course"> | number
    template?: BoolFilter<"Course"> | boolean
    departmentId?: IntNullableFilter<"Course"> | number | null
    processId?: IntFilter<"Course"> | number
    createdAt?: DateTimeFilter<"Course"> | Date | string
    updatedAt?: DateTimeFilter<"Course"> | Date | string
    createdBy?: IntFilter<"Course"> | number
    deletedBy?: IntNullableFilter<"Course"> | number | null
    isDeleted?: BoolFilter<"Course"> | boolean
  }

  export type CourseUpsertWithWhereUniqueWithoutDeleterInput = {
    where: CourseWhereUniqueInput
    update: XOR<CourseUpdateWithoutDeleterInput, CourseUncheckedUpdateWithoutDeleterInput>
    create: XOR<CourseCreateWithoutDeleterInput, CourseUncheckedCreateWithoutDeleterInput>
  }

  export type CourseUpdateWithWhereUniqueWithoutDeleterInput = {
    where: CourseWhereUniqueInput
    data: XOR<CourseUpdateWithoutDeleterInput, CourseUncheckedUpdateWithoutDeleterInput>
  }

  export type CourseUpdateManyWithWhereWithoutDeleterInput = {
    where: CourseScalarWhereInput
    data: XOR<CourseUpdateManyMutationInput, CourseUncheckedUpdateManyWithoutDeleterInput>
  }

  export type UserCourseCompletionUpsertWithWhereUniqueWithoutUserInput = {
    where: UserCourseCompletionWhereUniqueInput
    update: XOR<UserCourseCompletionUpdateWithoutUserInput, UserCourseCompletionUncheckedUpdateWithoutUserInput>
    create: XOR<UserCourseCompletionCreateWithoutUserInput, UserCourseCompletionUncheckedCreateWithoutUserInput>
  }

  export type UserCourseCompletionUpdateWithWhereUniqueWithoutUserInput = {
    where: UserCourseCompletionWhereUniqueInput
    data: XOR<UserCourseCompletionUpdateWithoutUserInput, UserCourseCompletionUncheckedUpdateWithoutUserInput>
  }

  export type UserCourseCompletionUpdateManyWithWhereWithoutUserInput = {
    where: UserCourseCompletionScalarWhereInput
    data: XOR<UserCourseCompletionUpdateManyMutationInput, UserCourseCompletionUncheckedUpdateManyWithoutUserInput>
  }

  export type UserCourseCompletionScalarWhereInput = {
    AND?: UserCourseCompletionScalarWhereInput | UserCourseCompletionScalarWhereInput[]
    OR?: UserCourseCompletionScalarWhereInput[]
    NOT?: UserCourseCompletionScalarWhereInput | UserCourseCompletionScalarWhereInput[]
    id?: IntFilter<"UserCourseCompletion"> | number
    userId?: IntFilter<"UserCourseCompletion"> | number
    username?: StringFilter<"UserCourseCompletion"> | string
    courseId?: IntFilter<"UserCourseCompletion"> | number
    examId?: IntFilter<"UserCourseCompletion"> | number
    processId?: IntFilter<"UserCourseCompletion"> | number
    completedAt?: DateTimeFilter<"UserCourseCompletion"> | Date | string
    createdAt?: DateTimeFilter<"UserCourseCompletion"> | Date | string
    updatedAt?: DateTimeFilter<"UserCourseCompletion"> | Date | string
  }

  export type ProjectUpsertWithWhereUniqueWithoutUserInput = {
    where: ProjectWhereUniqueInput
    update: XOR<ProjectUpdateWithoutUserInput, ProjectUncheckedUpdateWithoutUserInput>
    create: XOR<ProjectCreateWithoutUserInput, ProjectUncheckedCreateWithoutUserInput>
  }

  export type ProjectUpdateWithWhereUniqueWithoutUserInput = {
    where: ProjectWhereUniqueInput
    data: XOR<ProjectUpdateWithoutUserInput, ProjectUncheckedUpdateWithoutUserInput>
  }

  export type ProjectUpdateManyWithWhereWithoutUserInput = {
    where: ProjectScalarWhereInput
    data: XOR<ProjectUpdateManyMutationInput, ProjectUncheckedUpdateManyWithoutUserInput>
  }

  export type ProjectScalarWhereInput = {
    AND?: ProjectScalarWhereInput | ProjectScalarWhereInput[]
    OR?: ProjectScalarWhereInput[]
    NOT?: ProjectScalarWhereInput | ProjectScalarWhereInput[]
    id?: IntFilter<"Project"> | number
    pj_bluePrintNo?: StringFilter<"Project"> | string
    pj_serialNumber?: StringFilter<"Project"> | string
    pj_projectName?: StringFilter<"Project"> | string
    pj_startDate?: DateTimeFilter<"Project"> | Date | string
    pj_endDate?: DateTimeFilter<"Project"> | Date | string
    pj_amountProduct?: IntFilter<"Project"> | number
    pj_totalDay?: IntFilter<"Project"> | number
    pj_imageProduct?: StringFilter<"Project"> | string
    pj_remark?: StringFilter<"Project"> | string
    pj_status?: StringFilter<"Project"> | string
    pj_type?: StringFilter<"Project"> | string
    pj_userId?: StringFilter<"Project"> | string
    createdAt?: DateTimeFilter<"Project"> | Date | string
    updatedAt?: DateTimeFilter<"Project"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Project"> | Date | string | null
  }

  export type CompanyBranchCreateWithoutCompanyInput = {
    companyBranchName: string
  }

  export type CompanyBranchUncheckedCreateWithoutCompanyInput = {
    id?: number
    companyBranchName: string
  }

  export type CompanyBranchCreateOrConnectWithoutCompanyInput = {
    where: CompanyBranchWhereUniqueInput
    create: XOR<CompanyBranchCreateWithoutCompanyInput, CompanyBranchUncheckedCreateWithoutCompanyInput>
  }

  export type CompanyBranchCreateManyCompanyInputEnvelope = {
    data: CompanyBranchCreateManyCompanyInput | CompanyBranchCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type CompanyBranchUpsertWithWhereUniqueWithoutCompanyInput = {
    where: CompanyBranchWhereUniqueInput
    update: XOR<CompanyBranchUpdateWithoutCompanyInput, CompanyBranchUncheckedUpdateWithoutCompanyInput>
    create: XOR<CompanyBranchCreateWithoutCompanyInput, CompanyBranchUncheckedCreateWithoutCompanyInput>
  }

  export type CompanyBranchUpdateWithWhereUniqueWithoutCompanyInput = {
    where: CompanyBranchWhereUniqueInput
    data: XOR<CompanyBranchUpdateWithoutCompanyInput, CompanyBranchUncheckedUpdateWithoutCompanyInput>
  }

  export type CompanyBranchUpdateManyWithWhereWithoutCompanyInput = {
    where: CompanyBranchScalarWhereInput
    data: XOR<CompanyBranchUpdateManyMutationInput, CompanyBranchUncheckedUpdateManyWithoutCompanyInput>
  }

  export type CompanyBranchScalarWhereInput = {
    AND?: CompanyBranchScalarWhereInput | CompanyBranchScalarWhereInput[]
    OR?: CompanyBranchScalarWhereInput[]
    NOT?: CompanyBranchScalarWhereInput | CompanyBranchScalarWhereInput[]
    id?: IntFilter<"CompanyBranch"> | number
    companyId?: IntFilter<"CompanyBranch"> | number
    companyBranchName?: StringFilter<"CompanyBranch"> | string
  }

  export type CompanyCreateWithoutCompanyBranchInput = {
    companyName: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type CompanyUncheckedCreateWithoutCompanyBranchInput = {
    id?: number
    companyName: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type CompanyCreateOrConnectWithoutCompanyBranchInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutCompanyBranchInput, CompanyUncheckedCreateWithoutCompanyBranchInput>
  }

  export type CompanyUpsertWithoutCompanyBranchInput = {
    update: XOR<CompanyUpdateWithoutCompanyBranchInput, CompanyUncheckedUpdateWithoutCompanyBranchInput>
    create: XOR<CompanyCreateWithoutCompanyBranchInput, CompanyUncheckedCreateWithoutCompanyBranchInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutCompanyBranchInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutCompanyBranchInput, CompanyUncheckedUpdateWithoutCompanyBranchInput>
  }

  export type CompanyUpdateWithoutCompanyBranchInput = {
    companyName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CompanyUncheckedUpdateWithoutCompanyBranchInput = {
    id?: IntFieldUpdateOperationsInput | number
    companyName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserCreateWithoutDepartmentInput = {
    userId: string
    firstName: string
    lastName: string
    password: string
    companyId?: number | null
    companyBranchId?: number | null
    role: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    processes?: ProcessCreateNestedManyWithoutUserInput
    exams?: ExamAttemptCreateNestedManyWithoutUserInput
    enrollments?: EnrollmentCreateNestedManyWithoutUserInput
    oplDocuments?: OplDocumentCreateNestedManyWithoutUserInput
    files?: FileCreateNestedManyWithoutUserInput
    createdCourses?: CourseCreateNestedManyWithoutCreatorInput
    deletedCourses?: CourseCreateNestedManyWithoutDeleterInput
    courseCompletions?: UserCourseCompletionCreateNestedManyWithoutUserInput
    project?: ProjectCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutDepartmentInput = {
    id?: number
    userId: string
    firstName: string
    lastName: string
    password: string
    companyId?: number | null
    companyBranchId?: number | null
    role: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    processes?: ProcessUncheckedCreateNestedManyWithoutUserInput
    exams?: ExamAttemptUncheckedCreateNestedManyWithoutUserInput
    enrollments?: EnrollmentUncheckedCreateNestedManyWithoutUserInput
    oplDocuments?: OplDocumentUncheckedCreateNestedManyWithoutUserInput
    files?: FileUncheckedCreateNestedManyWithoutUserInput
    createdCourses?: CourseUncheckedCreateNestedManyWithoutCreatorInput
    deletedCourses?: CourseUncheckedCreateNestedManyWithoutDeleterInput
    courseCompletions?: UserCourseCompletionUncheckedCreateNestedManyWithoutUserInput
    project?: ProjectUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutDepartmentInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutDepartmentInput, UserUncheckedCreateWithoutDepartmentInput>
  }

  export type UserCreateManyDepartmentInputEnvelope = {
    data: UserCreateManyDepartmentInput | UserCreateManyDepartmentInput[]
    skipDuplicates?: boolean
  }

  export type CourseCreateWithoutDepartmentInput = {
    title: string
    description?: string | null
    pdfUrl?: string | null
    videoUrl?: string | null
    typeId: number
    template?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    process?: ProcessCreateNestedOneWithoutCoursesInput
    enrollments?: EnrollmentCreateNestedManyWithoutCourseInput
    files?: FileCreateNestedManyWithoutCourseInput
    exams?: ExamCreateNestedManyWithoutCourseInput
    completions?: UserCourseCompletionCreateNestedManyWithoutCourseInput
    creator: UserCreateNestedOneWithoutCreatedCoursesInput
    deleter?: UserCreateNestedOneWithoutDeletedCoursesInput
  }

  export type CourseUncheckedCreateWithoutDepartmentInput = {
    id?: number
    title: string
    description?: string | null
    pdfUrl?: string | null
    videoUrl?: string | null
    typeId: number
    template?: boolean
    processId?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: number
    deletedBy?: number | null
    isDeleted?: boolean
    enrollments?: EnrollmentUncheckedCreateNestedManyWithoutCourseInput
    files?: FileUncheckedCreateNestedManyWithoutCourseInput
    exams?: ExamUncheckedCreateNestedManyWithoutCourseInput
    completions?: UserCourseCompletionUncheckedCreateNestedManyWithoutCourseInput
  }

  export type CourseCreateOrConnectWithoutDepartmentInput = {
    where: CourseWhereUniqueInput
    create: XOR<CourseCreateWithoutDepartmentInput, CourseUncheckedCreateWithoutDepartmentInput>
  }

  export type CourseCreateManyDepartmentInputEnvelope = {
    data: CourseCreateManyDepartmentInput | CourseCreateManyDepartmentInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithWhereUniqueWithoutDepartmentInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutDepartmentInput, UserUncheckedUpdateWithoutDepartmentInput>
    create: XOR<UserCreateWithoutDepartmentInput, UserUncheckedCreateWithoutDepartmentInput>
  }

  export type UserUpdateWithWhereUniqueWithoutDepartmentInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutDepartmentInput, UserUncheckedUpdateWithoutDepartmentInput>
  }

  export type UserUpdateManyWithWhereWithoutDepartmentInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutDepartmentInput>
  }

  export type UserScalarWhereInput = {
    AND?: UserScalarWhereInput | UserScalarWhereInput[]
    OR?: UserScalarWhereInput[]
    NOT?: UserScalarWhereInput | UserScalarWhereInput[]
    id?: IntFilter<"User"> | number
    userId?: StringFilter<"User"> | string
    firstName?: StringFilter<"User"> | string
    lastName?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    companyId?: IntNullableFilter<"User"> | number | null
    companyBranchId?: IntNullableFilter<"User"> | number | null
    departmentId?: IntNullableFilter<"User"> | number | null
    role?: StringFilter<"User"> | string
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    deletedAt?: DateTimeNullableFilter<"User"> | Date | string | null
  }

  export type CourseUpsertWithWhereUniqueWithoutDepartmentInput = {
    where: CourseWhereUniqueInput
    update: XOR<CourseUpdateWithoutDepartmentInput, CourseUncheckedUpdateWithoutDepartmentInput>
    create: XOR<CourseCreateWithoutDepartmentInput, CourseUncheckedCreateWithoutDepartmentInput>
  }

  export type CourseUpdateWithWhereUniqueWithoutDepartmentInput = {
    where: CourseWhereUniqueInput
    data: XOR<CourseUpdateWithoutDepartmentInput, CourseUncheckedUpdateWithoutDepartmentInput>
  }

  export type CourseUpdateManyWithWhereWithoutDepartmentInput = {
    where: CourseScalarWhereInput
    data: XOR<CourseUpdateManyMutationInput, CourseUncheckedUpdateManyWithoutDepartmentInput>
  }

  export type DepartmentCreateWithoutCourseInput = {
    departmentName: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    user?: UserCreateNestedManyWithoutDepartmentInput
  }

  export type DepartmentUncheckedCreateWithoutCourseInput = {
    id?: number
    departmentName: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    user?: UserUncheckedCreateNestedManyWithoutDepartmentInput
  }

  export type DepartmentCreateOrConnectWithoutCourseInput = {
    where: DepartmentWhereUniqueInput
    create: XOR<DepartmentCreateWithoutCourseInput, DepartmentUncheckedCreateWithoutCourseInput>
  }

  export type ProcessCreateWithoutCoursesInput = {
    pc_bluePrintNo: string
    pc_imageBluePrint: string
    pc_totalProcess: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    user: UserCreateNestedOneWithoutProcessesInput
    completions?: UserCourseCompletionCreateNestedManyWithoutProcessInput
    processDetail?: ProcessDetailCreateNestedManyWithoutProcessInput
  }

  export type ProcessUncheckedCreateWithoutCoursesInput = {
    id?: number
    pc_bluePrintNo: string
    pc_imageBluePrint: string
    pc_totalProcess: number
    pc_userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    completions?: UserCourseCompletionUncheckedCreateNestedManyWithoutProcessInput
    processDetail?: ProcessDetailUncheckedCreateNestedManyWithoutProcessInput
  }

  export type ProcessCreateOrConnectWithoutCoursesInput = {
    where: ProcessWhereUniqueInput
    create: XOR<ProcessCreateWithoutCoursesInput, ProcessUncheckedCreateWithoutCoursesInput>
  }

  export type EnrollmentCreateWithoutCourseInput = {
    progress: number
    completed?: boolean
    isDownloaded?: number
    user: UserCreateNestedOneWithoutEnrollmentsInput
  }

  export type EnrollmentUncheckedCreateWithoutCourseInput = {
    id?: number
    userId: number
    progress: number
    completed?: boolean
    isDownloaded?: number
  }

  export type EnrollmentCreateOrConnectWithoutCourseInput = {
    where: EnrollmentWhereUniqueInput
    create: XOR<EnrollmentCreateWithoutCourseInput, EnrollmentUncheckedCreateWithoutCourseInput>
  }

  export type EnrollmentCreateManyCourseInputEnvelope = {
    data: EnrollmentCreateManyCourseInput | EnrollmentCreateManyCourseInput[]
    skipDuplicates?: boolean
  }

  export type FileCreateWithoutCourseInput = {
    originalName: string
    storedName: string
    fileType: string
    fileSize: bigint | number
    filePath: string
    uploadDate?: Date | string
    user?: UserCreateNestedOneWithoutFilesInput
  }

  export type FileUncheckedCreateWithoutCourseInput = {
    id?: number
    originalName: string
    storedName: string
    fileType: string
    fileSize: bigint | number
    filePath: string
    uploadDate?: Date | string
    userId?: number | null
  }

  export type FileCreateOrConnectWithoutCourseInput = {
    where: FileWhereUniqueInput
    create: XOR<FileCreateWithoutCourseInput, FileUncheckedCreateWithoutCourseInput>
  }

  export type FileCreateManyCourseInputEnvelope = {
    data: FileCreateManyCourseInput | FileCreateManyCourseInput[]
    skipDuplicates?: boolean
  }

  export type ExamCreateWithoutCourseInput = {
    title: string
    departmentId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    description?: string | null
    deleted?: boolean
    questions?: QuestionCreateNestedManyWithoutExamInput
    attempts?: ExamAttemptCreateNestedManyWithoutExamInput
    completions?: UserCourseCompletionCreateNestedManyWithoutExamInput
  }

  export type ExamUncheckedCreateWithoutCourseInput = {
    id?: number
    title: string
    departmentId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    description?: string | null
    deleted?: boolean
    questions?: QuestionUncheckedCreateNestedManyWithoutExamInput
    attempts?: ExamAttemptUncheckedCreateNestedManyWithoutExamInput
    completions?: UserCourseCompletionUncheckedCreateNestedManyWithoutExamInput
  }

  export type ExamCreateOrConnectWithoutCourseInput = {
    where: ExamWhereUniqueInput
    create: XOR<ExamCreateWithoutCourseInput, ExamUncheckedCreateWithoutCourseInput>
  }

  export type ExamCreateManyCourseInputEnvelope = {
    data: ExamCreateManyCourseInput | ExamCreateManyCourseInput[]
    skipDuplicates?: boolean
  }

  export type UserCourseCompletionCreateWithoutCourseInput = {
    completedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutCourseCompletionsInput
    exam: ExamCreateNestedOneWithoutCompletionsInput
    process: ProcessCreateNestedOneWithoutCompletionsInput
  }

  export type UserCourseCompletionUncheckedCreateWithoutCourseInput = {
    id?: number
    userId: number
    username: string
    examId: number
    processId: number
    completedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserCourseCompletionCreateOrConnectWithoutCourseInput = {
    where: UserCourseCompletionWhereUniqueInput
    create: XOR<UserCourseCompletionCreateWithoutCourseInput, UserCourseCompletionUncheckedCreateWithoutCourseInput>
  }

  export type UserCourseCompletionCreateManyCourseInputEnvelope = {
    data: UserCourseCompletionCreateManyCourseInput | UserCourseCompletionCreateManyCourseInput[]
    skipDuplicates?: boolean
  }

  export type UserCreateWithoutCreatedCoursesInput = {
    userId: string
    firstName: string
    lastName: string
    password: string
    companyId?: number | null
    companyBranchId?: number | null
    role: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    department?: DepartmentCreateNestedOneWithoutUserInput
    processes?: ProcessCreateNestedManyWithoutUserInput
    exams?: ExamAttemptCreateNestedManyWithoutUserInput
    enrollments?: EnrollmentCreateNestedManyWithoutUserInput
    oplDocuments?: OplDocumentCreateNestedManyWithoutUserInput
    files?: FileCreateNestedManyWithoutUserInput
    deletedCourses?: CourseCreateNestedManyWithoutDeleterInput
    courseCompletions?: UserCourseCompletionCreateNestedManyWithoutUserInput
    project?: ProjectCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCreatedCoursesInput = {
    id?: number
    userId: string
    firstName: string
    lastName: string
    password: string
    companyId?: number | null
    companyBranchId?: number | null
    departmentId?: number | null
    role: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    processes?: ProcessUncheckedCreateNestedManyWithoutUserInput
    exams?: ExamAttemptUncheckedCreateNestedManyWithoutUserInput
    enrollments?: EnrollmentUncheckedCreateNestedManyWithoutUserInput
    oplDocuments?: OplDocumentUncheckedCreateNestedManyWithoutUserInput
    files?: FileUncheckedCreateNestedManyWithoutUserInput
    deletedCourses?: CourseUncheckedCreateNestedManyWithoutDeleterInput
    courseCompletions?: UserCourseCompletionUncheckedCreateNestedManyWithoutUserInput
    project?: ProjectUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCreatedCoursesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCreatedCoursesInput, UserUncheckedCreateWithoutCreatedCoursesInput>
  }

  export type UserCreateWithoutDeletedCoursesInput = {
    userId: string
    firstName: string
    lastName: string
    password: string
    companyId?: number | null
    companyBranchId?: number | null
    role: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    department?: DepartmentCreateNestedOneWithoutUserInput
    processes?: ProcessCreateNestedManyWithoutUserInput
    exams?: ExamAttemptCreateNestedManyWithoutUserInput
    enrollments?: EnrollmentCreateNestedManyWithoutUserInput
    oplDocuments?: OplDocumentCreateNestedManyWithoutUserInput
    files?: FileCreateNestedManyWithoutUserInput
    createdCourses?: CourseCreateNestedManyWithoutCreatorInput
    courseCompletions?: UserCourseCompletionCreateNestedManyWithoutUserInput
    project?: ProjectCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutDeletedCoursesInput = {
    id?: number
    userId: string
    firstName: string
    lastName: string
    password: string
    companyId?: number | null
    companyBranchId?: number | null
    departmentId?: number | null
    role: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    processes?: ProcessUncheckedCreateNestedManyWithoutUserInput
    exams?: ExamAttemptUncheckedCreateNestedManyWithoutUserInput
    enrollments?: EnrollmentUncheckedCreateNestedManyWithoutUserInput
    oplDocuments?: OplDocumentUncheckedCreateNestedManyWithoutUserInput
    files?: FileUncheckedCreateNestedManyWithoutUserInput
    createdCourses?: CourseUncheckedCreateNestedManyWithoutCreatorInput
    courseCompletions?: UserCourseCompletionUncheckedCreateNestedManyWithoutUserInput
    project?: ProjectUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutDeletedCoursesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutDeletedCoursesInput, UserUncheckedCreateWithoutDeletedCoursesInput>
  }

  export type DepartmentUpsertWithoutCourseInput = {
    update: XOR<DepartmentUpdateWithoutCourseInput, DepartmentUncheckedUpdateWithoutCourseInput>
    create: XOR<DepartmentCreateWithoutCourseInput, DepartmentUncheckedCreateWithoutCourseInput>
    where?: DepartmentWhereInput
  }

  export type DepartmentUpdateToOneWithWhereWithoutCourseInput = {
    where?: DepartmentWhereInput
    data: XOR<DepartmentUpdateWithoutCourseInput, DepartmentUncheckedUpdateWithoutCourseInput>
  }

  export type DepartmentUpdateWithoutCourseInput = {
    departmentName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateManyWithoutDepartmentNestedInput
  }

  export type DepartmentUncheckedUpdateWithoutCourseInput = {
    id?: IntFieldUpdateOperationsInput | number
    departmentName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUncheckedUpdateManyWithoutDepartmentNestedInput
  }

  export type ProcessUpsertWithoutCoursesInput = {
    update: XOR<ProcessUpdateWithoutCoursesInput, ProcessUncheckedUpdateWithoutCoursesInput>
    create: XOR<ProcessCreateWithoutCoursesInput, ProcessUncheckedCreateWithoutCoursesInput>
    where?: ProcessWhereInput
  }

  export type ProcessUpdateToOneWithWhereWithoutCoursesInput = {
    where?: ProcessWhereInput
    data: XOR<ProcessUpdateWithoutCoursesInput, ProcessUncheckedUpdateWithoutCoursesInput>
  }

  export type ProcessUpdateWithoutCoursesInput = {
    pc_bluePrintNo?: StringFieldUpdateOperationsInput | string
    pc_imageBluePrint?: StringFieldUpdateOperationsInput | string
    pc_totalProcess?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutProcessesNestedInput
    completions?: UserCourseCompletionUpdateManyWithoutProcessNestedInput
    processDetail?: ProcessDetailUpdateManyWithoutProcessNestedInput
  }

  export type ProcessUncheckedUpdateWithoutCoursesInput = {
    id?: IntFieldUpdateOperationsInput | number
    pc_bluePrintNo?: StringFieldUpdateOperationsInput | string
    pc_imageBluePrint?: StringFieldUpdateOperationsInput | string
    pc_totalProcess?: IntFieldUpdateOperationsInput | number
    pc_userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completions?: UserCourseCompletionUncheckedUpdateManyWithoutProcessNestedInput
    processDetail?: ProcessDetailUncheckedUpdateManyWithoutProcessNestedInput
  }

  export type EnrollmentUpsertWithWhereUniqueWithoutCourseInput = {
    where: EnrollmentWhereUniqueInput
    update: XOR<EnrollmentUpdateWithoutCourseInput, EnrollmentUncheckedUpdateWithoutCourseInput>
    create: XOR<EnrollmentCreateWithoutCourseInput, EnrollmentUncheckedCreateWithoutCourseInput>
  }

  export type EnrollmentUpdateWithWhereUniqueWithoutCourseInput = {
    where: EnrollmentWhereUniqueInput
    data: XOR<EnrollmentUpdateWithoutCourseInput, EnrollmentUncheckedUpdateWithoutCourseInput>
  }

  export type EnrollmentUpdateManyWithWhereWithoutCourseInput = {
    where: EnrollmentScalarWhereInput
    data: XOR<EnrollmentUpdateManyMutationInput, EnrollmentUncheckedUpdateManyWithoutCourseInput>
  }

  export type FileUpsertWithWhereUniqueWithoutCourseInput = {
    where: FileWhereUniqueInput
    update: XOR<FileUpdateWithoutCourseInput, FileUncheckedUpdateWithoutCourseInput>
    create: XOR<FileCreateWithoutCourseInput, FileUncheckedCreateWithoutCourseInput>
  }

  export type FileUpdateWithWhereUniqueWithoutCourseInput = {
    where: FileWhereUniqueInput
    data: XOR<FileUpdateWithoutCourseInput, FileUncheckedUpdateWithoutCourseInput>
  }

  export type FileUpdateManyWithWhereWithoutCourseInput = {
    where: FileScalarWhereInput
    data: XOR<FileUpdateManyMutationInput, FileUncheckedUpdateManyWithoutCourseInput>
  }

  export type ExamUpsertWithWhereUniqueWithoutCourseInput = {
    where: ExamWhereUniqueInput
    update: XOR<ExamUpdateWithoutCourseInput, ExamUncheckedUpdateWithoutCourseInput>
    create: XOR<ExamCreateWithoutCourseInput, ExamUncheckedCreateWithoutCourseInput>
  }

  export type ExamUpdateWithWhereUniqueWithoutCourseInput = {
    where: ExamWhereUniqueInput
    data: XOR<ExamUpdateWithoutCourseInput, ExamUncheckedUpdateWithoutCourseInput>
  }

  export type ExamUpdateManyWithWhereWithoutCourseInput = {
    where: ExamScalarWhereInput
    data: XOR<ExamUpdateManyMutationInput, ExamUncheckedUpdateManyWithoutCourseInput>
  }

  export type ExamScalarWhereInput = {
    AND?: ExamScalarWhereInput | ExamScalarWhereInput[]
    OR?: ExamScalarWhereInput[]
    NOT?: ExamScalarWhereInput | ExamScalarWhereInput[]
    id?: IntFilter<"Exam"> | number
    title?: StringFilter<"Exam"> | string
    departmentId?: IntNullableFilter<"Exam"> | number | null
    createdAt?: DateTimeFilter<"Exam"> | Date | string
    updatedAt?: DateTimeFilter<"Exam"> | Date | string
    courseId?: IntNullableFilter<"Exam"> | number | null
    description?: StringNullableFilter<"Exam"> | string | null
    deleted?: BoolFilter<"Exam"> | boolean
  }

  export type UserCourseCompletionUpsertWithWhereUniqueWithoutCourseInput = {
    where: UserCourseCompletionWhereUniqueInput
    update: XOR<UserCourseCompletionUpdateWithoutCourseInput, UserCourseCompletionUncheckedUpdateWithoutCourseInput>
    create: XOR<UserCourseCompletionCreateWithoutCourseInput, UserCourseCompletionUncheckedCreateWithoutCourseInput>
  }

  export type UserCourseCompletionUpdateWithWhereUniqueWithoutCourseInput = {
    where: UserCourseCompletionWhereUniqueInput
    data: XOR<UserCourseCompletionUpdateWithoutCourseInput, UserCourseCompletionUncheckedUpdateWithoutCourseInput>
  }

  export type UserCourseCompletionUpdateManyWithWhereWithoutCourseInput = {
    where: UserCourseCompletionScalarWhereInput
    data: XOR<UserCourseCompletionUpdateManyMutationInput, UserCourseCompletionUncheckedUpdateManyWithoutCourseInput>
  }

  export type UserUpsertWithoutCreatedCoursesInput = {
    update: XOR<UserUpdateWithoutCreatedCoursesInput, UserUncheckedUpdateWithoutCreatedCoursesInput>
    create: XOR<UserCreateWithoutCreatedCoursesInput, UserUncheckedCreateWithoutCreatedCoursesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCreatedCoursesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCreatedCoursesInput, UserUncheckedUpdateWithoutCreatedCoursesInput>
  }

  export type UserUpdateWithoutCreatedCoursesInput = {
    userId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    companyId?: NullableIntFieldUpdateOperationsInput | number | null
    companyBranchId?: NullableIntFieldUpdateOperationsInput | number | null
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    department?: DepartmentUpdateOneWithoutUserNestedInput
    processes?: ProcessUpdateManyWithoutUserNestedInput
    exams?: ExamAttemptUpdateManyWithoutUserNestedInput
    enrollments?: EnrollmentUpdateManyWithoutUserNestedInput
    oplDocuments?: OplDocumentUpdateManyWithoutUserNestedInput
    files?: FileUpdateManyWithoutUserNestedInput
    deletedCourses?: CourseUpdateManyWithoutDeleterNestedInput
    courseCompletions?: UserCourseCompletionUpdateManyWithoutUserNestedInput
    project?: ProjectUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCreatedCoursesInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    companyId?: NullableIntFieldUpdateOperationsInput | number | null
    companyBranchId?: NullableIntFieldUpdateOperationsInput | number | null
    departmentId?: NullableIntFieldUpdateOperationsInput | number | null
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    processes?: ProcessUncheckedUpdateManyWithoutUserNestedInput
    exams?: ExamAttemptUncheckedUpdateManyWithoutUserNestedInput
    enrollments?: EnrollmentUncheckedUpdateManyWithoutUserNestedInput
    oplDocuments?: OplDocumentUncheckedUpdateManyWithoutUserNestedInput
    files?: FileUncheckedUpdateManyWithoutUserNestedInput
    deletedCourses?: CourseUncheckedUpdateManyWithoutDeleterNestedInput
    courseCompletions?: UserCourseCompletionUncheckedUpdateManyWithoutUserNestedInput
    project?: ProjectUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUpsertWithoutDeletedCoursesInput = {
    update: XOR<UserUpdateWithoutDeletedCoursesInput, UserUncheckedUpdateWithoutDeletedCoursesInput>
    create: XOR<UserCreateWithoutDeletedCoursesInput, UserUncheckedCreateWithoutDeletedCoursesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutDeletedCoursesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutDeletedCoursesInput, UserUncheckedUpdateWithoutDeletedCoursesInput>
  }

  export type UserUpdateWithoutDeletedCoursesInput = {
    userId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    companyId?: NullableIntFieldUpdateOperationsInput | number | null
    companyBranchId?: NullableIntFieldUpdateOperationsInput | number | null
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    department?: DepartmentUpdateOneWithoutUserNestedInput
    processes?: ProcessUpdateManyWithoutUserNestedInput
    exams?: ExamAttemptUpdateManyWithoutUserNestedInput
    enrollments?: EnrollmentUpdateManyWithoutUserNestedInput
    oplDocuments?: OplDocumentUpdateManyWithoutUserNestedInput
    files?: FileUpdateManyWithoutUserNestedInput
    createdCourses?: CourseUpdateManyWithoutCreatorNestedInput
    courseCompletions?: UserCourseCompletionUpdateManyWithoutUserNestedInput
    project?: ProjectUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutDeletedCoursesInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    companyId?: NullableIntFieldUpdateOperationsInput | number | null
    companyBranchId?: NullableIntFieldUpdateOperationsInput | number | null
    departmentId?: NullableIntFieldUpdateOperationsInput | number | null
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    processes?: ProcessUncheckedUpdateManyWithoutUserNestedInput
    exams?: ExamAttemptUncheckedUpdateManyWithoutUserNestedInput
    enrollments?: EnrollmentUncheckedUpdateManyWithoutUserNestedInput
    oplDocuments?: OplDocumentUncheckedUpdateManyWithoutUserNestedInput
    files?: FileUncheckedUpdateManyWithoutUserNestedInput
    createdCourses?: CourseUncheckedUpdateManyWithoutCreatorNestedInput
    courseCompletions?: UserCourseCompletionUncheckedUpdateManyWithoutUserNestedInput
    project?: ProjectUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutCourseCompletionsInput = {
    userId: string
    firstName: string
    lastName: string
    password: string
    companyId?: number | null
    companyBranchId?: number | null
    role: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    department?: DepartmentCreateNestedOneWithoutUserInput
    processes?: ProcessCreateNestedManyWithoutUserInput
    exams?: ExamAttemptCreateNestedManyWithoutUserInput
    enrollments?: EnrollmentCreateNestedManyWithoutUserInput
    oplDocuments?: OplDocumentCreateNestedManyWithoutUserInput
    files?: FileCreateNestedManyWithoutUserInput
    createdCourses?: CourseCreateNestedManyWithoutCreatorInput
    deletedCourses?: CourseCreateNestedManyWithoutDeleterInput
    project?: ProjectCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCourseCompletionsInput = {
    id?: number
    userId: string
    firstName: string
    lastName: string
    password: string
    companyId?: number | null
    companyBranchId?: number | null
    departmentId?: number | null
    role: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    processes?: ProcessUncheckedCreateNestedManyWithoutUserInput
    exams?: ExamAttemptUncheckedCreateNestedManyWithoutUserInput
    enrollments?: EnrollmentUncheckedCreateNestedManyWithoutUserInput
    oplDocuments?: OplDocumentUncheckedCreateNestedManyWithoutUserInput
    files?: FileUncheckedCreateNestedManyWithoutUserInput
    createdCourses?: CourseUncheckedCreateNestedManyWithoutCreatorInput
    deletedCourses?: CourseUncheckedCreateNestedManyWithoutDeleterInput
    project?: ProjectUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCourseCompletionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCourseCompletionsInput, UserUncheckedCreateWithoutCourseCompletionsInput>
  }

  export type CourseCreateWithoutCompletionsInput = {
    title: string
    description?: string | null
    pdfUrl?: string | null
    videoUrl?: string | null
    typeId: number
    template?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    department?: DepartmentCreateNestedOneWithoutCourseInput
    process?: ProcessCreateNestedOneWithoutCoursesInput
    enrollments?: EnrollmentCreateNestedManyWithoutCourseInput
    files?: FileCreateNestedManyWithoutCourseInput
    exams?: ExamCreateNestedManyWithoutCourseInput
    creator: UserCreateNestedOneWithoutCreatedCoursesInput
    deleter?: UserCreateNestedOneWithoutDeletedCoursesInput
  }

  export type CourseUncheckedCreateWithoutCompletionsInput = {
    id?: number
    title: string
    description?: string | null
    pdfUrl?: string | null
    videoUrl?: string | null
    typeId: number
    template?: boolean
    departmentId?: number | null
    processId?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: number
    deletedBy?: number | null
    isDeleted?: boolean
    enrollments?: EnrollmentUncheckedCreateNestedManyWithoutCourseInput
    files?: FileUncheckedCreateNestedManyWithoutCourseInput
    exams?: ExamUncheckedCreateNestedManyWithoutCourseInput
  }

  export type CourseCreateOrConnectWithoutCompletionsInput = {
    where: CourseWhereUniqueInput
    create: XOR<CourseCreateWithoutCompletionsInput, CourseUncheckedCreateWithoutCompletionsInput>
  }

  export type ExamCreateWithoutCompletionsInput = {
    title: string
    departmentId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    description?: string | null
    deleted?: boolean
    questions?: QuestionCreateNestedManyWithoutExamInput
    attempts?: ExamAttemptCreateNestedManyWithoutExamInput
    course?: CourseCreateNestedOneWithoutExamsInput
  }

  export type ExamUncheckedCreateWithoutCompletionsInput = {
    id?: number
    title: string
    departmentId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    courseId?: number | null
    description?: string | null
    deleted?: boolean
    questions?: QuestionUncheckedCreateNestedManyWithoutExamInput
    attempts?: ExamAttemptUncheckedCreateNestedManyWithoutExamInput
  }

  export type ExamCreateOrConnectWithoutCompletionsInput = {
    where: ExamWhereUniqueInput
    create: XOR<ExamCreateWithoutCompletionsInput, ExamUncheckedCreateWithoutCompletionsInput>
  }

  export type ProcessCreateWithoutCompletionsInput = {
    pc_bluePrintNo: string
    pc_imageBluePrint: string
    pc_totalProcess: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    user: UserCreateNestedOneWithoutProcessesInput
    courses?: CourseCreateNestedManyWithoutProcessInput
    processDetail?: ProcessDetailCreateNestedManyWithoutProcessInput
  }

  export type ProcessUncheckedCreateWithoutCompletionsInput = {
    id?: number
    pc_bluePrintNo: string
    pc_imageBluePrint: string
    pc_totalProcess: number
    pc_userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    courses?: CourseUncheckedCreateNestedManyWithoutProcessInput
    processDetail?: ProcessDetailUncheckedCreateNestedManyWithoutProcessInput
  }

  export type ProcessCreateOrConnectWithoutCompletionsInput = {
    where: ProcessWhereUniqueInput
    create: XOR<ProcessCreateWithoutCompletionsInput, ProcessUncheckedCreateWithoutCompletionsInput>
  }

  export type UserUpsertWithoutCourseCompletionsInput = {
    update: XOR<UserUpdateWithoutCourseCompletionsInput, UserUncheckedUpdateWithoutCourseCompletionsInput>
    create: XOR<UserCreateWithoutCourseCompletionsInput, UserUncheckedCreateWithoutCourseCompletionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCourseCompletionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCourseCompletionsInput, UserUncheckedUpdateWithoutCourseCompletionsInput>
  }

  export type UserUpdateWithoutCourseCompletionsInput = {
    userId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    companyId?: NullableIntFieldUpdateOperationsInput | number | null
    companyBranchId?: NullableIntFieldUpdateOperationsInput | number | null
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    department?: DepartmentUpdateOneWithoutUserNestedInput
    processes?: ProcessUpdateManyWithoutUserNestedInput
    exams?: ExamAttemptUpdateManyWithoutUserNestedInput
    enrollments?: EnrollmentUpdateManyWithoutUserNestedInput
    oplDocuments?: OplDocumentUpdateManyWithoutUserNestedInput
    files?: FileUpdateManyWithoutUserNestedInput
    createdCourses?: CourseUpdateManyWithoutCreatorNestedInput
    deletedCourses?: CourseUpdateManyWithoutDeleterNestedInput
    project?: ProjectUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCourseCompletionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    companyId?: NullableIntFieldUpdateOperationsInput | number | null
    companyBranchId?: NullableIntFieldUpdateOperationsInput | number | null
    departmentId?: NullableIntFieldUpdateOperationsInput | number | null
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    processes?: ProcessUncheckedUpdateManyWithoutUserNestedInput
    exams?: ExamAttemptUncheckedUpdateManyWithoutUserNestedInput
    enrollments?: EnrollmentUncheckedUpdateManyWithoutUserNestedInput
    oplDocuments?: OplDocumentUncheckedUpdateManyWithoutUserNestedInput
    files?: FileUncheckedUpdateManyWithoutUserNestedInput
    createdCourses?: CourseUncheckedUpdateManyWithoutCreatorNestedInput
    deletedCourses?: CourseUncheckedUpdateManyWithoutDeleterNestedInput
    project?: ProjectUncheckedUpdateManyWithoutUserNestedInput
  }

  export type CourseUpsertWithoutCompletionsInput = {
    update: XOR<CourseUpdateWithoutCompletionsInput, CourseUncheckedUpdateWithoutCompletionsInput>
    create: XOR<CourseCreateWithoutCompletionsInput, CourseUncheckedCreateWithoutCompletionsInput>
    where?: CourseWhereInput
  }

  export type CourseUpdateToOneWithWhereWithoutCompletionsInput = {
    where?: CourseWhereInput
    data: XOR<CourseUpdateWithoutCompletionsInput, CourseUncheckedUpdateWithoutCompletionsInput>
  }

  export type CourseUpdateWithoutCompletionsInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    pdfUrl?: NullableStringFieldUpdateOperationsInput | string | null
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    typeId?: IntFieldUpdateOperationsInput | number
    template?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    department?: DepartmentUpdateOneWithoutCourseNestedInput
    process?: ProcessUpdateOneWithoutCoursesNestedInput
    enrollments?: EnrollmentUpdateManyWithoutCourseNestedInput
    files?: FileUpdateManyWithoutCourseNestedInput
    exams?: ExamUpdateManyWithoutCourseNestedInput
    creator?: UserUpdateOneRequiredWithoutCreatedCoursesNestedInput
    deleter?: UserUpdateOneWithoutDeletedCoursesNestedInput
  }

  export type CourseUncheckedUpdateWithoutCompletionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    pdfUrl?: NullableStringFieldUpdateOperationsInput | string | null
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    typeId?: IntFieldUpdateOperationsInput | number
    template?: BoolFieldUpdateOperationsInput | boolean
    departmentId?: NullableIntFieldUpdateOperationsInput | number | null
    processId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: IntFieldUpdateOperationsInput | number
    deletedBy?: NullableIntFieldUpdateOperationsInput | number | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    enrollments?: EnrollmentUncheckedUpdateManyWithoutCourseNestedInput
    files?: FileUncheckedUpdateManyWithoutCourseNestedInput
    exams?: ExamUncheckedUpdateManyWithoutCourseNestedInput
  }

  export type ExamUpsertWithoutCompletionsInput = {
    update: XOR<ExamUpdateWithoutCompletionsInput, ExamUncheckedUpdateWithoutCompletionsInput>
    create: XOR<ExamCreateWithoutCompletionsInput, ExamUncheckedCreateWithoutCompletionsInput>
    where?: ExamWhereInput
  }

  export type ExamUpdateToOneWithWhereWithoutCompletionsInput = {
    where?: ExamWhereInput
    data: XOR<ExamUpdateWithoutCompletionsInput, ExamUncheckedUpdateWithoutCompletionsInput>
  }

  export type ExamUpdateWithoutCompletionsInput = {
    title?: StringFieldUpdateOperationsInput | string
    departmentId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    questions?: QuestionUpdateManyWithoutExamNestedInput
    attempts?: ExamAttemptUpdateManyWithoutExamNestedInput
    course?: CourseUpdateOneWithoutExamsNestedInput
  }

  export type ExamUncheckedUpdateWithoutCompletionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    departmentId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    courseId?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    questions?: QuestionUncheckedUpdateManyWithoutExamNestedInput
    attempts?: ExamAttemptUncheckedUpdateManyWithoutExamNestedInput
  }

  export type ProcessUpsertWithoutCompletionsInput = {
    update: XOR<ProcessUpdateWithoutCompletionsInput, ProcessUncheckedUpdateWithoutCompletionsInput>
    create: XOR<ProcessCreateWithoutCompletionsInput, ProcessUncheckedCreateWithoutCompletionsInput>
    where?: ProcessWhereInput
  }

  export type ProcessUpdateToOneWithWhereWithoutCompletionsInput = {
    where?: ProcessWhereInput
    data: XOR<ProcessUpdateWithoutCompletionsInput, ProcessUncheckedUpdateWithoutCompletionsInput>
  }

  export type ProcessUpdateWithoutCompletionsInput = {
    pc_bluePrintNo?: StringFieldUpdateOperationsInput | string
    pc_imageBluePrint?: StringFieldUpdateOperationsInput | string
    pc_totalProcess?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutProcessesNestedInput
    courses?: CourseUpdateManyWithoutProcessNestedInput
    processDetail?: ProcessDetailUpdateManyWithoutProcessNestedInput
  }

  export type ProcessUncheckedUpdateWithoutCompletionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    pc_bluePrintNo?: StringFieldUpdateOperationsInput | string
    pc_imageBluePrint?: StringFieldUpdateOperationsInput | string
    pc_totalProcess?: IntFieldUpdateOperationsInput | number
    pc_userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    courses?: CourseUncheckedUpdateManyWithoutProcessNestedInput
    processDetail?: ProcessDetailUncheckedUpdateManyWithoutProcessNestedInput
  }

  export type UserCreateWithoutEnrollmentsInput = {
    userId: string
    firstName: string
    lastName: string
    password: string
    companyId?: number | null
    companyBranchId?: number | null
    role: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    department?: DepartmentCreateNestedOneWithoutUserInput
    processes?: ProcessCreateNestedManyWithoutUserInput
    exams?: ExamAttemptCreateNestedManyWithoutUserInput
    oplDocuments?: OplDocumentCreateNestedManyWithoutUserInput
    files?: FileCreateNestedManyWithoutUserInput
    createdCourses?: CourseCreateNestedManyWithoutCreatorInput
    deletedCourses?: CourseCreateNestedManyWithoutDeleterInput
    courseCompletions?: UserCourseCompletionCreateNestedManyWithoutUserInput
    project?: ProjectCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutEnrollmentsInput = {
    id?: number
    userId: string
    firstName: string
    lastName: string
    password: string
    companyId?: number | null
    companyBranchId?: number | null
    departmentId?: number | null
    role: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    processes?: ProcessUncheckedCreateNestedManyWithoutUserInput
    exams?: ExamAttemptUncheckedCreateNestedManyWithoutUserInput
    oplDocuments?: OplDocumentUncheckedCreateNestedManyWithoutUserInput
    files?: FileUncheckedCreateNestedManyWithoutUserInput
    createdCourses?: CourseUncheckedCreateNestedManyWithoutCreatorInput
    deletedCourses?: CourseUncheckedCreateNestedManyWithoutDeleterInput
    courseCompletions?: UserCourseCompletionUncheckedCreateNestedManyWithoutUserInput
    project?: ProjectUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutEnrollmentsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutEnrollmentsInput, UserUncheckedCreateWithoutEnrollmentsInput>
  }

  export type CourseCreateWithoutEnrollmentsInput = {
    title: string
    description?: string | null
    pdfUrl?: string | null
    videoUrl?: string | null
    typeId: number
    template?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    department?: DepartmentCreateNestedOneWithoutCourseInput
    process?: ProcessCreateNestedOneWithoutCoursesInput
    files?: FileCreateNestedManyWithoutCourseInput
    exams?: ExamCreateNestedManyWithoutCourseInput
    completions?: UserCourseCompletionCreateNestedManyWithoutCourseInput
    creator: UserCreateNestedOneWithoutCreatedCoursesInput
    deleter?: UserCreateNestedOneWithoutDeletedCoursesInput
  }

  export type CourseUncheckedCreateWithoutEnrollmentsInput = {
    id?: number
    title: string
    description?: string | null
    pdfUrl?: string | null
    videoUrl?: string | null
    typeId: number
    template?: boolean
    departmentId?: number | null
    processId?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: number
    deletedBy?: number | null
    isDeleted?: boolean
    files?: FileUncheckedCreateNestedManyWithoutCourseInput
    exams?: ExamUncheckedCreateNestedManyWithoutCourseInput
    completions?: UserCourseCompletionUncheckedCreateNestedManyWithoutCourseInput
  }

  export type CourseCreateOrConnectWithoutEnrollmentsInput = {
    where: CourseWhereUniqueInput
    create: XOR<CourseCreateWithoutEnrollmentsInput, CourseUncheckedCreateWithoutEnrollmentsInput>
  }

  export type UserUpsertWithoutEnrollmentsInput = {
    update: XOR<UserUpdateWithoutEnrollmentsInput, UserUncheckedUpdateWithoutEnrollmentsInput>
    create: XOR<UserCreateWithoutEnrollmentsInput, UserUncheckedCreateWithoutEnrollmentsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutEnrollmentsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutEnrollmentsInput, UserUncheckedUpdateWithoutEnrollmentsInput>
  }

  export type UserUpdateWithoutEnrollmentsInput = {
    userId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    companyId?: NullableIntFieldUpdateOperationsInput | number | null
    companyBranchId?: NullableIntFieldUpdateOperationsInput | number | null
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    department?: DepartmentUpdateOneWithoutUserNestedInput
    processes?: ProcessUpdateManyWithoutUserNestedInput
    exams?: ExamAttemptUpdateManyWithoutUserNestedInput
    oplDocuments?: OplDocumentUpdateManyWithoutUserNestedInput
    files?: FileUpdateManyWithoutUserNestedInput
    createdCourses?: CourseUpdateManyWithoutCreatorNestedInput
    deletedCourses?: CourseUpdateManyWithoutDeleterNestedInput
    courseCompletions?: UserCourseCompletionUpdateManyWithoutUserNestedInput
    project?: ProjectUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutEnrollmentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    companyId?: NullableIntFieldUpdateOperationsInput | number | null
    companyBranchId?: NullableIntFieldUpdateOperationsInput | number | null
    departmentId?: NullableIntFieldUpdateOperationsInput | number | null
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    processes?: ProcessUncheckedUpdateManyWithoutUserNestedInput
    exams?: ExamAttemptUncheckedUpdateManyWithoutUserNestedInput
    oplDocuments?: OplDocumentUncheckedUpdateManyWithoutUserNestedInput
    files?: FileUncheckedUpdateManyWithoutUserNestedInput
    createdCourses?: CourseUncheckedUpdateManyWithoutCreatorNestedInput
    deletedCourses?: CourseUncheckedUpdateManyWithoutDeleterNestedInput
    courseCompletions?: UserCourseCompletionUncheckedUpdateManyWithoutUserNestedInput
    project?: ProjectUncheckedUpdateManyWithoutUserNestedInput
  }

  export type CourseUpsertWithoutEnrollmentsInput = {
    update: XOR<CourseUpdateWithoutEnrollmentsInput, CourseUncheckedUpdateWithoutEnrollmentsInput>
    create: XOR<CourseCreateWithoutEnrollmentsInput, CourseUncheckedCreateWithoutEnrollmentsInput>
    where?: CourseWhereInput
  }

  export type CourseUpdateToOneWithWhereWithoutEnrollmentsInput = {
    where?: CourseWhereInput
    data: XOR<CourseUpdateWithoutEnrollmentsInput, CourseUncheckedUpdateWithoutEnrollmentsInput>
  }

  export type CourseUpdateWithoutEnrollmentsInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    pdfUrl?: NullableStringFieldUpdateOperationsInput | string | null
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    typeId?: IntFieldUpdateOperationsInput | number
    template?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    department?: DepartmentUpdateOneWithoutCourseNestedInput
    process?: ProcessUpdateOneWithoutCoursesNestedInput
    files?: FileUpdateManyWithoutCourseNestedInput
    exams?: ExamUpdateManyWithoutCourseNestedInput
    completions?: UserCourseCompletionUpdateManyWithoutCourseNestedInput
    creator?: UserUpdateOneRequiredWithoutCreatedCoursesNestedInput
    deleter?: UserUpdateOneWithoutDeletedCoursesNestedInput
  }

  export type CourseUncheckedUpdateWithoutEnrollmentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    pdfUrl?: NullableStringFieldUpdateOperationsInput | string | null
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    typeId?: IntFieldUpdateOperationsInput | number
    template?: BoolFieldUpdateOperationsInput | boolean
    departmentId?: NullableIntFieldUpdateOperationsInput | number | null
    processId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: IntFieldUpdateOperationsInput | number
    deletedBy?: NullableIntFieldUpdateOperationsInput | number | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    files?: FileUncheckedUpdateManyWithoutCourseNestedInput
    exams?: ExamUncheckedUpdateManyWithoutCourseNestedInput
    completions?: UserCourseCompletionUncheckedUpdateManyWithoutCourseNestedInput
  }

  export type QuestionCreateWithoutExamInput = {
    text: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deleted?: boolean
    choices?: ChoiceCreateNestedManyWithoutQuestionInput
    userAnswers?: UserAnswerCreateNestedManyWithoutQuestionInput
  }

  export type QuestionUncheckedCreateWithoutExamInput = {
    id?: number
    text: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deleted?: boolean
    choices?: ChoiceUncheckedCreateNestedManyWithoutQuestionInput
    userAnswers?: UserAnswerUncheckedCreateNestedManyWithoutQuestionInput
  }

  export type QuestionCreateOrConnectWithoutExamInput = {
    where: QuestionWhereUniqueInput
    create: XOR<QuestionCreateWithoutExamInput, QuestionUncheckedCreateWithoutExamInput>
  }

  export type QuestionCreateManyExamInputEnvelope = {
    data: QuestionCreateManyExamInput | QuestionCreateManyExamInput[]
    skipDuplicates?: boolean
  }

  export type ExamAttemptCreateWithoutExamInput = {
    startedAt?: Date | string
    endedAt?: Date | string | null
    grade?: number | null
    isPassed?: boolean | null
    user: UserCreateNestedOneWithoutExamsInput
    answers?: UserAnswerCreateNestedManyWithoutExamAttemptInput
  }

  export type ExamAttemptUncheckedCreateWithoutExamInput = {
    id?: number
    userId: number
    startedAt?: Date | string
    endedAt?: Date | string | null
    grade?: number | null
    isPassed?: boolean | null
    answers?: UserAnswerUncheckedCreateNestedManyWithoutExamAttemptInput
  }

  export type ExamAttemptCreateOrConnectWithoutExamInput = {
    where: ExamAttemptWhereUniqueInput
    create: XOR<ExamAttemptCreateWithoutExamInput, ExamAttemptUncheckedCreateWithoutExamInput>
  }

  export type ExamAttemptCreateManyExamInputEnvelope = {
    data: ExamAttemptCreateManyExamInput | ExamAttemptCreateManyExamInput[]
    skipDuplicates?: boolean
  }

  export type UserCourseCompletionCreateWithoutExamInput = {
    completedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutCourseCompletionsInput
    course: CourseCreateNestedOneWithoutCompletionsInput
    process: ProcessCreateNestedOneWithoutCompletionsInput
  }

  export type UserCourseCompletionUncheckedCreateWithoutExamInput = {
    id?: number
    userId: number
    username: string
    courseId: number
    processId: number
    completedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserCourseCompletionCreateOrConnectWithoutExamInput = {
    where: UserCourseCompletionWhereUniqueInput
    create: XOR<UserCourseCompletionCreateWithoutExamInput, UserCourseCompletionUncheckedCreateWithoutExamInput>
  }

  export type UserCourseCompletionCreateManyExamInputEnvelope = {
    data: UserCourseCompletionCreateManyExamInput | UserCourseCompletionCreateManyExamInput[]
    skipDuplicates?: boolean
  }

  export type CourseCreateWithoutExamsInput = {
    title: string
    description?: string | null
    pdfUrl?: string | null
    videoUrl?: string | null
    typeId: number
    template?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    department?: DepartmentCreateNestedOneWithoutCourseInput
    process?: ProcessCreateNestedOneWithoutCoursesInput
    enrollments?: EnrollmentCreateNestedManyWithoutCourseInput
    files?: FileCreateNestedManyWithoutCourseInput
    completions?: UserCourseCompletionCreateNestedManyWithoutCourseInput
    creator: UserCreateNestedOneWithoutCreatedCoursesInput
    deleter?: UserCreateNestedOneWithoutDeletedCoursesInput
  }

  export type CourseUncheckedCreateWithoutExamsInput = {
    id?: number
    title: string
    description?: string | null
    pdfUrl?: string | null
    videoUrl?: string | null
    typeId: number
    template?: boolean
    departmentId?: number | null
    processId?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: number
    deletedBy?: number | null
    isDeleted?: boolean
    enrollments?: EnrollmentUncheckedCreateNestedManyWithoutCourseInput
    files?: FileUncheckedCreateNestedManyWithoutCourseInput
    completions?: UserCourseCompletionUncheckedCreateNestedManyWithoutCourseInput
  }

  export type CourseCreateOrConnectWithoutExamsInput = {
    where: CourseWhereUniqueInput
    create: XOR<CourseCreateWithoutExamsInput, CourseUncheckedCreateWithoutExamsInput>
  }

  export type QuestionUpsertWithWhereUniqueWithoutExamInput = {
    where: QuestionWhereUniqueInput
    update: XOR<QuestionUpdateWithoutExamInput, QuestionUncheckedUpdateWithoutExamInput>
    create: XOR<QuestionCreateWithoutExamInput, QuestionUncheckedCreateWithoutExamInput>
  }

  export type QuestionUpdateWithWhereUniqueWithoutExamInput = {
    where: QuestionWhereUniqueInput
    data: XOR<QuestionUpdateWithoutExamInput, QuestionUncheckedUpdateWithoutExamInput>
  }

  export type QuestionUpdateManyWithWhereWithoutExamInput = {
    where: QuestionScalarWhereInput
    data: XOR<QuestionUpdateManyMutationInput, QuestionUncheckedUpdateManyWithoutExamInput>
  }

  export type QuestionScalarWhereInput = {
    AND?: QuestionScalarWhereInput | QuestionScalarWhereInput[]
    OR?: QuestionScalarWhereInput[]
    NOT?: QuestionScalarWhereInput | QuestionScalarWhereInput[]
    id?: IntFilter<"Question"> | number
    examId?: IntFilter<"Question"> | number
    text?: StringFilter<"Question"> | string
    createdAt?: DateTimeFilter<"Question"> | Date | string
    updatedAt?: DateTimeFilter<"Question"> | Date | string
    deleted?: BoolFilter<"Question"> | boolean
  }

  export type ExamAttemptUpsertWithWhereUniqueWithoutExamInput = {
    where: ExamAttemptWhereUniqueInput
    update: XOR<ExamAttemptUpdateWithoutExamInput, ExamAttemptUncheckedUpdateWithoutExamInput>
    create: XOR<ExamAttemptCreateWithoutExamInput, ExamAttemptUncheckedCreateWithoutExamInput>
  }

  export type ExamAttemptUpdateWithWhereUniqueWithoutExamInput = {
    where: ExamAttemptWhereUniqueInput
    data: XOR<ExamAttemptUpdateWithoutExamInput, ExamAttemptUncheckedUpdateWithoutExamInput>
  }

  export type ExamAttemptUpdateManyWithWhereWithoutExamInput = {
    where: ExamAttemptScalarWhereInput
    data: XOR<ExamAttemptUpdateManyMutationInput, ExamAttemptUncheckedUpdateManyWithoutExamInput>
  }

  export type UserCourseCompletionUpsertWithWhereUniqueWithoutExamInput = {
    where: UserCourseCompletionWhereUniqueInput
    update: XOR<UserCourseCompletionUpdateWithoutExamInput, UserCourseCompletionUncheckedUpdateWithoutExamInput>
    create: XOR<UserCourseCompletionCreateWithoutExamInput, UserCourseCompletionUncheckedCreateWithoutExamInput>
  }

  export type UserCourseCompletionUpdateWithWhereUniqueWithoutExamInput = {
    where: UserCourseCompletionWhereUniqueInput
    data: XOR<UserCourseCompletionUpdateWithoutExamInput, UserCourseCompletionUncheckedUpdateWithoutExamInput>
  }

  export type UserCourseCompletionUpdateManyWithWhereWithoutExamInput = {
    where: UserCourseCompletionScalarWhereInput
    data: XOR<UserCourseCompletionUpdateManyMutationInput, UserCourseCompletionUncheckedUpdateManyWithoutExamInput>
  }

  export type CourseUpsertWithoutExamsInput = {
    update: XOR<CourseUpdateWithoutExamsInput, CourseUncheckedUpdateWithoutExamsInput>
    create: XOR<CourseCreateWithoutExamsInput, CourseUncheckedCreateWithoutExamsInput>
    where?: CourseWhereInput
  }

  export type CourseUpdateToOneWithWhereWithoutExamsInput = {
    where?: CourseWhereInput
    data: XOR<CourseUpdateWithoutExamsInput, CourseUncheckedUpdateWithoutExamsInput>
  }

  export type CourseUpdateWithoutExamsInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    pdfUrl?: NullableStringFieldUpdateOperationsInput | string | null
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    typeId?: IntFieldUpdateOperationsInput | number
    template?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    department?: DepartmentUpdateOneWithoutCourseNestedInput
    process?: ProcessUpdateOneWithoutCoursesNestedInput
    enrollments?: EnrollmentUpdateManyWithoutCourseNestedInput
    files?: FileUpdateManyWithoutCourseNestedInput
    completions?: UserCourseCompletionUpdateManyWithoutCourseNestedInput
    creator?: UserUpdateOneRequiredWithoutCreatedCoursesNestedInput
    deleter?: UserUpdateOneWithoutDeletedCoursesNestedInput
  }

  export type CourseUncheckedUpdateWithoutExamsInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    pdfUrl?: NullableStringFieldUpdateOperationsInput | string | null
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    typeId?: IntFieldUpdateOperationsInput | number
    template?: BoolFieldUpdateOperationsInput | boolean
    departmentId?: NullableIntFieldUpdateOperationsInput | number | null
    processId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: IntFieldUpdateOperationsInput | number
    deletedBy?: NullableIntFieldUpdateOperationsInput | number | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    enrollments?: EnrollmentUncheckedUpdateManyWithoutCourseNestedInput
    files?: FileUncheckedUpdateManyWithoutCourseNestedInput
    completions?: UserCourseCompletionUncheckedUpdateManyWithoutCourseNestedInput
  }

  export type ExamCreateWithoutQuestionsInput = {
    title: string
    departmentId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    description?: string | null
    deleted?: boolean
    attempts?: ExamAttemptCreateNestedManyWithoutExamInput
    completions?: UserCourseCompletionCreateNestedManyWithoutExamInput
    course?: CourseCreateNestedOneWithoutExamsInput
  }

  export type ExamUncheckedCreateWithoutQuestionsInput = {
    id?: number
    title: string
    departmentId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    courseId?: number | null
    description?: string | null
    deleted?: boolean
    attempts?: ExamAttemptUncheckedCreateNestedManyWithoutExamInput
    completions?: UserCourseCompletionUncheckedCreateNestedManyWithoutExamInput
  }

  export type ExamCreateOrConnectWithoutQuestionsInput = {
    where: ExamWhereUniqueInput
    create: XOR<ExamCreateWithoutQuestionsInput, ExamUncheckedCreateWithoutQuestionsInput>
  }

  export type ChoiceCreateWithoutQuestionInput = {
    text: string
    correct: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deleted?: boolean
    UserAnswer?: UserAnswerCreateNestedManyWithoutSelectedChoiceInput
  }

  export type ChoiceUncheckedCreateWithoutQuestionInput = {
    id?: number
    text: string
    correct: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deleted?: boolean
    UserAnswer?: UserAnswerUncheckedCreateNestedManyWithoutSelectedChoiceInput
  }

  export type ChoiceCreateOrConnectWithoutQuestionInput = {
    where: ChoiceWhereUniqueInput
    create: XOR<ChoiceCreateWithoutQuestionInput, ChoiceUncheckedCreateWithoutQuestionInput>
  }

  export type ChoiceCreateManyQuestionInputEnvelope = {
    data: ChoiceCreateManyQuestionInput | ChoiceCreateManyQuestionInput[]
    skipDuplicates?: boolean
  }

  export type UserAnswerCreateWithoutQuestionInput = {
    isCorrect: boolean
    createdAt?: Date | string
    examAttempt: ExamAttemptCreateNestedOneWithoutAnswersInput
    selectedChoice: ChoiceCreateNestedOneWithoutUserAnswerInput
  }

  export type UserAnswerUncheckedCreateWithoutQuestionInput = {
    id?: number
    examAttemptId: number
    selectedChoiceId: number
    isCorrect: boolean
    createdAt?: Date | string
  }

  export type UserAnswerCreateOrConnectWithoutQuestionInput = {
    where: UserAnswerWhereUniqueInput
    create: XOR<UserAnswerCreateWithoutQuestionInput, UserAnswerUncheckedCreateWithoutQuestionInput>
  }

  export type UserAnswerCreateManyQuestionInputEnvelope = {
    data: UserAnswerCreateManyQuestionInput | UserAnswerCreateManyQuestionInput[]
    skipDuplicates?: boolean
  }

  export type ExamUpsertWithoutQuestionsInput = {
    update: XOR<ExamUpdateWithoutQuestionsInput, ExamUncheckedUpdateWithoutQuestionsInput>
    create: XOR<ExamCreateWithoutQuestionsInput, ExamUncheckedCreateWithoutQuestionsInput>
    where?: ExamWhereInput
  }

  export type ExamUpdateToOneWithWhereWithoutQuestionsInput = {
    where?: ExamWhereInput
    data: XOR<ExamUpdateWithoutQuestionsInput, ExamUncheckedUpdateWithoutQuestionsInput>
  }

  export type ExamUpdateWithoutQuestionsInput = {
    title?: StringFieldUpdateOperationsInput | string
    departmentId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    attempts?: ExamAttemptUpdateManyWithoutExamNestedInput
    completions?: UserCourseCompletionUpdateManyWithoutExamNestedInput
    course?: CourseUpdateOneWithoutExamsNestedInput
  }

  export type ExamUncheckedUpdateWithoutQuestionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    departmentId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    courseId?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    attempts?: ExamAttemptUncheckedUpdateManyWithoutExamNestedInput
    completions?: UserCourseCompletionUncheckedUpdateManyWithoutExamNestedInput
  }

  export type ChoiceUpsertWithWhereUniqueWithoutQuestionInput = {
    where: ChoiceWhereUniqueInput
    update: XOR<ChoiceUpdateWithoutQuestionInput, ChoiceUncheckedUpdateWithoutQuestionInput>
    create: XOR<ChoiceCreateWithoutQuestionInput, ChoiceUncheckedCreateWithoutQuestionInput>
  }

  export type ChoiceUpdateWithWhereUniqueWithoutQuestionInput = {
    where: ChoiceWhereUniqueInput
    data: XOR<ChoiceUpdateWithoutQuestionInput, ChoiceUncheckedUpdateWithoutQuestionInput>
  }

  export type ChoiceUpdateManyWithWhereWithoutQuestionInput = {
    where: ChoiceScalarWhereInput
    data: XOR<ChoiceUpdateManyMutationInput, ChoiceUncheckedUpdateManyWithoutQuestionInput>
  }

  export type ChoiceScalarWhereInput = {
    AND?: ChoiceScalarWhereInput | ChoiceScalarWhereInput[]
    OR?: ChoiceScalarWhereInput[]
    NOT?: ChoiceScalarWhereInput | ChoiceScalarWhereInput[]
    id?: IntFilter<"Choice"> | number
    questionId?: IntFilter<"Choice"> | number
    text?: StringFilter<"Choice"> | string
    correct?: BoolFilter<"Choice"> | boolean
    createdAt?: DateTimeFilter<"Choice"> | Date | string
    updatedAt?: DateTimeFilter<"Choice"> | Date | string
    deleted?: BoolFilter<"Choice"> | boolean
  }

  export type UserAnswerUpsertWithWhereUniqueWithoutQuestionInput = {
    where: UserAnswerWhereUniqueInput
    update: XOR<UserAnswerUpdateWithoutQuestionInput, UserAnswerUncheckedUpdateWithoutQuestionInput>
    create: XOR<UserAnswerCreateWithoutQuestionInput, UserAnswerUncheckedCreateWithoutQuestionInput>
  }

  export type UserAnswerUpdateWithWhereUniqueWithoutQuestionInput = {
    where: UserAnswerWhereUniqueInput
    data: XOR<UserAnswerUpdateWithoutQuestionInput, UserAnswerUncheckedUpdateWithoutQuestionInput>
  }

  export type UserAnswerUpdateManyWithWhereWithoutQuestionInput = {
    where: UserAnswerScalarWhereInput
    data: XOR<UserAnswerUpdateManyMutationInput, UserAnswerUncheckedUpdateManyWithoutQuestionInput>
  }

  export type UserAnswerScalarWhereInput = {
    AND?: UserAnswerScalarWhereInput | UserAnswerScalarWhereInput[]
    OR?: UserAnswerScalarWhereInput[]
    NOT?: UserAnswerScalarWhereInput | UserAnswerScalarWhereInput[]
    id?: IntFilter<"UserAnswer"> | number
    examAttemptId?: IntFilter<"UserAnswer"> | number
    questionId?: IntFilter<"UserAnswer"> | number
    selectedChoiceId?: IntFilter<"UserAnswer"> | number
    isCorrect?: BoolFilter<"UserAnswer"> | boolean
    createdAt?: DateTimeFilter<"UserAnswer"> | Date | string
  }

  export type QuestionCreateWithoutChoicesInput = {
    text: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deleted?: boolean
    exam: ExamCreateNestedOneWithoutQuestionsInput
    userAnswers?: UserAnswerCreateNestedManyWithoutQuestionInput
  }

  export type QuestionUncheckedCreateWithoutChoicesInput = {
    id?: number
    examId: number
    text: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deleted?: boolean
    userAnswers?: UserAnswerUncheckedCreateNestedManyWithoutQuestionInput
  }

  export type QuestionCreateOrConnectWithoutChoicesInput = {
    where: QuestionWhereUniqueInput
    create: XOR<QuestionCreateWithoutChoicesInput, QuestionUncheckedCreateWithoutChoicesInput>
  }

  export type UserAnswerCreateWithoutSelectedChoiceInput = {
    isCorrect: boolean
    createdAt?: Date | string
    examAttempt: ExamAttemptCreateNestedOneWithoutAnswersInput
    question: QuestionCreateNestedOneWithoutUserAnswersInput
  }

  export type UserAnswerUncheckedCreateWithoutSelectedChoiceInput = {
    id?: number
    examAttemptId: number
    questionId: number
    isCorrect: boolean
    createdAt?: Date | string
  }

  export type UserAnswerCreateOrConnectWithoutSelectedChoiceInput = {
    where: UserAnswerWhereUniqueInput
    create: XOR<UserAnswerCreateWithoutSelectedChoiceInput, UserAnswerUncheckedCreateWithoutSelectedChoiceInput>
  }

  export type UserAnswerCreateManySelectedChoiceInputEnvelope = {
    data: UserAnswerCreateManySelectedChoiceInput | UserAnswerCreateManySelectedChoiceInput[]
    skipDuplicates?: boolean
  }

  export type QuestionUpsertWithoutChoicesInput = {
    update: XOR<QuestionUpdateWithoutChoicesInput, QuestionUncheckedUpdateWithoutChoicesInput>
    create: XOR<QuestionCreateWithoutChoicesInput, QuestionUncheckedCreateWithoutChoicesInput>
    where?: QuestionWhereInput
  }

  export type QuestionUpdateToOneWithWhereWithoutChoicesInput = {
    where?: QuestionWhereInput
    data: XOR<QuestionUpdateWithoutChoicesInput, QuestionUncheckedUpdateWithoutChoicesInput>
  }

  export type QuestionUpdateWithoutChoicesInput = {
    text?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
    exam?: ExamUpdateOneRequiredWithoutQuestionsNestedInput
    userAnswers?: UserAnswerUpdateManyWithoutQuestionNestedInput
  }

  export type QuestionUncheckedUpdateWithoutChoicesInput = {
    id?: IntFieldUpdateOperationsInput | number
    examId?: IntFieldUpdateOperationsInput | number
    text?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
    userAnswers?: UserAnswerUncheckedUpdateManyWithoutQuestionNestedInput
  }

  export type UserAnswerUpsertWithWhereUniqueWithoutSelectedChoiceInput = {
    where: UserAnswerWhereUniqueInput
    update: XOR<UserAnswerUpdateWithoutSelectedChoiceInput, UserAnswerUncheckedUpdateWithoutSelectedChoiceInput>
    create: XOR<UserAnswerCreateWithoutSelectedChoiceInput, UserAnswerUncheckedCreateWithoutSelectedChoiceInput>
  }

  export type UserAnswerUpdateWithWhereUniqueWithoutSelectedChoiceInput = {
    where: UserAnswerWhereUniqueInput
    data: XOR<UserAnswerUpdateWithoutSelectedChoiceInput, UserAnswerUncheckedUpdateWithoutSelectedChoiceInput>
  }

  export type UserAnswerUpdateManyWithWhereWithoutSelectedChoiceInput = {
    where: UserAnswerScalarWhereInput
    data: XOR<UserAnswerUpdateManyMutationInput, UserAnswerUncheckedUpdateManyWithoutSelectedChoiceInput>
  }

  export type UserCreateWithoutExamsInput = {
    userId: string
    firstName: string
    lastName: string
    password: string
    companyId?: number | null
    companyBranchId?: number | null
    role: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    department?: DepartmentCreateNestedOneWithoutUserInput
    processes?: ProcessCreateNestedManyWithoutUserInput
    enrollments?: EnrollmentCreateNestedManyWithoutUserInput
    oplDocuments?: OplDocumentCreateNestedManyWithoutUserInput
    files?: FileCreateNestedManyWithoutUserInput
    createdCourses?: CourseCreateNestedManyWithoutCreatorInput
    deletedCourses?: CourseCreateNestedManyWithoutDeleterInput
    courseCompletions?: UserCourseCompletionCreateNestedManyWithoutUserInput
    project?: ProjectCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutExamsInput = {
    id?: number
    userId: string
    firstName: string
    lastName: string
    password: string
    companyId?: number | null
    companyBranchId?: number | null
    departmentId?: number | null
    role: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    processes?: ProcessUncheckedCreateNestedManyWithoutUserInput
    enrollments?: EnrollmentUncheckedCreateNestedManyWithoutUserInput
    oplDocuments?: OplDocumentUncheckedCreateNestedManyWithoutUserInput
    files?: FileUncheckedCreateNestedManyWithoutUserInput
    createdCourses?: CourseUncheckedCreateNestedManyWithoutCreatorInput
    deletedCourses?: CourseUncheckedCreateNestedManyWithoutDeleterInput
    courseCompletions?: UserCourseCompletionUncheckedCreateNestedManyWithoutUserInput
    project?: ProjectUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutExamsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutExamsInput, UserUncheckedCreateWithoutExamsInput>
  }

  export type ExamCreateWithoutAttemptsInput = {
    title: string
    departmentId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    description?: string | null
    deleted?: boolean
    questions?: QuestionCreateNestedManyWithoutExamInput
    completions?: UserCourseCompletionCreateNestedManyWithoutExamInput
    course?: CourseCreateNestedOneWithoutExamsInput
  }

  export type ExamUncheckedCreateWithoutAttemptsInput = {
    id?: number
    title: string
    departmentId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    courseId?: number | null
    description?: string | null
    deleted?: boolean
    questions?: QuestionUncheckedCreateNestedManyWithoutExamInput
    completions?: UserCourseCompletionUncheckedCreateNestedManyWithoutExamInput
  }

  export type ExamCreateOrConnectWithoutAttemptsInput = {
    where: ExamWhereUniqueInput
    create: XOR<ExamCreateWithoutAttemptsInput, ExamUncheckedCreateWithoutAttemptsInput>
  }

  export type UserAnswerCreateWithoutExamAttemptInput = {
    isCorrect: boolean
    createdAt?: Date | string
    question: QuestionCreateNestedOneWithoutUserAnswersInput
    selectedChoice: ChoiceCreateNestedOneWithoutUserAnswerInput
  }

  export type UserAnswerUncheckedCreateWithoutExamAttemptInput = {
    id?: number
    questionId: number
    selectedChoiceId: number
    isCorrect: boolean
    createdAt?: Date | string
  }

  export type UserAnswerCreateOrConnectWithoutExamAttemptInput = {
    where: UserAnswerWhereUniqueInput
    create: XOR<UserAnswerCreateWithoutExamAttemptInput, UserAnswerUncheckedCreateWithoutExamAttemptInput>
  }

  export type UserAnswerCreateManyExamAttemptInputEnvelope = {
    data: UserAnswerCreateManyExamAttemptInput | UserAnswerCreateManyExamAttemptInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutExamsInput = {
    update: XOR<UserUpdateWithoutExamsInput, UserUncheckedUpdateWithoutExamsInput>
    create: XOR<UserCreateWithoutExamsInput, UserUncheckedCreateWithoutExamsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutExamsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutExamsInput, UserUncheckedUpdateWithoutExamsInput>
  }

  export type UserUpdateWithoutExamsInput = {
    userId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    companyId?: NullableIntFieldUpdateOperationsInput | number | null
    companyBranchId?: NullableIntFieldUpdateOperationsInput | number | null
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    department?: DepartmentUpdateOneWithoutUserNestedInput
    processes?: ProcessUpdateManyWithoutUserNestedInput
    enrollments?: EnrollmentUpdateManyWithoutUserNestedInput
    oplDocuments?: OplDocumentUpdateManyWithoutUserNestedInput
    files?: FileUpdateManyWithoutUserNestedInput
    createdCourses?: CourseUpdateManyWithoutCreatorNestedInput
    deletedCourses?: CourseUpdateManyWithoutDeleterNestedInput
    courseCompletions?: UserCourseCompletionUpdateManyWithoutUserNestedInput
    project?: ProjectUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutExamsInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    companyId?: NullableIntFieldUpdateOperationsInput | number | null
    companyBranchId?: NullableIntFieldUpdateOperationsInput | number | null
    departmentId?: NullableIntFieldUpdateOperationsInput | number | null
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    processes?: ProcessUncheckedUpdateManyWithoutUserNestedInput
    enrollments?: EnrollmentUncheckedUpdateManyWithoutUserNestedInput
    oplDocuments?: OplDocumentUncheckedUpdateManyWithoutUserNestedInput
    files?: FileUncheckedUpdateManyWithoutUserNestedInput
    createdCourses?: CourseUncheckedUpdateManyWithoutCreatorNestedInput
    deletedCourses?: CourseUncheckedUpdateManyWithoutDeleterNestedInput
    courseCompletions?: UserCourseCompletionUncheckedUpdateManyWithoutUserNestedInput
    project?: ProjectUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ExamUpsertWithoutAttemptsInput = {
    update: XOR<ExamUpdateWithoutAttemptsInput, ExamUncheckedUpdateWithoutAttemptsInput>
    create: XOR<ExamCreateWithoutAttemptsInput, ExamUncheckedCreateWithoutAttemptsInput>
    where?: ExamWhereInput
  }

  export type ExamUpdateToOneWithWhereWithoutAttemptsInput = {
    where?: ExamWhereInput
    data: XOR<ExamUpdateWithoutAttemptsInput, ExamUncheckedUpdateWithoutAttemptsInput>
  }

  export type ExamUpdateWithoutAttemptsInput = {
    title?: StringFieldUpdateOperationsInput | string
    departmentId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    questions?: QuestionUpdateManyWithoutExamNestedInput
    completions?: UserCourseCompletionUpdateManyWithoutExamNestedInput
    course?: CourseUpdateOneWithoutExamsNestedInput
  }

  export type ExamUncheckedUpdateWithoutAttemptsInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    departmentId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    courseId?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    questions?: QuestionUncheckedUpdateManyWithoutExamNestedInput
    completions?: UserCourseCompletionUncheckedUpdateManyWithoutExamNestedInput
  }

  export type UserAnswerUpsertWithWhereUniqueWithoutExamAttemptInput = {
    where: UserAnswerWhereUniqueInput
    update: XOR<UserAnswerUpdateWithoutExamAttemptInput, UserAnswerUncheckedUpdateWithoutExamAttemptInput>
    create: XOR<UserAnswerCreateWithoutExamAttemptInput, UserAnswerUncheckedCreateWithoutExamAttemptInput>
  }

  export type UserAnswerUpdateWithWhereUniqueWithoutExamAttemptInput = {
    where: UserAnswerWhereUniqueInput
    data: XOR<UserAnswerUpdateWithoutExamAttemptInput, UserAnswerUncheckedUpdateWithoutExamAttemptInput>
  }

  export type UserAnswerUpdateManyWithWhereWithoutExamAttemptInput = {
    where: UserAnswerScalarWhereInput
    data: XOR<UserAnswerUpdateManyMutationInput, UserAnswerUncheckedUpdateManyWithoutExamAttemptInput>
  }

  export type ExamAttemptCreateWithoutAnswersInput = {
    startedAt?: Date | string
    endedAt?: Date | string | null
    grade?: number | null
    isPassed?: boolean | null
    user: UserCreateNestedOneWithoutExamsInput
    exam: ExamCreateNestedOneWithoutAttemptsInput
  }

  export type ExamAttemptUncheckedCreateWithoutAnswersInput = {
    id?: number
    userId: number
    examId: number
    startedAt?: Date | string
    endedAt?: Date | string | null
    grade?: number | null
    isPassed?: boolean | null
  }

  export type ExamAttemptCreateOrConnectWithoutAnswersInput = {
    where: ExamAttemptWhereUniqueInput
    create: XOR<ExamAttemptCreateWithoutAnswersInput, ExamAttemptUncheckedCreateWithoutAnswersInput>
  }

  export type QuestionCreateWithoutUserAnswersInput = {
    text: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deleted?: boolean
    exam: ExamCreateNestedOneWithoutQuestionsInput
    choices?: ChoiceCreateNestedManyWithoutQuestionInput
  }

  export type QuestionUncheckedCreateWithoutUserAnswersInput = {
    id?: number
    examId: number
    text: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deleted?: boolean
    choices?: ChoiceUncheckedCreateNestedManyWithoutQuestionInput
  }

  export type QuestionCreateOrConnectWithoutUserAnswersInput = {
    where: QuestionWhereUniqueInput
    create: XOR<QuestionCreateWithoutUserAnswersInput, QuestionUncheckedCreateWithoutUserAnswersInput>
  }

  export type ChoiceCreateWithoutUserAnswerInput = {
    text: string
    correct: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deleted?: boolean
    question: QuestionCreateNestedOneWithoutChoicesInput
  }

  export type ChoiceUncheckedCreateWithoutUserAnswerInput = {
    id?: number
    questionId: number
    text: string
    correct: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deleted?: boolean
  }

  export type ChoiceCreateOrConnectWithoutUserAnswerInput = {
    where: ChoiceWhereUniqueInput
    create: XOR<ChoiceCreateWithoutUserAnswerInput, ChoiceUncheckedCreateWithoutUserAnswerInput>
  }

  export type ExamAttemptUpsertWithoutAnswersInput = {
    update: XOR<ExamAttemptUpdateWithoutAnswersInput, ExamAttemptUncheckedUpdateWithoutAnswersInput>
    create: XOR<ExamAttemptCreateWithoutAnswersInput, ExamAttemptUncheckedCreateWithoutAnswersInput>
    where?: ExamAttemptWhereInput
  }

  export type ExamAttemptUpdateToOneWithWhereWithoutAnswersInput = {
    where?: ExamAttemptWhereInput
    data: XOR<ExamAttemptUpdateWithoutAnswersInput, ExamAttemptUncheckedUpdateWithoutAnswersInput>
  }

  export type ExamAttemptUpdateWithoutAnswersInput = {
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    grade?: NullableFloatFieldUpdateOperationsInput | number | null
    isPassed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    user?: UserUpdateOneRequiredWithoutExamsNestedInput
    exam?: ExamUpdateOneRequiredWithoutAttemptsNestedInput
  }

  export type ExamAttemptUncheckedUpdateWithoutAnswersInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    examId?: IntFieldUpdateOperationsInput | number
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    grade?: NullableFloatFieldUpdateOperationsInput | number | null
    isPassed?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type QuestionUpsertWithoutUserAnswersInput = {
    update: XOR<QuestionUpdateWithoutUserAnswersInput, QuestionUncheckedUpdateWithoutUserAnswersInput>
    create: XOR<QuestionCreateWithoutUserAnswersInput, QuestionUncheckedCreateWithoutUserAnswersInput>
    where?: QuestionWhereInput
  }

  export type QuestionUpdateToOneWithWhereWithoutUserAnswersInput = {
    where?: QuestionWhereInput
    data: XOR<QuestionUpdateWithoutUserAnswersInput, QuestionUncheckedUpdateWithoutUserAnswersInput>
  }

  export type QuestionUpdateWithoutUserAnswersInput = {
    text?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
    exam?: ExamUpdateOneRequiredWithoutQuestionsNestedInput
    choices?: ChoiceUpdateManyWithoutQuestionNestedInput
  }

  export type QuestionUncheckedUpdateWithoutUserAnswersInput = {
    id?: IntFieldUpdateOperationsInput | number
    examId?: IntFieldUpdateOperationsInput | number
    text?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
    choices?: ChoiceUncheckedUpdateManyWithoutQuestionNestedInput
  }

  export type ChoiceUpsertWithoutUserAnswerInput = {
    update: XOR<ChoiceUpdateWithoutUserAnswerInput, ChoiceUncheckedUpdateWithoutUserAnswerInput>
    create: XOR<ChoiceCreateWithoutUserAnswerInput, ChoiceUncheckedCreateWithoutUserAnswerInput>
    where?: ChoiceWhereInput
  }

  export type ChoiceUpdateToOneWithWhereWithoutUserAnswerInput = {
    where?: ChoiceWhereInput
    data: XOR<ChoiceUpdateWithoutUserAnswerInput, ChoiceUncheckedUpdateWithoutUserAnswerInput>
  }

  export type ChoiceUpdateWithoutUserAnswerInput = {
    text?: StringFieldUpdateOperationsInput | string
    correct?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
    question?: QuestionUpdateOneRequiredWithoutChoicesNestedInput
  }

  export type ChoiceUncheckedUpdateWithoutUserAnswerInput = {
    id?: IntFieldUpdateOperationsInput | number
    questionId?: IntFieldUpdateOperationsInput | number
    text?: StringFieldUpdateOperationsInput | string
    correct?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type UserCreateWithoutOplDocumentsInput = {
    userId: string
    firstName: string
    lastName: string
    password: string
    companyId?: number | null
    companyBranchId?: number | null
    role: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    department?: DepartmentCreateNestedOneWithoutUserInput
    processes?: ProcessCreateNestedManyWithoutUserInput
    exams?: ExamAttemptCreateNestedManyWithoutUserInput
    enrollments?: EnrollmentCreateNestedManyWithoutUserInput
    files?: FileCreateNestedManyWithoutUserInput
    createdCourses?: CourseCreateNestedManyWithoutCreatorInput
    deletedCourses?: CourseCreateNestedManyWithoutDeleterInput
    courseCompletions?: UserCourseCompletionCreateNestedManyWithoutUserInput
    project?: ProjectCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutOplDocumentsInput = {
    id?: number
    userId: string
    firstName: string
    lastName: string
    password: string
    companyId?: number | null
    companyBranchId?: number | null
    departmentId?: number | null
    role: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    processes?: ProcessUncheckedCreateNestedManyWithoutUserInput
    exams?: ExamAttemptUncheckedCreateNestedManyWithoutUserInput
    enrollments?: EnrollmentUncheckedCreateNestedManyWithoutUserInput
    files?: FileUncheckedCreateNestedManyWithoutUserInput
    createdCourses?: CourseUncheckedCreateNestedManyWithoutCreatorInput
    deletedCourses?: CourseUncheckedCreateNestedManyWithoutDeleterInput
    courseCompletions?: UserCourseCompletionUncheckedCreateNestedManyWithoutUserInput
    project?: ProjectUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutOplDocumentsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutOplDocumentsInput, UserUncheckedCreateWithoutOplDocumentsInput>
  }

  export type UserUpsertWithoutOplDocumentsInput = {
    update: XOR<UserUpdateWithoutOplDocumentsInput, UserUncheckedUpdateWithoutOplDocumentsInput>
    create: XOR<UserCreateWithoutOplDocumentsInput, UserUncheckedCreateWithoutOplDocumentsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutOplDocumentsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutOplDocumentsInput, UserUncheckedUpdateWithoutOplDocumentsInput>
  }

  export type UserUpdateWithoutOplDocumentsInput = {
    userId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    companyId?: NullableIntFieldUpdateOperationsInput | number | null
    companyBranchId?: NullableIntFieldUpdateOperationsInput | number | null
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    department?: DepartmentUpdateOneWithoutUserNestedInput
    processes?: ProcessUpdateManyWithoutUserNestedInput
    exams?: ExamAttemptUpdateManyWithoutUserNestedInput
    enrollments?: EnrollmentUpdateManyWithoutUserNestedInput
    files?: FileUpdateManyWithoutUserNestedInput
    createdCourses?: CourseUpdateManyWithoutCreatorNestedInput
    deletedCourses?: CourseUpdateManyWithoutDeleterNestedInput
    courseCompletions?: UserCourseCompletionUpdateManyWithoutUserNestedInput
    project?: ProjectUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutOplDocumentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    companyId?: NullableIntFieldUpdateOperationsInput | number | null
    companyBranchId?: NullableIntFieldUpdateOperationsInput | number | null
    departmentId?: NullableIntFieldUpdateOperationsInput | number | null
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    processes?: ProcessUncheckedUpdateManyWithoutUserNestedInput
    exams?: ExamAttemptUncheckedUpdateManyWithoutUserNestedInput
    enrollments?: EnrollmentUncheckedUpdateManyWithoutUserNestedInput
    files?: FileUncheckedUpdateManyWithoutUserNestedInput
    createdCourses?: CourseUncheckedUpdateManyWithoutCreatorNestedInput
    deletedCourses?: CourseUncheckedUpdateManyWithoutDeleterNestedInput
    courseCompletions?: UserCourseCompletionUncheckedUpdateManyWithoutUserNestedInput
    project?: ProjectUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutFilesInput = {
    userId: string
    firstName: string
    lastName: string
    password: string
    companyId?: number | null
    companyBranchId?: number | null
    role: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    department?: DepartmentCreateNestedOneWithoutUserInput
    processes?: ProcessCreateNestedManyWithoutUserInput
    exams?: ExamAttemptCreateNestedManyWithoutUserInput
    enrollments?: EnrollmentCreateNestedManyWithoutUserInput
    oplDocuments?: OplDocumentCreateNestedManyWithoutUserInput
    createdCourses?: CourseCreateNestedManyWithoutCreatorInput
    deletedCourses?: CourseCreateNestedManyWithoutDeleterInput
    courseCompletions?: UserCourseCompletionCreateNestedManyWithoutUserInput
    project?: ProjectCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutFilesInput = {
    id?: number
    userId: string
    firstName: string
    lastName: string
    password: string
    companyId?: number | null
    companyBranchId?: number | null
    departmentId?: number | null
    role: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    processes?: ProcessUncheckedCreateNestedManyWithoutUserInput
    exams?: ExamAttemptUncheckedCreateNestedManyWithoutUserInput
    enrollments?: EnrollmentUncheckedCreateNestedManyWithoutUserInput
    oplDocuments?: OplDocumentUncheckedCreateNestedManyWithoutUserInput
    createdCourses?: CourseUncheckedCreateNestedManyWithoutCreatorInput
    deletedCourses?: CourseUncheckedCreateNestedManyWithoutDeleterInput
    courseCompletions?: UserCourseCompletionUncheckedCreateNestedManyWithoutUserInput
    project?: ProjectUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutFilesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutFilesInput, UserUncheckedCreateWithoutFilesInput>
  }

  export type CourseCreateWithoutFilesInput = {
    title: string
    description?: string | null
    pdfUrl?: string | null
    videoUrl?: string | null
    typeId: number
    template?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    department?: DepartmentCreateNestedOneWithoutCourseInput
    process?: ProcessCreateNestedOneWithoutCoursesInput
    enrollments?: EnrollmentCreateNestedManyWithoutCourseInput
    exams?: ExamCreateNestedManyWithoutCourseInput
    completions?: UserCourseCompletionCreateNestedManyWithoutCourseInput
    creator: UserCreateNestedOneWithoutCreatedCoursesInput
    deleter?: UserCreateNestedOneWithoutDeletedCoursesInput
  }

  export type CourseUncheckedCreateWithoutFilesInput = {
    id?: number
    title: string
    description?: string | null
    pdfUrl?: string | null
    videoUrl?: string | null
    typeId: number
    template?: boolean
    departmentId?: number | null
    processId?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: number
    deletedBy?: number | null
    isDeleted?: boolean
    enrollments?: EnrollmentUncheckedCreateNestedManyWithoutCourseInput
    exams?: ExamUncheckedCreateNestedManyWithoutCourseInput
    completions?: UserCourseCompletionUncheckedCreateNestedManyWithoutCourseInput
  }

  export type CourseCreateOrConnectWithoutFilesInput = {
    where: CourseWhereUniqueInput
    create: XOR<CourseCreateWithoutFilesInput, CourseUncheckedCreateWithoutFilesInput>
  }

  export type UserUpsertWithoutFilesInput = {
    update: XOR<UserUpdateWithoutFilesInput, UserUncheckedUpdateWithoutFilesInput>
    create: XOR<UserCreateWithoutFilesInput, UserUncheckedCreateWithoutFilesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutFilesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutFilesInput, UserUncheckedUpdateWithoutFilesInput>
  }

  export type UserUpdateWithoutFilesInput = {
    userId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    companyId?: NullableIntFieldUpdateOperationsInput | number | null
    companyBranchId?: NullableIntFieldUpdateOperationsInput | number | null
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    department?: DepartmentUpdateOneWithoutUserNestedInput
    processes?: ProcessUpdateManyWithoutUserNestedInput
    exams?: ExamAttemptUpdateManyWithoutUserNestedInput
    enrollments?: EnrollmentUpdateManyWithoutUserNestedInput
    oplDocuments?: OplDocumentUpdateManyWithoutUserNestedInput
    createdCourses?: CourseUpdateManyWithoutCreatorNestedInput
    deletedCourses?: CourseUpdateManyWithoutDeleterNestedInput
    courseCompletions?: UserCourseCompletionUpdateManyWithoutUserNestedInput
    project?: ProjectUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutFilesInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    companyId?: NullableIntFieldUpdateOperationsInput | number | null
    companyBranchId?: NullableIntFieldUpdateOperationsInput | number | null
    departmentId?: NullableIntFieldUpdateOperationsInput | number | null
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    processes?: ProcessUncheckedUpdateManyWithoutUserNestedInput
    exams?: ExamAttemptUncheckedUpdateManyWithoutUserNestedInput
    enrollments?: EnrollmentUncheckedUpdateManyWithoutUserNestedInput
    oplDocuments?: OplDocumentUncheckedUpdateManyWithoutUserNestedInput
    createdCourses?: CourseUncheckedUpdateManyWithoutCreatorNestedInput
    deletedCourses?: CourseUncheckedUpdateManyWithoutDeleterNestedInput
    courseCompletions?: UserCourseCompletionUncheckedUpdateManyWithoutUserNestedInput
    project?: ProjectUncheckedUpdateManyWithoutUserNestedInput
  }

  export type CourseUpsertWithoutFilesInput = {
    update: XOR<CourseUpdateWithoutFilesInput, CourseUncheckedUpdateWithoutFilesInput>
    create: XOR<CourseCreateWithoutFilesInput, CourseUncheckedCreateWithoutFilesInput>
    where?: CourseWhereInput
  }

  export type CourseUpdateToOneWithWhereWithoutFilesInput = {
    where?: CourseWhereInput
    data: XOR<CourseUpdateWithoutFilesInput, CourseUncheckedUpdateWithoutFilesInput>
  }

  export type CourseUpdateWithoutFilesInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    pdfUrl?: NullableStringFieldUpdateOperationsInput | string | null
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    typeId?: IntFieldUpdateOperationsInput | number
    template?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    department?: DepartmentUpdateOneWithoutCourseNestedInput
    process?: ProcessUpdateOneWithoutCoursesNestedInput
    enrollments?: EnrollmentUpdateManyWithoutCourseNestedInput
    exams?: ExamUpdateManyWithoutCourseNestedInput
    completions?: UserCourseCompletionUpdateManyWithoutCourseNestedInput
    creator?: UserUpdateOneRequiredWithoutCreatedCoursesNestedInput
    deleter?: UserUpdateOneWithoutDeletedCoursesNestedInput
  }

  export type CourseUncheckedUpdateWithoutFilesInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    pdfUrl?: NullableStringFieldUpdateOperationsInput | string | null
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    typeId?: IntFieldUpdateOperationsInput | number
    template?: BoolFieldUpdateOperationsInput | boolean
    departmentId?: NullableIntFieldUpdateOperationsInput | number | null
    processId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: IntFieldUpdateOperationsInput | number
    deletedBy?: NullableIntFieldUpdateOperationsInput | number | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    enrollments?: EnrollmentUncheckedUpdateManyWithoutCourseNestedInput
    exams?: ExamUncheckedUpdateManyWithoutCourseNestedInput
    completions?: UserCourseCompletionUncheckedUpdateManyWithoutCourseNestedInput
  }

  export type UserCreateWithoutProcessesInput = {
    userId: string
    firstName: string
    lastName: string
    password: string
    companyId?: number | null
    companyBranchId?: number | null
    role: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    department?: DepartmentCreateNestedOneWithoutUserInput
    exams?: ExamAttemptCreateNestedManyWithoutUserInput
    enrollments?: EnrollmentCreateNestedManyWithoutUserInput
    oplDocuments?: OplDocumentCreateNestedManyWithoutUserInput
    files?: FileCreateNestedManyWithoutUserInput
    createdCourses?: CourseCreateNestedManyWithoutCreatorInput
    deletedCourses?: CourseCreateNestedManyWithoutDeleterInput
    courseCompletions?: UserCourseCompletionCreateNestedManyWithoutUserInput
    project?: ProjectCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutProcessesInput = {
    id?: number
    userId: string
    firstName: string
    lastName: string
    password: string
    companyId?: number | null
    companyBranchId?: number | null
    departmentId?: number | null
    role: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    exams?: ExamAttemptUncheckedCreateNestedManyWithoutUserInput
    enrollments?: EnrollmentUncheckedCreateNestedManyWithoutUserInput
    oplDocuments?: OplDocumentUncheckedCreateNestedManyWithoutUserInput
    files?: FileUncheckedCreateNestedManyWithoutUserInput
    createdCourses?: CourseUncheckedCreateNestedManyWithoutCreatorInput
    deletedCourses?: CourseUncheckedCreateNestedManyWithoutDeleterInput
    courseCompletions?: UserCourseCompletionUncheckedCreateNestedManyWithoutUserInput
    project?: ProjectUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutProcessesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutProcessesInput, UserUncheckedCreateWithoutProcessesInput>
  }

  export type CourseCreateWithoutProcessInput = {
    title: string
    description?: string | null
    pdfUrl?: string | null
    videoUrl?: string | null
    typeId: number
    template?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    department?: DepartmentCreateNestedOneWithoutCourseInput
    enrollments?: EnrollmentCreateNestedManyWithoutCourseInput
    files?: FileCreateNestedManyWithoutCourseInput
    exams?: ExamCreateNestedManyWithoutCourseInput
    completions?: UserCourseCompletionCreateNestedManyWithoutCourseInput
    creator: UserCreateNestedOneWithoutCreatedCoursesInput
    deleter?: UserCreateNestedOneWithoutDeletedCoursesInput
  }

  export type CourseUncheckedCreateWithoutProcessInput = {
    id?: number
    title: string
    description?: string | null
    pdfUrl?: string | null
    videoUrl?: string | null
    typeId: number
    template?: boolean
    departmentId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: number
    deletedBy?: number | null
    isDeleted?: boolean
    enrollments?: EnrollmentUncheckedCreateNestedManyWithoutCourseInput
    files?: FileUncheckedCreateNestedManyWithoutCourseInput
    exams?: ExamUncheckedCreateNestedManyWithoutCourseInput
    completions?: UserCourseCompletionUncheckedCreateNestedManyWithoutCourseInput
  }

  export type CourseCreateOrConnectWithoutProcessInput = {
    where: CourseWhereUniqueInput
    create: XOR<CourseCreateWithoutProcessInput, CourseUncheckedCreateWithoutProcessInput>
  }

  export type CourseCreateManyProcessInputEnvelope = {
    data: CourseCreateManyProcessInput | CourseCreateManyProcessInput[]
    skipDuplicates?: boolean
  }

  export type UserCourseCompletionCreateWithoutProcessInput = {
    completedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutCourseCompletionsInput
    course: CourseCreateNestedOneWithoutCompletionsInput
    exam: ExamCreateNestedOneWithoutCompletionsInput
  }

  export type UserCourseCompletionUncheckedCreateWithoutProcessInput = {
    id?: number
    userId: number
    username: string
    courseId: number
    examId: number
    completedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserCourseCompletionCreateOrConnectWithoutProcessInput = {
    where: UserCourseCompletionWhereUniqueInput
    create: XOR<UserCourseCompletionCreateWithoutProcessInput, UserCourseCompletionUncheckedCreateWithoutProcessInput>
  }

  export type UserCourseCompletionCreateManyProcessInputEnvelope = {
    data: UserCourseCompletionCreateManyProcessInput | UserCourseCompletionCreateManyProcessInput[]
    skipDuplicates?: boolean
  }

  export type ProcessDetailCreateWithoutProcessInput = {
    pc_processTitle: string
    pc_amountDay: number
    pc_reasonType: string
    processBranch?: ProcessBranchCreateNestedManyWithoutProcessDetailInput
    processMat?: ProcessMatCreateNestedManyWithoutProcessDetailInput
    processBom?: ProcessBomCreateNestedManyWithoutProcessDetailInput
  }

  export type ProcessDetailUncheckedCreateWithoutProcessInput = {
    id?: number
    pc_processTitle: string
    pc_amountDay: number
    pc_reasonType: string
    processBranch?: ProcessBranchUncheckedCreateNestedManyWithoutProcessDetailInput
    processMat?: ProcessMatUncheckedCreateNestedManyWithoutProcessDetailInput
    processBom?: ProcessBomUncheckedCreateNestedManyWithoutProcessDetailInput
  }

  export type ProcessDetailCreateOrConnectWithoutProcessInput = {
    where: ProcessDetailWhereUniqueInput
    create: XOR<ProcessDetailCreateWithoutProcessInput, ProcessDetailUncheckedCreateWithoutProcessInput>
  }

  export type ProcessDetailCreateManyProcessInputEnvelope = {
    data: ProcessDetailCreateManyProcessInput | ProcessDetailCreateManyProcessInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutProcessesInput = {
    update: XOR<UserUpdateWithoutProcessesInput, UserUncheckedUpdateWithoutProcessesInput>
    create: XOR<UserCreateWithoutProcessesInput, UserUncheckedCreateWithoutProcessesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutProcessesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutProcessesInput, UserUncheckedUpdateWithoutProcessesInput>
  }

  export type UserUpdateWithoutProcessesInput = {
    userId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    companyId?: NullableIntFieldUpdateOperationsInput | number | null
    companyBranchId?: NullableIntFieldUpdateOperationsInput | number | null
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    department?: DepartmentUpdateOneWithoutUserNestedInput
    exams?: ExamAttemptUpdateManyWithoutUserNestedInput
    enrollments?: EnrollmentUpdateManyWithoutUserNestedInput
    oplDocuments?: OplDocumentUpdateManyWithoutUserNestedInput
    files?: FileUpdateManyWithoutUserNestedInput
    createdCourses?: CourseUpdateManyWithoutCreatorNestedInput
    deletedCourses?: CourseUpdateManyWithoutDeleterNestedInput
    courseCompletions?: UserCourseCompletionUpdateManyWithoutUserNestedInput
    project?: ProjectUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutProcessesInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    companyId?: NullableIntFieldUpdateOperationsInput | number | null
    companyBranchId?: NullableIntFieldUpdateOperationsInput | number | null
    departmentId?: NullableIntFieldUpdateOperationsInput | number | null
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    exams?: ExamAttemptUncheckedUpdateManyWithoutUserNestedInput
    enrollments?: EnrollmentUncheckedUpdateManyWithoutUserNestedInput
    oplDocuments?: OplDocumentUncheckedUpdateManyWithoutUserNestedInput
    files?: FileUncheckedUpdateManyWithoutUserNestedInput
    createdCourses?: CourseUncheckedUpdateManyWithoutCreatorNestedInput
    deletedCourses?: CourseUncheckedUpdateManyWithoutDeleterNestedInput
    courseCompletions?: UserCourseCompletionUncheckedUpdateManyWithoutUserNestedInput
    project?: ProjectUncheckedUpdateManyWithoutUserNestedInput
  }

  export type CourseUpsertWithWhereUniqueWithoutProcessInput = {
    where: CourseWhereUniqueInput
    update: XOR<CourseUpdateWithoutProcessInput, CourseUncheckedUpdateWithoutProcessInput>
    create: XOR<CourseCreateWithoutProcessInput, CourseUncheckedCreateWithoutProcessInput>
  }

  export type CourseUpdateWithWhereUniqueWithoutProcessInput = {
    where: CourseWhereUniqueInput
    data: XOR<CourseUpdateWithoutProcessInput, CourseUncheckedUpdateWithoutProcessInput>
  }

  export type CourseUpdateManyWithWhereWithoutProcessInput = {
    where: CourseScalarWhereInput
    data: XOR<CourseUpdateManyMutationInput, CourseUncheckedUpdateManyWithoutProcessInput>
  }

  export type UserCourseCompletionUpsertWithWhereUniqueWithoutProcessInput = {
    where: UserCourseCompletionWhereUniqueInput
    update: XOR<UserCourseCompletionUpdateWithoutProcessInput, UserCourseCompletionUncheckedUpdateWithoutProcessInput>
    create: XOR<UserCourseCompletionCreateWithoutProcessInput, UserCourseCompletionUncheckedCreateWithoutProcessInput>
  }

  export type UserCourseCompletionUpdateWithWhereUniqueWithoutProcessInput = {
    where: UserCourseCompletionWhereUniqueInput
    data: XOR<UserCourseCompletionUpdateWithoutProcessInput, UserCourseCompletionUncheckedUpdateWithoutProcessInput>
  }

  export type UserCourseCompletionUpdateManyWithWhereWithoutProcessInput = {
    where: UserCourseCompletionScalarWhereInput
    data: XOR<UserCourseCompletionUpdateManyMutationInput, UserCourseCompletionUncheckedUpdateManyWithoutProcessInput>
  }

  export type ProcessDetailUpsertWithWhereUniqueWithoutProcessInput = {
    where: ProcessDetailWhereUniqueInput
    update: XOR<ProcessDetailUpdateWithoutProcessInput, ProcessDetailUncheckedUpdateWithoutProcessInput>
    create: XOR<ProcessDetailCreateWithoutProcessInput, ProcessDetailUncheckedCreateWithoutProcessInput>
  }

  export type ProcessDetailUpdateWithWhereUniqueWithoutProcessInput = {
    where: ProcessDetailWhereUniqueInput
    data: XOR<ProcessDetailUpdateWithoutProcessInput, ProcessDetailUncheckedUpdateWithoutProcessInput>
  }

  export type ProcessDetailUpdateManyWithWhereWithoutProcessInput = {
    where: ProcessDetailScalarWhereInput
    data: XOR<ProcessDetailUpdateManyMutationInput, ProcessDetailUncheckedUpdateManyWithoutProcessInput>
  }

  export type ProcessDetailScalarWhereInput = {
    AND?: ProcessDetailScalarWhereInput | ProcessDetailScalarWhereInput[]
    OR?: ProcessDetailScalarWhereInput[]
    NOT?: ProcessDetailScalarWhereInput | ProcessDetailScalarWhereInput[]
    id?: IntFilter<"ProcessDetail"> | number
    pc_bluePrintNo?: StringFilter<"ProcessDetail"> | string
    pc_processTitle?: StringFilter<"ProcessDetail"> | string
    pc_amountDay?: IntFilter<"ProcessDetail"> | number
    pc_reasonType?: StringFilter<"ProcessDetail"> | string
  }

  export type ProcessCreateWithoutProcessDetailInput = {
    pc_bluePrintNo: string
    pc_imageBluePrint: string
    pc_totalProcess: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    user: UserCreateNestedOneWithoutProcessesInput
    courses?: CourseCreateNestedManyWithoutProcessInput
    completions?: UserCourseCompletionCreateNestedManyWithoutProcessInput
  }

  export type ProcessUncheckedCreateWithoutProcessDetailInput = {
    id?: number
    pc_bluePrintNo: string
    pc_imageBluePrint: string
    pc_totalProcess: number
    pc_userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    courses?: CourseUncheckedCreateNestedManyWithoutProcessInput
    completions?: UserCourseCompletionUncheckedCreateNestedManyWithoutProcessInput
  }

  export type ProcessCreateOrConnectWithoutProcessDetailInput = {
    where: ProcessWhereUniqueInput
    create: XOR<ProcessCreateWithoutProcessDetailInput, ProcessUncheckedCreateWithoutProcessDetailInput>
  }

  export type ProcessBranchCreateWithoutProcessDetailInput = {
    pc_remark: string
  }

  export type ProcessBranchUncheckedCreateWithoutProcessDetailInput = {
    id?: number
    pc_remark: string
  }

  export type ProcessBranchCreateOrConnectWithoutProcessDetailInput = {
    where: ProcessBranchWhereUniqueInput
    create: XOR<ProcessBranchCreateWithoutProcessDetailInput, ProcessBranchUncheckedCreateWithoutProcessDetailInput>
  }

  export type ProcessBranchCreateManyProcessDetailInputEnvelope = {
    data: ProcessBranchCreateManyProcessDetailInput | ProcessBranchCreateManyProcessDetailInput[]
    skipDuplicates?: boolean
  }

  export type ProcessMatCreateWithoutProcessDetailInput = {
    pc_matamount: number
    stock: StockCreateNestedOneWithoutProcessMatInput
  }

  export type ProcessMatUncheckedCreateWithoutProcessDetailInput = {
    id?: number
    pc_matId: string
    pc_matamount: number
  }

  export type ProcessMatCreateOrConnectWithoutProcessDetailInput = {
    where: ProcessMatWhereUniqueInput
    create: XOR<ProcessMatCreateWithoutProcessDetailInput, ProcessMatUncheckedCreateWithoutProcessDetailInput>
  }

  export type ProcessMatCreateManyProcessDetailInputEnvelope = {
    data: ProcessMatCreateManyProcessDetailInput | ProcessMatCreateManyProcessDetailInput[]
    skipDuplicates?: boolean
  }

  export type ProcessBomCreateWithoutProcessDetailInput = {
    pc_bomamount: number
    stock: StockCreateNestedOneWithoutProcessBomInput
  }

  export type ProcessBomUncheckedCreateWithoutProcessDetailInput = {
    id?: number
    pc_bomId: string
    pc_bomamount: number
  }

  export type ProcessBomCreateOrConnectWithoutProcessDetailInput = {
    where: ProcessBomWhereUniqueInput
    create: XOR<ProcessBomCreateWithoutProcessDetailInput, ProcessBomUncheckedCreateWithoutProcessDetailInput>
  }

  export type ProcessBomCreateManyProcessDetailInputEnvelope = {
    data: ProcessBomCreateManyProcessDetailInput | ProcessBomCreateManyProcessDetailInput[]
    skipDuplicates?: boolean
  }

  export type ProcessUpsertWithoutProcessDetailInput = {
    update: XOR<ProcessUpdateWithoutProcessDetailInput, ProcessUncheckedUpdateWithoutProcessDetailInput>
    create: XOR<ProcessCreateWithoutProcessDetailInput, ProcessUncheckedCreateWithoutProcessDetailInput>
    where?: ProcessWhereInput
  }

  export type ProcessUpdateToOneWithWhereWithoutProcessDetailInput = {
    where?: ProcessWhereInput
    data: XOR<ProcessUpdateWithoutProcessDetailInput, ProcessUncheckedUpdateWithoutProcessDetailInput>
  }

  export type ProcessUpdateWithoutProcessDetailInput = {
    pc_bluePrintNo?: StringFieldUpdateOperationsInput | string
    pc_imageBluePrint?: StringFieldUpdateOperationsInput | string
    pc_totalProcess?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutProcessesNestedInput
    courses?: CourseUpdateManyWithoutProcessNestedInput
    completions?: UserCourseCompletionUpdateManyWithoutProcessNestedInput
  }

  export type ProcessUncheckedUpdateWithoutProcessDetailInput = {
    id?: IntFieldUpdateOperationsInput | number
    pc_bluePrintNo?: StringFieldUpdateOperationsInput | string
    pc_imageBluePrint?: StringFieldUpdateOperationsInput | string
    pc_totalProcess?: IntFieldUpdateOperationsInput | number
    pc_userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    courses?: CourseUncheckedUpdateManyWithoutProcessNestedInput
    completions?: UserCourseCompletionUncheckedUpdateManyWithoutProcessNestedInput
  }

  export type ProcessBranchUpsertWithWhereUniqueWithoutProcessDetailInput = {
    where: ProcessBranchWhereUniqueInput
    update: XOR<ProcessBranchUpdateWithoutProcessDetailInput, ProcessBranchUncheckedUpdateWithoutProcessDetailInput>
    create: XOR<ProcessBranchCreateWithoutProcessDetailInput, ProcessBranchUncheckedCreateWithoutProcessDetailInput>
  }

  export type ProcessBranchUpdateWithWhereUniqueWithoutProcessDetailInput = {
    where: ProcessBranchWhereUniqueInput
    data: XOR<ProcessBranchUpdateWithoutProcessDetailInput, ProcessBranchUncheckedUpdateWithoutProcessDetailInput>
  }

  export type ProcessBranchUpdateManyWithWhereWithoutProcessDetailInput = {
    where: ProcessBranchScalarWhereInput
    data: XOR<ProcessBranchUpdateManyMutationInput, ProcessBranchUncheckedUpdateManyWithoutProcessDetailInput>
  }

  export type ProcessBranchScalarWhereInput = {
    AND?: ProcessBranchScalarWhereInput | ProcessBranchScalarWhereInput[]
    OR?: ProcessBranchScalarWhereInput[]
    NOT?: ProcessBranchScalarWhereInput | ProcessBranchScalarWhereInput[]
    id?: IntFilter<"ProcessBranch"> | number
    pc_processDetailId?: IntFilter<"ProcessBranch"> | number
    pc_remark?: StringFilter<"ProcessBranch"> | string
  }

  export type ProcessMatUpsertWithWhereUniqueWithoutProcessDetailInput = {
    where: ProcessMatWhereUniqueInput
    update: XOR<ProcessMatUpdateWithoutProcessDetailInput, ProcessMatUncheckedUpdateWithoutProcessDetailInput>
    create: XOR<ProcessMatCreateWithoutProcessDetailInput, ProcessMatUncheckedCreateWithoutProcessDetailInput>
  }

  export type ProcessMatUpdateWithWhereUniqueWithoutProcessDetailInput = {
    where: ProcessMatWhereUniqueInput
    data: XOR<ProcessMatUpdateWithoutProcessDetailInput, ProcessMatUncheckedUpdateWithoutProcessDetailInput>
  }

  export type ProcessMatUpdateManyWithWhereWithoutProcessDetailInput = {
    where: ProcessMatScalarWhereInput
    data: XOR<ProcessMatUpdateManyMutationInput, ProcessMatUncheckedUpdateManyWithoutProcessDetailInput>
  }

  export type ProcessMatScalarWhereInput = {
    AND?: ProcessMatScalarWhereInput | ProcessMatScalarWhereInput[]
    OR?: ProcessMatScalarWhereInput[]
    NOT?: ProcessMatScalarWhereInput | ProcessMatScalarWhereInput[]
    id?: IntFilter<"ProcessMat"> | number
    pc_processDetailId?: IntFilter<"ProcessMat"> | number
    pc_matId?: StringFilter<"ProcessMat"> | string
    pc_matamount?: IntFilter<"ProcessMat"> | number
  }

  export type ProcessBomUpsertWithWhereUniqueWithoutProcessDetailInput = {
    where: ProcessBomWhereUniqueInput
    update: XOR<ProcessBomUpdateWithoutProcessDetailInput, ProcessBomUncheckedUpdateWithoutProcessDetailInput>
    create: XOR<ProcessBomCreateWithoutProcessDetailInput, ProcessBomUncheckedCreateWithoutProcessDetailInput>
  }

  export type ProcessBomUpdateWithWhereUniqueWithoutProcessDetailInput = {
    where: ProcessBomWhereUniqueInput
    data: XOR<ProcessBomUpdateWithoutProcessDetailInput, ProcessBomUncheckedUpdateWithoutProcessDetailInput>
  }

  export type ProcessBomUpdateManyWithWhereWithoutProcessDetailInput = {
    where: ProcessBomScalarWhereInput
    data: XOR<ProcessBomUpdateManyMutationInput, ProcessBomUncheckedUpdateManyWithoutProcessDetailInput>
  }

  export type ProcessBomScalarWhereInput = {
    AND?: ProcessBomScalarWhereInput | ProcessBomScalarWhereInput[]
    OR?: ProcessBomScalarWhereInput[]
    NOT?: ProcessBomScalarWhereInput | ProcessBomScalarWhereInput[]
    id?: IntFilter<"ProcessBom"> | number
    pc_processDetailId?: IntFilter<"ProcessBom"> | number
    pc_bomId?: StringFilter<"ProcessBom"> | string
    pc_bomamount?: IntFilter<"ProcessBom"> | number
  }

  export type ProcessDetailCreateWithoutProcessBranchInput = {
    pc_processTitle: string
    pc_amountDay: number
    pc_reasonType: string
    process: ProcessCreateNestedOneWithoutProcessDetailInput
    processMat?: ProcessMatCreateNestedManyWithoutProcessDetailInput
    processBom?: ProcessBomCreateNestedManyWithoutProcessDetailInput
  }

  export type ProcessDetailUncheckedCreateWithoutProcessBranchInput = {
    id?: number
    pc_bluePrintNo: string
    pc_processTitle: string
    pc_amountDay: number
    pc_reasonType: string
    processMat?: ProcessMatUncheckedCreateNestedManyWithoutProcessDetailInput
    processBom?: ProcessBomUncheckedCreateNestedManyWithoutProcessDetailInput
  }

  export type ProcessDetailCreateOrConnectWithoutProcessBranchInput = {
    where: ProcessDetailWhereUniqueInput
    create: XOR<ProcessDetailCreateWithoutProcessBranchInput, ProcessDetailUncheckedCreateWithoutProcessBranchInput>
  }

  export type ProcessDetailUpsertWithoutProcessBranchInput = {
    update: XOR<ProcessDetailUpdateWithoutProcessBranchInput, ProcessDetailUncheckedUpdateWithoutProcessBranchInput>
    create: XOR<ProcessDetailCreateWithoutProcessBranchInput, ProcessDetailUncheckedCreateWithoutProcessBranchInput>
    where?: ProcessDetailWhereInput
  }

  export type ProcessDetailUpdateToOneWithWhereWithoutProcessBranchInput = {
    where?: ProcessDetailWhereInput
    data: XOR<ProcessDetailUpdateWithoutProcessBranchInput, ProcessDetailUncheckedUpdateWithoutProcessBranchInput>
  }

  export type ProcessDetailUpdateWithoutProcessBranchInput = {
    pc_processTitle?: StringFieldUpdateOperationsInput | string
    pc_amountDay?: IntFieldUpdateOperationsInput | number
    pc_reasonType?: StringFieldUpdateOperationsInput | string
    process?: ProcessUpdateOneRequiredWithoutProcessDetailNestedInput
    processMat?: ProcessMatUpdateManyWithoutProcessDetailNestedInput
    processBom?: ProcessBomUpdateManyWithoutProcessDetailNestedInput
  }

  export type ProcessDetailUncheckedUpdateWithoutProcessBranchInput = {
    id?: IntFieldUpdateOperationsInput | number
    pc_bluePrintNo?: StringFieldUpdateOperationsInput | string
    pc_processTitle?: StringFieldUpdateOperationsInput | string
    pc_amountDay?: IntFieldUpdateOperationsInput | number
    pc_reasonType?: StringFieldUpdateOperationsInput | string
    processMat?: ProcessMatUncheckedUpdateManyWithoutProcessDetailNestedInput
    processBom?: ProcessBomUncheckedUpdateManyWithoutProcessDetailNestedInput
  }

  export type StockCreateWithoutProcessMatInput = {
    stockId: string
    stockName: string
    stockQuantity: number
    stockType: string
    stockTypeId: number
    stockImage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    processBom?: ProcessBomCreateNestedManyWithoutStockInput
    projectMat?: ProjectMatCreateNestedManyWithoutStockInput
    projectBom?: ProjectBomCreateNestedManyWithoutStockInput
  }

  export type StockUncheckedCreateWithoutProcessMatInput = {
    id?: number
    stockId: string
    stockName: string
    stockQuantity: number
    stockType: string
    stockTypeId: number
    stockImage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    processBom?: ProcessBomUncheckedCreateNestedManyWithoutStockInput
    projectMat?: ProjectMatUncheckedCreateNestedManyWithoutStockInput
    projectBom?: ProjectBomUncheckedCreateNestedManyWithoutStockInput
  }

  export type StockCreateOrConnectWithoutProcessMatInput = {
    where: StockWhereUniqueInput
    create: XOR<StockCreateWithoutProcessMatInput, StockUncheckedCreateWithoutProcessMatInput>
  }

  export type ProcessDetailCreateWithoutProcessMatInput = {
    pc_processTitle: string
    pc_amountDay: number
    pc_reasonType: string
    process: ProcessCreateNestedOneWithoutProcessDetailInput
    processBranch?: ProcessBranchCreateNestedManyWithoutProcessDetailInput
    processBom?: ProcessBomCreateNestedManyWithoutProcessDetailInput
  }

  export type ProcessDetailUncheckedCreateWithoutProcessMatInput = {
    id?: number
    pc_bluePrintNo: string
    pc_processTitle: string
    pc_amountDay: number
    pc_reasonType: string
    processBranch?: ProcessBranchUncheckedCreateNestedManyWithoutProcessDetailInput
    processBom?: ProcessBomUncheckedCreateNestedManyWithoutProcessDetailInput
  }

  export type ProcessDetailCreateOrConnectWithoutProcessMatInput = {
    where: ProcessDetailWhereUniqueInput
    create: XOR<ProcessDetailCreateWithoutProcessMatInput, ProcessDetailUncheckedCreateWithoutProcessMatInput>
  }

  export type StockUpsertWithoutProcessMatInput = {
    update: XOR<StockUpdateWithoutProcessMatInput, StockUncheckedUpdateWithoutProcessMatInput>
    create: XOR<StockCreateWithoutProcessMatInput, StockUncheckedCreateWithoutProcessMatInput>
    where?: StockWhereInput
  }

  export type StockUpdateToOneWithWhereWithoutProcessMatInput = {
    where?: StockWhereInput
    data: XOR<StockUpdateWithoutProcessMatInput, StockUncheckedUpdateWithoutProcessMatInput>
  }

  export type StockUpdateWithoutProcessMatInput = {
    stockId?: StringFieldUpdateOperationsInput | string
    stockName?: StringFieldUpdateOperationsInput | string
    stockQuantity?: IntFieldUpdateOperationsInput | number
    stockType?: StringFieldUpdateOperationsInput | string
    stockTypeId?: IntFieldUpdateOperationsInput | number
    stockImage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    processBom?: ProcessBomUpdateManyWithoutStockNestedInput
    projectMat?: ProjectMatUpdateManyWithoutStockNestedInput
    projectBom?: ProjectBomUpdateManyWithoutStockNestedInput
  }

  export type StockUncheckedUpdateWithoutProcessMatInput = {
    id?: IntFieldUpdateOperationsInput | number
    stockId?: StringFieldUpdateOperationsInput | string
    stockName?: StringFieldUpdateOperationsInput | string
    stockQuantity?: IntFieldUpdateOperationsInput | number
    stockType?: StringFieldUpdateOperationsInput | string
    stockTypeId?: IntFieldUpdateOperationsInput | number
    stockImage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    processBom?: ProcessBomUncheckedUpdateManyWithoutStockNestedInput
    projectMat?: ProjectMatUncheckedUpdateManyWithoutStockNestedInput
    projectBom?: ProjectBomUncheckedUpdateManyWithoutStockNestedInput
  }

  export type ProcessDetailUpsertWithoutProcessMatInput = {
    update: XOR<ProcessDetailUpdateWithoutProcessMatInput, ProcessDetailUncheckedUpdateWithoutProcessMatInput>
    create: XOR<ProcessDetailCreateWithoutProcessMatInput, ProcessDetailUncheckedCreateWithoutProcessMatInput>
    where?: ProcessDetailWhereInput
  }

  export type ProcessDetailUpdateToOneWithWhereWithoutProcessMatInput = {
    where?: ProcessDetailWhereInput
    data: XOR<ProcessDetailUpdateWithoutProcessMatInput, ProcessDetailUncheckedUpdateWithoutProcessMatInput>
  }

  export type ProcessDetailUpdateWithoutProcessMatInput = {
    pc_processTitle?: StringFieldUpdateOperationsInput | string
    pc_amountDay?: IntFieldUpdateOperationsInput | number
    pc_reasonType?: StringFieldUpdateOperationsInput | string
    process?: ProcessUpdateOneRequiredWithoutProcessDetailNestedInput
    processBranch?: ProcessBranchUpdateManyWithoutProcessDetailNestedInput
    processBom?: ProcessBomUpdateManyWithoutProcessDetailNestedInput
  }

  export type ProcessDetailUncheckedUpdateWithoutProcessMatInput = {
    id?: IntFieldUpdateOperationsInput | number
    pc_bluePrintNo?: StringFieldUpdateOperationsInput | string
    pc_processTitle?: StringFieldUpdateOperationsInput | string
    pc_amountDay?: IntFieldUpdateOperationsInput | number
    pc_reasonType?: StringFieldUpdateOperationsInput | string
    processBranch?: ProcessBranchUncheckedUpdateManyWithoutProcessDetailNestedInput
    processBom?: ProcessBomUncheckedUpdateManyWithoutProcessDetailNestedInput
  }

  export type StockCreateWithoutProcessBomInput = {
    stockId: string
    stockName: string
    stockQuantity: number
    stockType: string
    stockTypeId: number
    stockImage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    processMat?: ProcessMatCreateNestedManyWithoutStockInput
    projectMat?: ProjectMatCreateNestedManyWithoutStockInput
    projectBom?: ProjectBomCreateNestedManyWithoutStockInput
  }

  export type StockUncheckedCreateWithoutProcessBomInput = {
    id?: number
    stockId: string
    stockName: string
    stockQuantity: number
    stockType: string
    stockTypeId: number
    stockImage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    processMat?: ProcessMatUncheckedCreateNestedManyWithoutStockInput
    projectMat?: ProjectMatUncheckedCreateNestedManyWithoutStockInput
    projectBom?: ProjectBomUncheckedCreateNestedManyWithoutStockInput
  }

  export type StockCreateOrConnectWithoutProcessBomInput = {
    where: StockWhereUniqueInput
    create: XOR<StockCreateWithoutProcessBomInput, StockUncheckedCreateWithoutProcessBomInput>
  }

  export type ProcessDetailCreateWithoutProcessBomInput = {
    pc_processTitle: string
    pc_amountDay: number
    pc_reasonType: string
    process: ProcessCreateNestedOneWithoutProcessDetailInput
    processBranch?: ProcessBranchCreateNestedManyWithoutProcessDetailInput
    processMat?: ProcessMatCreateNestedManyWithoutProcessDetailInput
  }

  export type ProcessDetailUncheckedCreateWithoutProcessBomInput = {
    id?: number
    pc_bluePrintNo: string
    pc_processTitle: string
    pc_amountDay: number
    pc_reasonType: string
    processBranch?: ProcessBranchUncheckedCreateNestedManyWithoutProcessDetailInput
    processMat?: ProcessMatUncheckedCreateNestedManyWithoutProcessDetailInput
  }

  export type ProcessDetailCreateOrConnectWithoutProcessBomInput = {
    where: ProcessDetailWhereUniqueInput
    create: XOR<ProcessDetailCreateWithoutProcessBomInput, ProcessDetailUncheckedCreateWithoutProcessBomInput>
  }

  export type StockUpsertWithoutProcessBomInput = {
    update: XOR<StockUpdateWithoutProcessBomInput, StockUncheckedUpdateWithoutProcessBomInput>
    create: XOR<StockCreateWithoutProcessBomInput, StockUncheckedCreateWithoutProcessBomInput>
    where?: StockWhereInput
  }

  export type StockUpdateToOneWithWhereWithoutProcessBomInput = {
    where?: StockWhereInput
    data: XOR<StockUpdateWithoutProcessBomInput, StockUncheckedUpdateWithoutProcessBomInput>
  }

  export type StockUpdateWithoutProcessBomInput = {
    stockId?: StringFieldUpdateOperationsInput | string
    stockName?: StringFieldUpdateOperationsInput | string
    stockQuantity?: IntFieldUpdateOperationsInput | number
    stockType?: StringFieldUpdateOperationsInput | string
    stockTypeId?: IntFieldUpdateOperationsInput | number
    stockImage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    processMat?: ProcessMatUpdateManyWithoutStockNestedInput
    projectMat?: ProjectMatUpdateManyWithoutStockNestedInput
    projectBom?: ProjectBomUpdateManyWithoutStockNestedInput
  }

  export type StockUncheckedUpdateWithoutProcessBomInput = {
    id?: IntFieldUpdateOperationsInput | number
    stockId?: StringFieldUpdateOperationsInput | string
    stockName?: StringFieldUpdateOperationsInput | string
    stockQuantity?: IntFieldUpdateOperationsInput | number
    stockType?: StringFieldUpdateOperationsInput | string
    stockTypeId?: IntFieldUpdateOperationsInput | number
    stockImage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    processMat?: ProcessMatUncheckedUpdateManyWithoutStockNestedInput
    projectMat?: ProjectMatUncheckedUpdateManyWithoutStockNestedInput
    projectBom?: ProjectBomUncheckedUpdateManyWithoutStockNestedInput
  }

  export type ProcessDetailUpsertWithoutProcessBomInput = {
    update: XOR<ProcessDetailUpdateWithoutProcessBomInput, ProcessDetailUncheckedUpdateWithoutProcessBomInput>
    create: XOR<ProcessDetailCreateWithoutProcessBomInput, ProcessDetailUncheckedCreateWithoutProcessBomInput>
    where?: ProcessDetailWhereInput
  }

  export type ProcessDetailUpdateToOneWithWhereWithoutProcessBomInput = {
    where?: ProcessDetailWhereInput
    data: XOR<ProcessDetailUpdateWithoutProcessBomInput, ProcessDetailUncheckedUpdateWithoutProcessBomInput>
  }

  export type ProcessDetailUpdateWithoutProcessBomInput = {
    pc_processTitle?: StringFieldUpdateOperationsInput | string
    pc_amountDay?: IntFieldUpdateOperationsInput | number
    pc_reasonType?: StringFieldUpdateOperationsInput | string
    process?: ProcessUpdateOneRequiredWithoutProcessDetailNestedInput
    processBranch?: ProcessBranchUpdateManyWithoutProcessDetailNestedInput
    processMat?: ProcessMatUpdateManyWithoutProcessDetailNestedInput
  }

  export type ProcessDetailUncheckedUpdateWithoutProcessBomInput = {
    id?: IntFieldUpdateOperationsInput | number
    pc_bluePrintNo?: StringFieldUpdateOperationsInput | string
    pc_processTitle?: StringFieldUpdateOperationsInput | string
    pc_amountDay?: IntFieldUpdateOperationsInput | number
    pc_reasonType?: StringFieldUpdateOperationsInput | string
    processBranch?: ProcessBranchUncheckedUpdateManyWithoutProcessDetailNestedInput
    processMat?: ProcessMatUncheckedUpdateManyWithoutProcessDetailNestedInput
  }

  export type UserCreateWithoutProjectInput = {
    userId: string
    firstName: string
    lastName: string
    password: string
    companyId?: number | null
    companyBranchId?: number | null
    role: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    department?: DepartmentCreateNestedOneWithoutUserInput
    processes?: ProcessCreateNestedManyWithoutUserInput
    exams?: ExamAttemptCreateNestedManyWithoutUserInput
    enrollments?: EnrollmentCreateNestedManyWithoutUserInput
    oplDocuments?: OplDocumentCreateNestedManyWithoutUserInput
    files?: FileCreateNestedManyWithoutUserInput
    createdCourses?: CourseCreateNestedManyWithoutCreatorInput
    deletedCourses?: CourseCreateNestedManyWithoutDeleterInput
    courseCompletions?: UserCourseCompletionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutProjectInput = {
    id?: number
    userId: string
    firstName: string
    lastName: string
    password: string
    companyId?: number | null
    companyBranchId?: number | null
    departmentId?: number | null
    role: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    processes?: ProcessUncheckedCreateNestedManyWithoutUserInput
    exams?: ExamAttemptUncheckedCreateNestedManyWithoutUserInput
    enrollments?: EnrollmentUncheckedCreateNestedManyWithoutUserInput
    oplDocuments?: OplDocumentUncheckedCreateNestedManyWithoutUserInput
    files?: FileUncheckedCreateNestedManyWithoutUserInput
    createdCourses?: CourseUncheckedCreateNestedManyWithoutCreatorInput
    deletedCourses?: CourseUncheckedCreateNestedManyWithoutDeleterInput
    courseCompletions?: UserCourseCompletionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutProjectInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutProjectInput, UserUncheckedCreateWithoutProjectInput>
  }

  export type ProjectDetailCreateWithoutProjectInput = {
    pj_bluePrintNo: string
    pj_serialNumber: string
    pj_processTitle: string
    pj_amountDay: number
    pj_reasonType: string
    pj_statusPc: string
    projectBranch?: ProjectBranchCreateNestedManyWithoutProjectDetailInput
    projectMat?: ProjectMatCreateNestedManyWithoutProjectDetailInput
    projectBom?: ProjectBomCreateNestedManyWithoutProjectDetailInput
    ProjectResUser?: ProjectResUserCreateNestedManyWithoutProjectDetailInput
  }

  export type ProjectDetailUncheckedCreateWithoutProjectInput = {
    id?: number
    pj_bluePrintNo: string
    pj_serialNumber: string
    pj_processTitle: string
    pj_amountDay: number
    pj_reasonType: string
    pj_statusPc: string
    projectBranch?: ProjectBranchUncheckedCreateNestedManyWithoutProjectDetailInput
    projectMat?: ProjectMatUncheckedCreateNestedManyWithoutProjectDetailInput
    projectBom?: ProjectBomUncheckedCreateNestedManyWithoutProjectDetailInput
    ProjectResUser?: ProjectResUserUncheckedCreateNestedManyWithoutProjectDetailInput
  }

  export type ProjectDetailCreateOrConnectWithoutProjectInput = {
    where: ProjectDetailWhereUniqueInput
    create: XOR<ProjectDetailCreateWithoutProjectInput, ProjectDetailUncheckedCreateWithoutProjectInput>
  }

  export type ProjectDetailCreateManyProjectInputEnvelope = {
    data: ProjectDetailCreateManyProjectInput | ProjectDetailCreateManyProjectInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutProjectInput = {
    update: XOR<UserUpdateWithoutProjectInput, UserUncheckedUpdateWithoutProjectInput>
    create: XOR<UserCreateWithoutProjectInput, UserUncheckedCreateWithoutProjectInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutProjectInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutProjectInput, UserUncheckedUpdateWithoutProjectInput>
  }

  export type UserUpdateWithoutProjectInput = {
    userId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    companyId?: NullableIntFieldUpdateOperationsInput | number | null
    companyBranchId?: NullableIntFieldUpdateOperationsInput | number | null
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    department?: DepartmentUpdateOneWithoutUserNestedInput
    processes?: ProcessUpdateManyWithoutUserNestedInput
    exams?: ExamAttemptUpdateManyWithoutUserNestedInput
    enrollments?: EnrollmentUpdateManyWithoutUserNestedInput
    oplDocuments?: OplDocumentUpdateManyWithoutUserNestedInput
    files?: FileUpdateManyWithoutUserNestedInput
    createdCourses?: CourseUpdateManyWithoutCreatorNestedInput
    deletedCourses?: CourseUpdateManyWithoutDeleterNestedInput
    courseCompletions?: UserCourseCompletionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutProjectInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    companyId?: NullableIntFieldUpdateOperationsInput | number | null
    companyBranchId?: NullableIntFieldUpdateOperationsInput | number | null
    departmentId?: NullableIntFieldUpdateOperationsInput | number | null
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    processes?: ProcessUncheckedUpdateManyWithoutUserNestedInput
    exams?: ExamAttemptUncheckedUpdateManyWithoutUserNestedInput
    enrollments?: EnrollmentUncheckedUpdateManyWithoutUserNestedInput
    oplDocuments?: OplDocumentUncheckedUpdateManyWithoutUserNestedInput
    files?: FileUncheckedUpdateManyWithoutUserNestedInput
    createdCourses?: CourseUncheckedUpdateManyWithoutCreatorNestedInput
    deletedCourses?: CourseUncheckedUpdateManyWithoutDeleterNestedInput
    courseCompletions?: UserCourseCompletionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ProjectDetailUpsertWithWhereUniqueWithoutProjectInput = {
    where: ProjectDetailWhereUniqueInput
    update: XOR<ProjectDetailUpdateWithoutProjectInput, ProjectDetailUncheckedUpdateWithoutProjectInput>
    create: XOR<ProjectDetailCreateWithoutProjectInput, ProjectDetailUncheckedCreateWithoutProjectInput>
  }

  export type ProjectDetailUpdateWithWhereUniqueWithoutProjectInput = {
    where: ProjectDetailWhereUniqueInput
    data: XOR<ProjectDetailUpdateWithoutProjectInput, ProjectDetailUncheckedUpdateWithoutProjectInput>
  }

  export type ProjectDetailUpdateManyWithWhereWithoutProjectInput = {
    where: ProjectDetailScalarWhereInput
    data: XOR<ProjectDetailUpdateManyMutationInput, ProjectDetailUncheckedUpdateManyWithoutProjectInput>
  }

  export type ProjectDetailScalarWhereInput = {
    AND?: ProjectDetailScalarWhereInput | ProjectDetailScalarWhereInput[]
    OR?: ProjectDetailScalarWhereInput[]
    NOT?: ProjectDetailScalarWhereInput | ProjectDetailScalarWhereInput[]
    id?: IntFilter<"ProjectDetail"> | number
    pj_projectId?: IntFilter<"ProjectDetail"> | number
    pj_bluePrintNo?: StringFilter<"ProjectDetail"> | string
    pj_serialNumber?: StringFilter<"ProjectDetail"> | string
    pj_processTitle?: StringFilter<"ProjectDetail"> | string
    pj_amountDay?: IntFilter<"ProjectDetail"> | number
    pj_reasonType?: StringFilter<"ProjectDetail"> | string
    pj_statusPc?: StringFilter<"ProjectDetail"> | string
  }

  export type ProjectCreateWithoutProjectDetailInput = {
    pj_bluePrintNo: string
    pj_serialNumber: string
    pj_projectName: string
    pj_startDate: Date | string
    pj_endDate: Date | string
    pj_amountProduct: number
    pj_totalDay: number
    pj_imageProduct: string
    pj_remark: string
    pj_status: string
    pj_type: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    user: UserCreateNestedOneWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutProjectDetailInput = {
    id?: number
    pj_bluePrintNo: string
    pj_serialNumber: string
    pj_projectName: string
    pj_startDate: Date | string
    pj_endDate: Date | string
    pj_amountProduct: number
    pj_totalDay: number
    pj_imageProduct: string
    pj_remark: string
    pj_status: string
    pj_type: string
    pj_userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type ProjectCreateOrConnectWithoutProjectDetailInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutProjectDetailInput, ProjectUncheckedCreateWithoutProjectDetailInput>
  }

  export type ProjectBranchCreateWithoutProjectDetailInput = {
    pj_remark: string
  }

  export type ProjectBranchUncheckedCreateWithoutProjectDetailInput = {
    id?: number
    pj_remark: string
  }

  export type ProjectBranchCreateOrConnectWithoutProjectDetailInput = {
    where: ProjectBranchWhereUniqueInput
    create: XOR<ProjectBranchCreateWithoutProjectDetailInput, ProjectBranchUncheckedCreateWithoutProjectDetailInput>
  }

  export type ProjectBranchCreateManyProjectDetailInputEnvelope = {
    data: ProjectBranchCreateManyProjectDetailInput | ProjectBranchCreateManyProjectDetailInput[]
    skipDuplicates?: boolean
  }

  export type ProjectMatCreateWithoutProjectDetailInput = {
    pj_matamount: number
    pj_matTatal: number
    stock: StockCreateNestedOneWithoutProjectMatInput
  }

  export type ProjectMatUncheckedCreateWithoutProjectDetailInput = {
    id?: number
    pj_matId: string
    pj_matamount: number
    pj_matTatal: number
  }

  export type ProjectMatCreateOrConnectWithoutProjectDetailInput = {
    where: ProjectMatWhereUniqueInput
    create: XOR<ProjectMatCreateWithoutProjectDetailInput, ProjectMatUncheckedCreateWithoutProjectDetailInput>
  }

  export type ProjectMatCreateManyProjectDetailInputEnvelope = {
    data: ProjectMatCreateManyProjectDetailInput | ProjectMatCreateManyProjectDetailInput[]
    skipDuplicates?: boolean
  }

  export type ProjectBomCreateWithoutProjectDetailInput = {
    pj_bomamount: number
    pj_bomTatal: number
    stock: StockCreateNestedOneWithoutProjectBomInput
  }

  export type ProjectBomUncheckedCreateWithoutProjectDetailInput = {
    id?: number
    pj_bomId: string
    pj_bomamount: number
    pj_bomTatal: number
  }

  export type ProjectBomCreateOrConnectWithoutProjectDetailInput = {
    where: ProjectBomWhereUniqueInput
    create: XOR<ProjectBomCreateWithoutProjectDetailInput, ProjectBomUncheckedCreateWithoutProjectDetailInput>
  }

  export type ProjectBomCreateManyProjectDetailInputEnvelope = {
    data: ProjectBomCreateManyProjectDetailInput | ProjectBomCreateManyProjectDetailInput[]
    skipDuplicates?: boolean
  }

  export type ProjectResUserCreateWithoutProjectDetailInput = {
    pj_userId: string
  }

  export type ProjectResUserUncheckedCreateWithoutProjectDetailInput = {
    id?: number
    pj_userId: string
  }

  export type ProjectResUserCreateOrConnectWithoutProjectDetailInput = {
    where: ProjectResUserWhereUniqueInput
    create: XOR<ProjectResUserCreateWithoutProjectDetailInput, ProjectResUserUncheckedCreateWithoutProjectDetailInput>
  }

  export type ProjectResUserCreateManyProjectDetailInputEnvelope = {
    data: ProjectResUserCreateManyProjectDetailInput | ProjectResUserCreateManyProjectDetailInput[]
    skipDuplicates?: boolean
  }

  export type ProjectUpsertWithoutProjectDetailInput = {
    update: XOR<ProjectUpdateWithoutProjectDetailInput, ProjectUncheckedUpdateWithoutProjectDetailInput>
    create: XOR<ProjectCreateWithoutProjectDetailInput, ProjectUncheckedCreateWithoutProjectDetailInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutProjectDetailInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutProjectDetailInput, ProjectUncheckedUpdateWithoutProjectDetailInput>
  }

  export type ProjectUpdateWithoutProjectDetailInput = {
    pj_bluePrintNo?: StringFieldUpdateOperationsInput | string
    pj_serialNumber?: StringFieldUpdateOperationsInput | string
    pj_projectName?: StringFieldUpdateOperationsInput | string
    pj_startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    pj_endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    pj_amountProduct?: IntFieldUpdateOperationsInput | number
    pj_totalDay?: IntFieldUpdateOperationsInput | number
    pj_imageProduct?: StringFieldUpdateOperationsInput | string
    pj_remark?: StringFieldUpdateOperationsInput | string
    pj_status?: StringFieldUpdateOperationsInput | string
    pj_type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutProjectDetailInput = {
    id?: IntFieldUpdateOperationsInput | number
    pj_bluePrintNo?: StringFieldUpdateOperationsInput | string
    pj_serialNumber?: StringFieldUpdateOperationsInput | string
    pj_projectName?: StringFieldUpdateOperationsInput | string
    pj_startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    pj_endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    pj_amountProduct?: IntFieldUpdateOperationsInput | number
    pj_totalDay?: IntFieldUpdateOperationsInput | number
    pj_imageProduct?: StringFieldUpdateOperationsInput | string
    pj_remark?: StringFieldUpdateOperationsInput | string
    pj_status?: StringFieldUpdateOperationsInput | string
    pj_type?: StringFieldUpdateOperationsInput | string
    pj_userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ProjectBranchUpsertWithWhereUniqueWithoutProjectDetailInput = {
    where: ProjectBranchWhereUniqueInput
    update: XOR<ProjectBranchUpdateWithoutProjectDetailInput, ProjectBranchUncheckedUpdateWithoutProjectDetailInput>
    create: XOR<ProjectBranchCreateWithoutProjectDetailInput, ProjectBranchUncheckedCreateWithoutProjectDetailInput>
  }

  export type ProjectBranchUpdateWithWhereUniqueWithoutProjectDetailInput = {
    where: ProjectBranchWhereUniqueInput
    data: XOR<ProjectBranchUpdateWithoutProjectDetailInput, ProjectBranchUncheckedUpdateWithoutProjectDetailInput>
  }

  export type ProjectBranchUpdateManyWithWhereWithoutProjectDetailInput = {
    where: ProjectBranchScalarWhereInput
    data: XOR<ProjectBranchUpdateManyMutationInput, ProjectBranchUncheckedUpdateManyWithoutProjectDetailInput>
  }

  export type ProjectBranchScalarWhereInput = {
    AND?: ProjectBranchScalarWhereInput | ProjectBranchScalarWhereInput[]
    OR?: ProjectBranchScalarWhereInput[]
    NOT?: ProjectBranchScalarWhereInput | ProjectBranchScalarWhereInput[]
    id?: IntFilter<"ProjectBranch"> | number
    pj_projectDetailId?: IntFilter<"ProjectBranch"> | number
    pj_remark?: StringFilter<"ProjectBranch"> | string
  }

  export type ProjectMatUpsertWithWhereUniqueWithoutProjectDetailInput = {
    where: ProjectMatWhereUniqueInput
    update: XOR<ProjectMatUpdateWithoutProjectDetailInput, ProjectMatUncheckedUpdateWithoutProjectDetailInput>
    create: XOR<ProjectMatCreateWithoutProjectDetailInput, ProjectMatUncheckedCreateWithoutProjectDetailInput>
  }

  export type ProjectMatUpdateWithWhereUniqueWithoutProjectDetailInput = {
    where: ProjectMatWhereUniqueInput
    data: XOR<ProjectMatUpdateWithoutProjectDetailInput, ProjectMatUncheckedUpdateWithoutProjectDetailInput>
  }

  export type ProjectMatUpdateManyWithWhereWithoutProjectDetailInput = {
    where: ProjectMatScalarWhereInput
    data: XOR<ProjectMatUpdateManyMutationInput, ProjectMatUncheckedUpdateManyWithoutProjectDetailInput>
  }

  export type ProjectMatScalarWhereInput = {
    AND?: ProjectMatScalarWhereInput | ProjectMatScalarWhereInput[]
    OR?: ProjectMatScalarWhereInput[]
    NOT?: ProjectMatScalarWhereInput | ProjectMatScalarWhereInput[]
    id?: IntFilter<"ProjectMat"> | number
    pj_projectDetailId?: IntFilter<"ProjectMat"> | number
    pj_matId?: StringFilter<"ProjectMat"> | string
    pj_matamount?: IntFilter<"ProjectMat"> | number
    pj_matTatal?: IntFilter<"ProjectMat"> | number
  }

  export type ProjectBomUpsertWithWhereUniqueWithoutProjectDetailInput = {
    where: ProjectBomWhereUniqueInput
    update: XOR<ProjectBomUpdateWithoutProjectDetailInput, ProjectBomUncheckedUpdateWithoutProjectDetailInput>
    create: XOR<ProjectBomCreateWithoutProjectDetailInput, ProjectBomUncheckedCreateWithoutProjectDetailInput>
  }

  export type ProjectBomUpdateWithWhereUniqueWithoutProjectDetailInput = {
    where: ProjectBomWhereUniqueInput
    data: XOR<ProjectBomUpdateWithoutProjectDetailInput, ProjectBomUncheckedUpdateWithoutProjectDetailInput>
  }

  export type ProjectBomUpdateManyWithWhereWithoutProjectDetailInput = {
    where: ProjectBomScalarWhereInput
    data: XOR<ProjectBomUpdateManyMutationInput, ProjectBomUncheckedUpdateManyWithoutProjectDetailInput>
  }

  export type ProjectBomScalarWhereInput = {
    AND?: ProjectBomScalarWhereInput | ProjectBomScalarWhereInput[]
    OR?: ProjectBomScalarWhereInput[]
    NOT?: ProjectBomScalarWhereInput | ProjectBomScalarWhereInput[]
    id?: IntFilter<"ProjectBom"> | number
    pj_projectDetailId?: IntFilter<"ProjectBom"> | number
    pj_bomId?: StringFilter<"ProjectBom"> | string
    pj_bomamount?: IntFilter<"ProjectBom"> | number
    pj_bomTatal?: IntFilter<"ProjectBom"> | number
  }

  export type ProjectResUserUpsertWithWhereUniqueWithoutProjectDetailInput = {
    where: ProjectResUserWhereUniqueInput
    update: XOR<ProjectResUserUpdateWithoutProjectDetailInput, ProjectResUserUncheckedUpdateWithoutProjectDetailInput>
    create: XOR<ProjectResUserCreateWithoutProjectDetailInput, ProjectResUserUncheckedCreateWithoutProjectDetailInput>
  }

  export type ProjectResUserUpdateWithWhereUniqueWithoutProjectDetailInput = {
    where: ProjectResUserWhereUniqueInput
    data: XOR<ProjectResUserUpdateWithoutProjectDetailInput, ProjectResUserUncheckedUpdateWithoutProjectDetailInput>
  }

  export type ProjectResUserUpdateManyWithWhereWithoutProjectDetailInput = {
    where: ProjectResUserScalarWhereInput
    data: XOR<ProjectResUserUpdateManyMutationInput, ProjectResUserUncheckedUpdateManyWithoutProjectDetailInput>
  }

  export type ProjectResUserScalarWhereInput = {
    AND?: ProjectResUserScalarWhereInput | ProjectResUserScalarWhereInput[]
    OR?: ProjectResUserScalarWhereInput[]
    NOT?: ProjectResUserScalarWhereInput | ProjectResUserScalarWhereInput[]
    id?: IntFilter<"ProjectResUser"> | number
    pj_projectDetailId?: IntFilter<"ProjectResUser"> | number
    pj_userId?: StringFilter<"ProjectResUser"> | string
  }

  export type ProjectDetailCreateWithoutProjectBranchInput = {
    pj_bluePrintNo: string
    pj_serialNumber: string
    pj_processTitle: string
    pj_amountDay: number
    pj_reasonType: string
    pj_statusPc: string
    project: ProjectCreateNestedOneWithoutProjectDetailInput
    projectMat?: ProjectMatCreateNestedManyWithoutProjectDetailInput
    projectBom?: ProjectBomCreateNestedManyWithoutProjectDetailInput
    ProjectResUser?: ProjectResUserCreateNestedManyWithoutProjectDetailInput
  }

  export type ProjectDetailUncheckedCreateWithoutProjectBranchInput = {
    id?: number
    pj_projectId: number
    pj_bluePrintNo: string
    pj_serialNumber: string
    pj_processTitle: string
    pj_amountDay: number
    pj_reasonType: string
    pj_statusPc: string
    projectMat?: ProjectMatUncheckedCreateNestedManyWithoutProjectDetailInput
    projectBom?: ProjectBomUncheckedCreateNestedManyWithoutProjectDetailInput
    ProjectResUser?: ProjectResUserUncheckedCreateNestedManyWithoutProjectDetailInput
  }

  export type ProjectDetailCreateOrConnectWithoutProjectBranchInput = {
    where: ProjectDetailWhereUniqueInput
    create: XOR<ProjectDetailCreateWithoutProjectBranchInput, ProjectDetailUncheckedCreateWithoutProjectBranchInput>
  }

  export type ProjectDetailUpsertWithoutProjectBranchInput = {
    update: XOR<ProjectDetailUpdateWithoutProjectBranchInput, ProjectDetailUncheckedUpdateWithoutProjectBranchInput>
    create: XOR<ProjectDetailCreateWithoutProjectBranchInput, ProjectDetailUncheckedCreateWithoutProjectBranchInput>
    where?: ProjectDetailWhereInput
  }

  export type ProjectDetailUpdateToOneWithWhereWithoutProjectBranchInput = {
    where?: ProjectDetailWhereInput
    data: XOR<ProjectDetailUpdateWithoutProjectBranchInput, ProjectDetailUncheckedUpdateWithoutProjectBranchInput>
  }

  export type ProjectDetailUpdateWithoutProjectBranchInput = {
    pj_bluePrintNo?: StringFieldUpdateOperationsInput | string
    pj_serialNumber?: StringFieldUpdateOperationsInput | string
    pj_processTitle?: StringFieldUpdateOperationsInput | string
    pj_amountDay?: IntFieldUpdateOperationsInput | number
    pj_reasonType?: StringFieldUpdateOperationsInput | string
    pj_statusPc?: StringFieldUpdateOperationsInput | string
    project?: ProjectUpdateOneRequiredWithoutProjectDetailNestedInput
    projectMat?: ProjectMatUpdateManyWithoutProjectDetailNestedInput
    projectBom?: ProjectBomUpdateManyWithoutProjectDetailNestedInput
    ProjectResUser?: ProjectResUserUpdateManyWithoutProjectDetailNestedInput
  }

  export type ProjectDetailUncheckedUpdateWithoutProjectBranchInput = {
    id?: IntFieldUpdateOperationsInput | number
    pj_projectId?: IntFieldUpdateOperationsInput | number
    pj_bluePrintNo?: StringFieldUpdateOperationsInput | string
    pj_serialNumber?: StringFieldUpdateOperationsInput | string
    pj_processTitle?: StringFieldUpdateOperationsInput | string
    pj_amountDay?: IntFieldUpdateOperationsInput | number
    pj_reasonType?: StringFieldUpdateOperationsInput | string
    pj_statusPc?: StringFieldUpdateOperationsInput | string
    projectMat?: ProjectMatUncheckedUpdateManyWithoutProjectDetailNestedInput
    projectBom?: ProjectBomUncheckedUpdateManyWithoutProjectDetailNestedInput
    ProjectResUser?: ProjectResUserUncheckedUpdateManyWithoutProjectDetailNestedInput
  }

  export type StockCreateWithoutProjectMatInput = {
    stockId: string
    stockName: string
    stockQuantity: number
    stockType: string
    stockTypeId: number
    stockImage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    processMat?: ProcessMatCreateNestedManyWithoutStockInput
    processBom?: ProcessBomCreateNestedManyWithoutStockInput
    projectBom?: ProjectBomCreateNestedManyWithoutStockInput
  }

  export type StockUncheckedCreateWithoutProjectMatInput = {
    id?: number
    stockId: string
    stockName: string
    stockQuantity: number
    stockType: string
    stockTypeId: number
    stockImage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    processMat?: ProcessMatUncheckedCreateNestedManyWithoutStockInput
    processBom?: ProcessBomUncheckedCreateNestedManyWithoutStockInput
    projectBom?: ProjectBomUncheckedCreateNestedManyWithoutStockInput
  }

  export type StockCreateOrConnectWithoutProjectMatInput = {
    where: StockWhereUniqueInput
    create: XOR<StockCreateWithoutProjectMatInput, StockUncheckedCreateWithoutProjectMatInput>
  }

  export type ProjectDetailCreateWithoutProjectMatInput = {
    pj_bluePrintNo: string
    pj_serialNumber: string
    pj_processTitle: string
    pj_amountDay: number
    pj_reasonType: string
    pj_statusPc: string
    project: ProjectCreateNestedOneWithoutProjectDetailInput
    projectBranch?: ProjectBranchCreateNestedManyWithoutProjectDetailInput
    projectBom?: ProjectBomCreateNestedManyWithoutProjectDetailInput
    ProjectResUser?: ProjectResUserCreateNestedManyWithoutProjectDetailInput
  }

  export type ProjectDetailUncheckedCreateWithoutProjectMatInput = {
    id?: number
    pj_projectId: number
    pj_bluePrintNo: string
    pj_serialNumber: string
    pj_processTitle: string
    pj_amountDay: number
    pj_reasonType: string
    pj_statusPc: string
    projectBranch?: ProjectBranchUncheckedCreateNestedManyWithoutProjectDetailInput
    projectBom?: ProjectBomUncheckedCreateNestedManyWithoutProjectDetailInput
    ProjectResUser?: ProjectResUserUncheckedCreateNestedManyWithoutProjectDetailInput
  }

  export type ProjectDetailCreateOrConnectWithoutProjectMatInput = {
    where: ProjectDetailWhereUniqueInput
    create: XOR<ProjectDetailCreateWithoutProjectMatInput, ProjectDetailUncheckedCreateWithoutProjectMatInput>
  }

  export type StockUpsertWithoutProjectMatInput = {
    update: XOR<StockUpdateWithoutProjectMatInput, StockUncheckedUpdateWithoutProjectMatInput>
    create: XOR<StockCreateWithoutProjectMatInput, StockUncheckedCreateWithoutProjectMatInput>
    where?: StockWhereInput
  }

  export type StockUpdateToOneWithWhereWithoutProjectMatInput = {
    where?: StockWhereInput
    data: XOR<StockUpdateWithoutProjectMatInput, StockUncheckedUpdateWithoutProjectMatInput>
  }

  export type StockUpdateWithoutProjectMatInput = {
    stockId?: StringFieldUpdateOperationsInput | string
    stockName?: StringFieldUpdateOperationsInput | string
    stockQuantity?: IntFieldUpdateOperationsInput | number
    stockType?: StringFieldUpdateOperationsInput | string
    stockTypeId?: IntFieldUpdateOperationsInput | number
    stockImage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    processMat?: ProcessMatUpdateManyWithoutStockNestedInput
    processBom?: ProcessBomUpdateManyWithoutStockNestedInput
    projectBom?: ProjectBomUpdateManyWithoutStockNestedInput
  }

  export type StockUncheckedUpdateWithoutProjectMatInput = {
    id?: IntFieldUpdateOperationsInput | number
    stockId?: StringFieldUpdateOperationsInput | string
    stockName?: StringFieldUpdateOperationsInput | string
    stockQuantity?: IntFieldUpdateOperationsInput | number
    stockType?: StringFieldUpdateOperationsInput | string
    stockTypeId?: IntFieldUpdateOperationsInput | number
    stockImage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    processMat?: ProcessMatUncheckedUpdateManyWithoutStockNestedInput
    processBom?: ProcessBomUncheckedUpdateManyWithoutStockNestedInput
    projectBom?: ProjectBomUncheckedUpdateManyWithoutStockNestedInput
  }

  export type ProjectDetailUpsertWithoutProjectMatInput = {
    update: XOR<ProjectDetailUpdateWithoutProjectMatInput, ProjectDetailUncheckedUpdateWithoutProjectMatInput>
    create: XOR<ProjectDetailCreateWithoutProjectMatInput, ProjectDetailUncheckedCreateWithoutProjectMatInput>
    where?: ProjectDetailWhereInput
  }

  export type ProjectDetailUpdateToOneWithWhereWithoutProjectMatInput = {
    where?: ProjectDetailWhereInput
    data: XOR<ProjectDetailUpdateWithoutProjectMatInput, ProjectDetailUncheckedUpdateWithoutProjectMatInput>
  }

  export type ProjectDetailUpdateWithoutProjectMatInput = {
    pj_bluePrintNo?: StringFieldUpdateOperationsInput | string
    pj_serialNumber?: StringFieldUpdateOperationsInput | string
    pj_processTitle?: StringFieldUpdateOperationsInput | string
    pj_amountDay?: IntFieldUpdateOperationsInput | number
    pj_reasonType?: StringFieldUpdateOperationsInput | string
    pj_statusPc?: StringFieldUpdateOperationsInput | string
    project?: ProjectUpdateOneRequiredWithoutProjectDetailNestedInput
    projectBranch?: ProjectBranchUpdateManyWithoutProjectDetailNestedInput
    projectBom?: ProjectBomUpdateManyWithoutProjectDetailNestedInput
    ProjectResUser?: ProjectResUserUpdateManyWithoutProjectDetailNestedInput
  }

  export type ProjectDetailUncheckedUpdateWithoutProjectMatInput = {
    id?: IntFieldUpdateOperationsInput | number
    pj_projectId?: IntFieldUpdateOperationsInput | number
    pj_bluePrintNo?: StringFieldUpdateOperationsInput | string
    pj_serialNumber?: StringFieldUpdateOperationsInput | string
    pj_processTitle?: StringFieldUpdateOperationsInput | string
    pj_amountDay?: IntFieldUpdateOperationsInput | number
    pj_reasonType?: StringFieldUpdateOperationsInput | string
    pj_statusPc?: StringFieldUpdateOperationsInput | string
    projectBranch?: ProjectBranchUncheckedUpdateManyWithoutProjectDetailNestedInput
    projectBom?: ProjectBomUncheckedUpdateManyWithoutProjectDetailNestedInput
    ProjectResUser?: ProjectResUserUncheckedUpdateManyWithoutProjectDetailNestedInput
  }

  export type StockCreateWithoutProjectBomInput = {
    stockId: string
    stockName: string
    stockQuantity: number
    stockType: string
    stockTypeId: number
    stockImage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    processMat?: ProcessMatCreateNestedManyWithoutStockInput
    processBom?: ProcessBomCreateNestedManyWithoutStockInput
    projectMat?: ProjectMatCreateNestedManyWithoutStockInput
  }

  export type StockUncheckedCreateWithoutProjectBomInput = {
    id?: number
    stockId: string
    stockName: string
    stockQuantity: number
    stockType: string
    stockTypeId: number
    stockImage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    processMat?: ProcessMatUncheckedCreateNestedManyWithoutStockInput
    processBom?: ProcessBomUncheckedCreateNestedManyWithoutStockInput
    projectMat?: ProjectMatUncheckedCreateNestedManyWithoutStockInput
  }

  export type StockCreateOrConnectWithoutProjectBomInput = {
    where: StockWhereUniqueInput
    create: XOR<StockCreateWithoutProjectBomInput, StockUncheckedCreateWithoutProjectBomInput>
  }

  export type ProjectDetailCreateWithoutProjectBomInput = {
    pj_bluePrintNo: string
    pj_serialNumber: string
    pj_processTitle: string
    pj_amountDay: number
    pj_reasonType: string
    pj_statusPc: string
    project: ProjectCreateNestedOneWithoutProjectDetailInput
    projectBranch?: ProjectBranchCreateNestedManyWithoutProjectDetailInput
    projectMat?: ProjectMatCreateNestedManyWithoutProjectDetailInput
    ProjectResUser?: ProjectResUserCreateNestedManyWithoutProjectDetailInput
  }

  export type ProjectDetailUncheckedCreateWithoutProjectBomInput = {
    id?: number
    pj_projectId: number
    pj_bluePrintNo: string
    pj_serialNumber: string
    pj_processTitle: string
    pj_amountDay: number
    pj_reasonType: string
    pj_statusPc: string
    projectBranch?: ProjectBranchUncheckedCreateNestedManyWithoutProjectDetailInput
    projectMat?: ProjectMatUncheckedCreateNestedManyWithoutProjectDetailInput
    ProjectResUser?: ProjectResUserUncheckedCreateNestedManyWithoutProjectDetailInput
  }

  export type ProjectDetailCreateOrConnectWithoutProjectBomInput = {
    where: ProjectDetailWhereUniqueInput
    create: XOR<ProjectDetailCreateWithoutProjectBomInput, ProjectDetailUncheckedCreateWithoutProjectBomInput>
  }

  export type StockUpsertWithoutProjectBomInput = {
    update: XOR<StockUpdateWithoutProjectBomInput, StockUncheckedUpdateWithoutProjectBomInput>
    create: XOR<StockCreateWithoutProjectBomInput, StockUncheckedCreateWithoutProjectBomInput>
    where?: StockWhereInput
  }

  export type StockUpdateToOneWithWhereWithoutProjectBomInput = {
    where?: StockWhereInput
    data: XOR<StockUpdateWithoutProjectBomInput, StockUncheckedUpdateWithoutProjectBomInput>
  }

  export type StockUpdateWithoutProjectBomInput = {
    stockId?: StringFieldUpdateOperationsInput | string
    stockName?: StringFieldUpdateOperationsInput | string
    stockQuantity?: IntFieldUpdateOperationsInput | number
    stockType?: StringFieldUpdateOperationsInput | string
    stockTypeId?: IntFieldUpdateOperationsInput | number
    stockImage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    processMat?: ProcessMatUpdateManyWithoutStockNestedInput
    processBom?: ProcessBomUpdateManyWithoutStockNestedInput
    projectMat?: ProjectMatUpdateManyWithoutStockNestedInput
  }

  export type StockUncheckedUpdateWithoutProjectBomInput = {
    id?: IntFieldUpdateOperationsInput | number
    stockId?: StringFieldUpdateOperationsInput | string
    stockName?: StringFieldUpdateOperationsInput | string
    stockQuantity?: IntFieldUpdateOperationsInput | number
    stockType?: StringFieldUpdateOperationsInput | string
    stockTypeId?: IntFieldUpdateOperationsInput | number
    stockImage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    processMat?: ProcessMatUncheckedUpdateManyWithoutStockNestedInput
    processBom?: ProcessBomUncheckedUpdateManyWithoutStockNestedInput
    projectMat?: ProjectMatUncheckedUpdateManyWithoutStockNestedInput
  }

  export type ProjectDetailUpsertWithoutProjectBomInput = {
    update: XOR<ProjectDetailUpdateWithoutProjectBomInput, ProjectDetailUncheckedUpdateWithoutProjectBomInput>
    create: XOR<ProjectDetailCreateWithoutProjectBomInput, ProjectDetailUncheckedCreateWithoutProjectBomInput>
    where?: ProjectDetailWhereInput
  }

  export type ProjectDetailUpdateToOneWithWhereWithoutProjectBomInput = {
    where?: ProjectDetailWhereInput
    data: XOR<ProjectDetailUpdateWithoutProjectBomInput, ProjectDetailUncheckedUpdateWithoutProjectBomInput>
  }

  export type ProjectDetailUpdateWithoutProjectBomInput = {
    pj_bluePrintNo?: StringFieldUpdateOperationsInput | string
    pj_serialNumber?: StringFieldUpdateOperationsInput | string
    pj_processTitle?: StringFieldUpdateOperationsInput | string
    pj_amountDay?: IntFieldUpdateOperationsInput | number
    pj_reasonType?: StringFieldUpdateOperationsInput | string
    pj_statusPc?: StringFieldUpdateOperationsInput | string
    project?: ProjectUpdateOneRequiredWithoutProjectDetailNestedInput
    projectBranch?: ProjectBranchUpdateManyWithoutProjectDetailNestedInput
    projectMat?: ProjectMatUpdateManyWithoutProjectDetailNestedInput
    ProjectResUser?: ProjectResUserUpdateManyWithoutProjectDetailNestedInput
  }

  export type ProjectDetailUncheckedUpdateWithoutProjectBomInput = {
    id?: IntFieldUpdateOperationsInput | number
    pj_projectId?: IntFieldUpdateOperationsInput | number
    pj_bluePrintNo?: StringFieldUpdateOperationsInput | string
    pj_serialNumber?: StringFieldUpdateOperationsInput | string
    pj_processTitle?: StringFieldUpdateOperationsInput | string
    pj_amountDay?: IntFieldUpdateOperationsInput | number
    pj_reasonType?: StringFieldUpdateOperationsInput | string
    pj_statusPc?: StringFieldUpdateOperationsInput | string
    projectBranch?: ProjectBranchUncheckedUpdateManyWithoutProjectDetailNestedInput
    projectMat?: ProjectMatUncheckedUpdateManyWithoutProjectDetailNestedInput
    ProjectResUser?: ProjectResUserUncheckedUpdateManyWithoutProjectDetailNestedInput
  }

  export type ProjectDetailCreateWithoutProjectResUserInput = {
    pj_bluePrintNo: string
    pj_serialNumber: string
    pj_processTitle: string
    pj_amountDay: number
    pj_reasonType: string
    pj_statusPc: string
    project: ProjectCreateNestedOneWithoutProjectDetailInput
    projectBranch?: ProjectBranchCreateNestedManyWithoutProjectDetailInput
    projectMat?: ProjectMatCreateNestedManyWithoutProjectDetailInput
    projectBom?: ProjectBomCreateNestedManyWithoutProjectDetailInput
  }

  export type ProjectDetailUncheckedCreateWithoutProjectResUserInput = {
    id?: number
    pj_projectId: number
    pj_bluePrintNo: string
    pj_serialNumber: string
    pj_processTitle: string
    pj_amountDay: number
    pj_reasonType: string
    pj_statusPc: string
    projectBranch?: ProjectBranchUncheckedCreateNestedManyWithoutProjectDetailInput
    projectMat?: ProjectMatUncheckedCreateNestedManyWithoutProjectDetailInput
    projectBom?: ProjectBomUncheckedCreateNestedManyWithoutProjectDetailInput
  }

  export type ProjectDetailCreateOrConnectWithoutProjectResUserInput = {
    where: ProjectDetailWhereUniqueInput
    create: XOR<ProjectDetailCreateWithoutProjectResUserInput, ProjectDetailUncheckedCreateWithoutProjectResUserInput>
  }

  export type ProjectDetailUpsertWithoutProjectResUserInput = {
    update: XOR<ProjectDetailUpdateWithoutProjectResUserInput, ProjectDetailUncheckedUpdateWithoutProjectResUserInput>
    create: XOR<ProjectDetailCreateWithoutProjectResUserInput, ProjectDetailUncheckedCreateWithoutProjectResUserInput>
    where?: ProjectDetailWhereInput
  }

  export type ProjectDetailUpdateToOneWithWhereWithoutProjectResUserInput = {
    where?: ProjectDetailWhereInput
    data: XOR<ProjectDetailUpdateWithoutProjectResUserInput, ProjectDetailUncheckedUpdateWithoutProjectResUserInput>
  }

  export type ProjectDetailUpdateWithoutProjectResUserInput = {
    pj_bluePrintNo?: StringFieldUpdateOperationsInput | string
    pj_serialNumber?: StringFieldUpdateOperationsInput | string
    pj_processTitle?: StringFieldUpdateOperationsInput | string
    pj_amountDay?: IntFieldUpdateOperationsInput | number
    pj_reasonType?: StringFieldUpdateOperationsInput | string
    pj_statusPc?: StringFieldUpdateOperationsInput | string
    project?: ProjectUpdateOneRequiredWithoutProjectDetailNestedInput
    projectBranch?: ProjectBranchUpdateManyWithoutProjectDetailNestedInput
    projectMat?: ProjectMatUpdateManyWithoutProjectDetailNestedInput
    projectBom?: ProjectBomUpdateManyWithoutProjectDetailNestedInput
  }

  export type ProjectDetailUncheckedUpdateWithoutProjectResUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    pj_projectId?: IntFieldUpdateOperationsInput | number
    pj_bluePrintNo?: StringFieldUpdateOperationsInput | string
    pj_serialNumber?: StringFieldUpdateOperationsInput | string
    pj_processTitle?: StringFieldUpdateOperationsInput | string
    pj_amountDay?: IntFieldUpdateOperationsInput | number
    pj_reasonType?: StringFieldUpdateOperationsInput | string
    pj_statusPc?: StringFieldUpdateOperationsInput | string
    projectBranch?: ProjectBranchUncheckedUpdateManyWithoutProjectDetailNestedInput
    projectMat?: ProjectMatUncheckedUpdateManyWithoutProjectDetailNestedInput
    projectBom?: ProjectBomUncheckedUpdateManyWithoutProjectDetailNestedInput
  }

  export type ProcessMatCreateWithoutStockInput = {
    pc_matamount: number
    processDetail: ProcessDetailCreateNestedOneWithoutProcessMatInput
  }

  export type ProcessMatUncheckedCreateWithoutStockInput = {
    id?: number
    pc_processDetailId: number
    pc_matamount: number
  }

  export type ProcessMatCreateOrConnectWithoutStockInput = {
    where: ProcessMatWhereUniqueInput
    create: XOR<ProcessMatCreateWithoutStockInput, ProcessMatUncheckedCreateWithoutStockInput>
  }

  export type ProcessMatCreateManyStockInputEnvelope = {
    data: ProcessMatCreateManyStockInput | ProcessMatCreateManyStockInput[]
    skipDuplicates?: boolean
  }

  export type ProcessBomCreateWithoutStockInput = {
    pc_bomamount: number
    processDetail: ProcessDetailCreateNestedOneWithoutProcessBomInput
  }

  export type ProcessBomUncheckedCreateWithoutStockInput = {
    id?: number
    pc_processDetailId: number
    pc_bomamount: number
  }

  export type ProcessBomCreateOrConnectWithoutStockInput = {
    where: ProcessBomWhereUniqueInput
    create: XOR<ProcessBomCreateWithoutStockInput, ProcessBomUncheckedCreateWithoutStockInput>
  }

  export type ProcessBomCreateManyStockInputEnvelope = {
    data: ProcessBomCreateManyStockInput | ProcessBomCreateManyStockInput[]
    skipDuplicates?: boolean
  }

  export type ProjectMatCreateWithoutStockInput = {
    pj_matamount: number
    pj_matTatal: number
    projectDetail: ProjectDetailCreateNestedOneWithoutProjectMatInput
  }

  export type ProjectMatUncheckedCreateWithoutStockInput = {
    id?: number
    pj_projectDetailId: number
    pj_matamount: number
    pj_matTatal: number
  }

  export type ProjectMatCreateOrConnectWithoutStockInput = {
    where: ProjectMatWhereUniqueInput
    create: XOR<ProjectMatCreateWithoutStockInput, ProjectMatUncheckedCreateWithoutStockInput>
  }

  export type ProjectMatCreateManyStockInputEnvelope = {
    data: ProjectMatCreateManyStockInput | ProjectMatCreateManyStockInput[]
    skipDuplicates?: boolean
  }

  export type ProjectBomCreateWithoutStockInput = {
    pj_bomamount: number
    pj_bomTatal: number
    projectDetail: ProjectDetailCreateNestedOneWithoutProjectBomInput
  }

  export type ProjectBomUncheckedCreateWithoutStockInput = {
    id?: number
    pj_projectDetailId: number
    pj_bomamount: number
    pj_bomTatal: number
  }

  export type ProjectBomCreateOrConnectWithoutStockInput = {
    where: ProjectBomWhereUniqueInput
    create: XOR<ProjectBomCreateWithoutStockInput, ProjectBomUncheckedCreateWithoutStockInput>
  }

  export type ProjectBomCreateManyStockInputEnvelope = {
    data: ProjectBomCreateManyStockInput | ProjectBomCreateManyStockInput[]
    skipDuplicates?: boolean
  }

  export type ProcessMatUpsertWithWhereUniqueWithoutStockInput = {
    where: ProcessMatWhereUniqueInput
    update: XOR<ProcessMatUpdateWithoutStockInput, ProcessMatUncheckedUpdateWithoutStockInput>
    create: XOR<ProcessMatCreateWithoutStockInput, ProcessMatUncheckedCreateWithoutStockInput>
  }

  export type ProcessMatUpdateWithWhereUniqueWithoutStockInput = {
    where: ProcessMatWhereUniqueInput
    data: XOR<ProcessMatUpdateWithoutStockInput, ProcessMatUncheckedUpdateWithoutStockInput>
  }

  export type ProcessMatUpdateManyWithWhereWithoutStockInput = {
    where: ProcessMatScalarWhereInput
    data: XOR<ProcessMatUpdateManyMutationInput, ProcessMatUncheckedUpdateManyWithoutStockInput>
  }

  export type ProcessBomUpsertWithWhereUniqueWithoutStockInput = {
    where: ProcessBomWhereUniqueInput
    update: XOR<ProcessBomUpdateWithoutStockInput, ProcessBomUncheckedUpdateWithoutStockInput>
    create: XOR<ProcessBomCreateWithoutStockInput, ProcessBomUncheckedCreateWithoutStockInput>
  }

  export type ProcessBomUpdateWithWhereUniqueWithoutStockInput = {
    where: ProcessBomWhereUniqueInput
    data: XOR<ProcessBomUpdateWithoutStockInput, ProcessBomUncheckedUpdateWithoutStockInput>
  }

  export type ProcessBomUpdateManyWithWhereWithoutStockInput = {
    where: ProcessBomScalarWhereInput
    data: XOR<ProcessBomUpdateManyMutationInput, ProcessBomUncheckedUpdateManyWithoutStockInput>
  }

  export type ProjectMatUpsertWithWhereUniqueWithoutStockInput = {
    where: ProjectMatWhereUniqueInput
    update: XOR<ProjectMatUpdateWithoutStockInput, ProjectMatUncheckedUpdateWithoutStockInput>
    create: XOR<ProjectMatCreateWithoutStockInput, ProjectMatUncheckedCreateWithoutStockInput>
  }

  export type ProjectMatUpdateWithWhereUniqueWithoutStockInput = {
    where: ProjectMatWhereUniqueInput
    data: XOR<ProjectMatUpdateWithoutStockInput, ProjectMatUncheckedUpdateWithoutStockInput>
  }

  export type ProjectMatUpdateManyWithWhereWithoutStockInput = {
    where: ProjectMatScalarWhereInput
    data: XOR<ProjectMatUpdateManyMutationInput, ProjectMatUncheckedUpdateManyWithoutStockInput>
  }

  export type ProjectBomUpsertWithWhereUniqueWithoutStockInput = {
    where: ProjectBomWhereUniqueInput
    update: XOR<ProjectBomUpdateWithoutStockInput, ProjectBomUncheckedUpdateWithoutStockInput>
    create: XOR<ProjectBomCreateWithoutStockInput, ProjectBomUncheckedCreateWithoutStockInput>
  }

  export type ProjectBomUpdateWithWhereUniqueWithoutStockInput = {
    where: ProjectBomWhereUniqueInput
    data: XOR<ProjectBomUpdateWithoutStockInput, ProjectBomUncheckedUpdateWithoutStockInput>
  }

  export type ProjectBomUpdateManyWithWhereWithoutStockInput = {
    where: ProjectBomScalarWhereInput
    data: XOR<ProjectBomUpdateManyMutationInput, ProjectBomUncheckedUpdateManyWithoutStockInput>
  }

  export type ReasonDetailCreateWithoutReasonTypeNGInput = {
    reasondetailName: string
  }

  export type ReasonDetailUncheckedCreateWithoutReasonTypeNGInput = {
    id?: number
    reasondetailName: string
  }

  export type ReasonDetailCreateOrConnectWithoutReasonTypeNGInput = {
    where: ReasonDetailWhereUniqueInput
    create: XOR<ReasonDetailCreateWithoutReasonTypeNGInput, ReasonDetailUncheckedCreateWithoutReasonTypeNGInput>
  }

  export type ReasonDetailCreateManyReasonTypeNGInputEnvelope = {
    data: ReasonDetailCreateManyReasonTypeNGInput | ReasonDetailCreateManyReasonTypeNGInput[]
    skipDuplicates?: boolean
  }

  export type ReasonDetailUpsertWithWhereUniqueWithoutReasonTypeNGInput = {
    where: ReasonDetailWhereUniqueInput
    update: XOR<ReasonDetailUpdateWithoutReasonTypeNGInput, ReasonDetailUncheckedUpdateWithoutReasonTypeNGInput>
    create: XOR<ReasonDetailCreateWithoutReasonTypeNGInput, ReasonDetailUncheckedCreateWithoutReasonTypeNGInput>
  }

  export type ReasonDetailUpdateWithWhereUniqueWithoutReasonTypeNGInput = {
    where: ReasonDetailWhereUniqueInput
    data: XOR<ReasonDetailUpdateWithoutReasonTypeNGInput, ReasonDetailUncheckedUpdateWithoutReasonTypeNGInput>
  }

  export type ReasonDetailUpdateManyWithWhereWithoutReasonTypeNGInput = {
    where: ReasonDetailScalarWhereInput
    data: XOR<ReasonDetailUpdateManyMutationInput, ReasonDetailUncheckedUpdateManyWithoutReasonTypeNGInput>
  }

  export type ReasonDetailScalarWhereInput = {
    AND?: ReasonDetailScalarWhereInput | ReasonDetailScalarWhereInput[]
    OR?: ReasonDetailScalarWhereInput[]
    NOT?: ReasonDetailScalarWhereInput | ReasonDetailScalarWhereInput[]
    id?: IntFilter<"ReasonDetail"> | number
    reasonTypeId?: IntFilter<"ReasonDetail"> | number
    reasondetailName?: StringFilter<"ReasonDetail"> | string
  }

  export type ReasonTypeNGCreateWithoutReasondDetailInput = {
    reasontypeName: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type ReasonTypeNGUncheckedCreateWithoutReasondDetailInput = {
    id?: number
    reasontypeName: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type ReasonTypeNGCreateOrConnectWithoutReasondDetailInput = {
    where: ReasonTypeNGWhereUniqueInput
    create: XOR<ReasonTypeNGCreateWithoutReasondDetailInput, ReasonTypeNGUncheckedCreateWithoutReasondDetailInput>
  }

  export type ReasonTypeNGUpsertWithoutReasondDetailInput = {
    update: XOR<ReasonTypeNGUpdateWithoutReasondDetailInput, ReasonTypeNGUncheckedUpdateWithoutReasondDetailInput>
    create: XOR<ReasonTypeNGCreateWithoutReasondDetailInput, ReasonTypeNGUncheckedCreateWithoutReasondDetailInput>
    where?: ReasonTypeNGWhereInput
  }

  export type ReasonTypeNGUpdateToOneWithWhereWithoutReasondDetailInput = {
    where?: ReasonTypeNGWhereInput
    data: XOR<ReasonTypeNGUpdateWithoutReasondDetailInput, ReasonTypeNGUncheckedUpdateWithoutReasondDetailInput>
  }

  export type ReasonTypeNGUpdateWithoutReasondDetailInput = {
    reasontypeName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ReasonTypeNGUncheckedUpdateWithoutReasondDetailInput = {
    id?: IntFieldUpdateOperationsInput | number
    reasontypeName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ReportProcessCreateWithoutReportInput = {
    processNo: string
    amountday: number
    reportStock?: ReportStockCreateNestedManyWithoutReportProcessInput
  }

  export type ReportProcessUncheckedCreateWithoutReportInput = {
    id?: number
    processNo: string
    amountday: number
    reportStock?: ReportStockUncheckedCreateNestedManyWithoutReportProcessInput
  }

  export type ReportProcessCreateOrConnectWithoutReportInput = {
    where: ReportProcessWhereUniqueInput
    create: XOR<ReportProcessCreateWithoutReportInput, ReportProcessUncheckedCreateWithoutReportInput>
  }

  export type ReportProcessCreateManyReportInputEnvelope = {
    data: ReportProcessCreateManyReportInput | ReportProcessCreateManyReportInput[]
    skipDuplicates?: boolean
  }

  export type ReportProcessUpsertWithWhereUniqueWithoutReportInput = {
    where: ReportProcessWhereUniqueInput
    update: XOR<ReportProcessUpdateWithoutReportInput, ReportProcessUncheckedUpdateWithoutReportInput>
    create: XOR<ReportProcessCreateWithoutReportInput, ReportProcessUncheckedCreateWithoutReportInput>
  }

  export type ReportProcessUpdateWithWhereUniqueWithoutReportInput = {
    where: ReportProcessWhereUniqueInput
    data: XOR<ReportProcessUpdateWithoutReportInput, ReportProcessUncheckedUpdateWithoutReportInput>
  }

  export type ReportProcessUpdateManyWithWhereWithoutReportInput = {
    where: ReportProcessScalarWhereInput
    data: XOR<ReportProcessUpdateManyMutationInput, ReportProcessUncheckedUpdateManyWithoutReportInput>
  }

  export type ReportProcessScalarWhereInput = {
    AND?: ReportProcessScalarWhereInput | ReportProcessScalarWhereInput[]
    OR?: ReportProcessScalarWhereInput[]
    NOT?: ReportProcessScalarWhereInput | ReportProcessScalarWhereInput[]
    id?: IntFilter<"ReportProcess"> | number
    reportId?: IntFilter<"ReportProcess"> | number
    processNo?: StringFilter<"ReportProcess"> | string
    amountday?: IntFilter<"ReportProcess"> | number
  }

  export type ReportCreateWithoutReportProcessInput = {
    projectId: number
    blueprintNo: string
    serialId: string
    reportName: string
    amountComplete: number
    amountNG: number
    timeHour: string
    reportType: string
    status: string
    reasonType?: string | null
    reasonDetail: string
    reasonId?: number | null
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string
    updatedBy: string
    deletedAt?: Date | string | null
    deletedBy: string
  }

  export type ReportUncheckedCreateWithoutReportProcessInput = {
    id?: number
    projectId: number
    blueprintNo: string
    serialId: string
    reportName: string
    amountComplete: number
    amountNG: number
    timeHour: string
    reportType: string
    status: string
    reasonType?: string | null
    reasonDetail: string
    reasonId?: number | null
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string
    updatedBy: string
    deletedAt?: Date | string | null
    deletedBy: string
  }

  export type ReportCreateOrConnectWithoutReportProcessInput = {
    where: ReportWhereUniqueInput
    create: XOR<ReportCreateWithoutReportProcessInput, ReportUncheckedCreateWithoutReportProcessInput>
  }

  export type ReportStockCreateWithoutReportProcessInput = {
    stockId: string
    stockamount: number
    stocktype: number
  }

  export type ReportStockUncheckedCreateWithoutReportProcessInput = {
    id?: number
    stockId: string
    stockamount: number
    stocktype: number
  }

  export type ReportStockCreateOrConnectWithoutReportProcessInput = {
    where: ReportStockWhereUniqueInput
    create: XOR<ReportStockCreateWithoutReportProcessInput, ReportStockUncheckedCreateWithoutReportProcessInput>
  }

  export type ReportStockCreateManyReportProcessInputEnvelope = {
    data: ReportStockCreateManyReportProcessInput | ReportStockCreateManyReportProcessInput[]
    skipDuplicates?: boolean
  }

  export type ReportUpsertWithoutReportProcessInput = {
    update: XOR<ReportUpdateWithoutReportProcessInput, ReportUncheckedUpdateWithoutReportProcessInput>
    create: XOR<ReportCreateWithoutReportProcessInput, ReportUncheckedCreateWithoutReportProcessInput>
    where?: ReportWhereInput
  }

  export type ReportUpdateToOneWithWhereWithoutReportProcessInput = {
    where?: ReportWhereInput
    data: XOR<ReportUpdateWithoutReportProcessInput, ReportUncheckedUpdateWithoutReportProcessInput>
  }

  export type ReportUpdateWithoutReportProcessInput = {
    projectId?: IntFieldUpdateOperationsInput | number
    blueprintNo?: StringFieldUpdateOperationsInput | string
    serialId?: StringFieldUpdateOperationsInput | string
    reportName?: StringFieldUpdateOperationsInput | string
    amountComplete?: IntFieldUpdateOperationsInput | number
    amountNG?: IntFieldUpdateOperationsInput | number
    timeHour?: StringFieldUpdateOperationsInput | string
    reportType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    reasonType?: NullableStringFieldUpdateOperationsInput | string | null
    reasonDetail?: StringFieldUpdateOperationsInput | string
    reasonId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: StringFieldUpdateOperationsInput | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: StringFieldUpdateOperationsInput | string
  }

  export type ReportUncheckedUpdateWithoutReportProcessInput = {
    id?: IntFieldUpdateOperationsInput | number
    projectId?: IntFieldUpdateOperationsInput | number
    blueprintNo?: StringFieldUpdateOperationsInput | string
    serialId?: StringFieldUpdateOperationsInput | string
    reportName?: StringFieldUpdateOperationsInput | string
    amountComplete?: IntFieldUpdateOperationsInput | number
    amountNG?: IntFieldUpdateOperationsInput | number
    timeHour?: StringFieldUpdateOperationsInput | string
    reportType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    reasonType?: NullableStringFieldUpdateOperationsInput | string | null
    reasonDetail?: StringFieldUpdateOperationsInput | string
    reasonId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: StringFieldUpdateOperationsInput | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: StringFieldUpdateOperationsInput | string
  }

  export type ReportStockUpsertWithWhereUniqueWithoutReportProcessInput = {
    where: ReportStockWhereUniqueInput
    update: XOR<ReportStockUpdateWithoutReportProcessInput, ReportStockUncheckedUpdateWithoutReportProcessInput>
    create: XOR<ReportStockCreateWithoutReportProcessInput, ReportStockUncheckedCreateWithoutReportProcessInput>
  }

  export type ReportStockUpdateWithWhereUniqueWithoutReportProcessInput = {
    where: ReportStockWhereUniqueInput
    data: XOR<ReportStockUpdateWithoutReportProcessInput, ReportStockUncheckedUpdateWithoutReportProcessInput>
  }

  export type ReportStockUpdateManyWithWhereWithoutReportProcessInput = {
    where: ReportStockScalarWhereInput
    data: XOR<ReportStockUpdateManyMutationInput, ReportStockUncheckedUpdateManyWithoutReportProcessInput>
  }

  export type ReportStockScalarWhereInput = {
    AND?: ReportStockScalarWhereInput | ReportStockScalarWhereInput[]
    OR?: ReportStockScalarWhereInput[]
    NOT?: ReportStockScalarWhereInput | ReportStockScalarWhereInput[]
    id?: IntFilter<"ReportStock"> | number
    reportProcessId?: IntFilter<"ReportStock"> | number
    stockId?: StringFilter<"ReportStock"> | string
    stockamount?: IntFilter<"ReportStock"> | number
    stocktype?: IntFilter<"ReportStock"> | number
  }

  export type ReportProcessCreateWithoutReportStockInput = {
    processNo: string
    amountday: number
    report: ReportCreateNestedOneWithoutReportProcessInput
  }

  export type ReportProcessUncheckedCreateWithoutReportStockInput = {
    id?: number
    reportId: number
    processNo: string
    amountday: number
  }

  export type ReportProcessCreateOrConnectWithoutReportStockInput = {
    where: ReportProcessWhereUniqueInput
    create: XOR<ReportProcessCreateWithoutReportStockInput, ReportProcessUncheckedCreateWithoutReportStockInput>
  }

  export type ReportProcessUpsertWithoutReportStockInput = {
    update: XOR<ReportProcessUpdateWithoutReportStockInput, ReportProcessUncheckedUpdateWithoutReportStockInput>
    create: XOR<ReportProcessCreateWithoutReportStockInput, ReportProcessUncheckedCreateWithoutReportStockInput>
    where?: ReportProcessWhereInput
  }

  export type ReportProcessUpdateToOneWithWhereWithoutReportStockInput = {
    where?: ReportProcessWhereInput
    data: XOR<ReportProcessUpdateWithoutReportStockInput, ReportProcessUncheckedUpdateWithoutReportStockInput>
  }

  export type ReportProcessUpdateWithoutReportStockInput = {
    processNo?: StringFieldUpdateOperationsInput | string
    amountday?: IntFieldUpdateOperationsInput | number
    report?: ReportUpdateOneRequiredWithoutReportProcessNestedInput
  }

  export type ReportProcessUncheckedUpdateWithoutReportStockInput = {
    id?: IntFieldUpdateOperationsInput | number
    reportId?: IntFieldUpdateOperationsInput | number
    processNo?: StringFieldUpdateOperationsInput | string
    amountday?: IntFieldUpdateOperationsInput | number
  }

  export type ProcessCreateManyUserInput = {
    id?: number
    pc_bluePrintNo: string
    pc_imageBluePrint: string
    pc_totalProcess: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type ExamAttemptCreateManyUserInput = {
    id?: number
    examId: number
    startedAt?: Date | string
    endedAt?: Date | string | null
    grade?: number | null
    isPassed?: boolean | null
  }

  export type EnrollmentCreateManyUserInput = {
    id?: number
    courseId: number
    progress: number
    completed?: boolean
    isDownloaded?: number
  }

  export type OplDocumentCreateManyUserInput = {
    id?: number
    title: string
    description?: string | null
    fileName: string
    fileType: string
    filePath: string
    template?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type FileCreateManyUserInput = {
    id?: number
    originalName: string
    storedName: string
    fileType: string
    fileSize: bigint | number
    filePath: string
    uploadDate?: Date | string
    courseId?: number | null
  }

  export type CourseCreateManyCreatorInput = {
    id?: number
    title: string
    description?: string | null
    pdfUrl?: string | null
    videoUrl?: string | null
    typeId: number
    template?: boolean
    departmentId?: number | null
    processId?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedBy?: number | null
    isDeleted?: boolean
  }

  export type CourseCreateManyDeleterInput = {
    id?: number
    title: string
    description?: string | null
    pdfUrl?: string | null
    videoUrl?: string | null
    typeId: number
    template?: boolean
    departmentId?: number | null
    processId?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: number
    isDeleted?: boolean
  }

  export type UserCourseCompletionCreateManyUserInput = {
    id?: number
    courseId: number
    examId: number
    processId: number
    completedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProjectCreateManyUserInput = {
    id?: number
    pj_bluePrintNo: string
    pj_serialNumber: string
    pj_projectName: string
    pj_startDate: Date | string
    pj_endDate: Date | string
    pj_amountProduct: number
    pj_totalDay: number
    pj_imageProduct: string
    pj_remark: string
    pj_status: string
    pj_type: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type ProcessUpdateWithoutUserInput = {
    pc_bluePrintNo?: StringFieldUpdateOperationsInput | string
    pc_imageBluePrint?: StringFieldUpdateOperationsInput | string
    pc_totalProcess?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    courses?: CourseUpdateManyWithoutProcessNestedInput
    completions?: UserCourseCompletionUpdateManyWithoutProcessNestedInput
    processDetail?: ProcessDetailUpdateManyWithoutProcessNestedInput
  }

  export type ProcessUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    pc_bluePrintNo?: StringFieldUpdateOperationsInput | string
    pc_imageBluePrint?: StringFieldUpdateOperationsInput | string
    pc_totalProcess?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    courses?: CourseUncheckedUpdateManyWithoutProcessNestedInput
    completions?: UserCourseCompletionUncheckedUpdateManyWithoutProcessNestedInput
    processDetail?: ProcessDetailUncheckedUpdateManyWithoutProcessNestedInput
  }

  export type ProcessUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    pc_bluePrintNo?: StringFieldUpdateOperationsInput | string
    pc_imageBluePrint?: StringFieldUpdateOperationsInput | string
    pc_totalProcess?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ExamAttemptUpdateWithoutUserInput = {
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    grade?: NullableFloatFieldUpdateOperationsInput | number | null
    isPassed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    exam?: ExamUpdateOneRequiredWithoutAttemptsNestedInput
    answers?: UserAnswerUpdateManyWithoutExamAttemptNestedInput
  }

  export type ExamAttemptUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    examId?: IntFieldUpdateOperationsInput | number
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    grade?: NullableFloatFieldUpdateOperationsInput | number | null
    isPassed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    answers?: UserAnswerUncheckedUpdateManyWithoutExamAttemptNestedInput
  }

  export type ExamAttemptUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    examId?: IntFieldUpdateOperationsInput | number
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    grade?: NullableFloatFieldUpdateOperationsInput | number | null
    isPassed?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type EnrollmentUpdateWithoutUserInput = {
    progress?: FloatFieldUpdateOperationsInput | number
    completed?: BoolFieldUpdateOperationsInput | boolean
    isDownloaded?: FloatFieldUpdateOperationsInput | number
    course?: CourseUpdateOneRequiredWithoutEnrollmentsNestedInput
  }

  export type EnrollmentUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    courseId?: IntFieldUpdateOperationsInput | number
    progress?: FloatFieldUpdateOperationsInput | number
    completed?: BoolFieldUpdateOperationsInput | boolean
    isDownloaded?: FloatFieldUpdateOperationsInput | number
  }

  export type EnrollmentUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    courseId?: IntFieldUpdateOperationsInput | number
    progress?: FloatFieldUpdateOperationsInput | number
    completed?: BoolFieldUpdateOperationsInput | boolean
    isDownloaded?: FloatFieldUpdateOperationsInput | number
  }

  export type OplDocumentUpdateWithoutUserInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    fileName?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    template?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type OplDocumentUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    fileName?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    template?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type OplDocumentUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    fileName?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    template?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type FileUpdateWithoutUserInput = {
    originalName?: StringFieldUpdateOperationsInput | string
    storedName?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
    fileSize?: BigIntFieldUpdateOperationsInput | bigint | number
    filePath?: StringFieldUpdateOperationsInput | string
    uploadDate?: DateTimeFieldUpdateOperationsInput | Date | string
    course?: CourseUpdateOneWithoutFilesNestedInput
  }

  export type FileUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    originalName?: StringFieldUpdateOperationsInput | string
    storedName?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
    fileSize?: BigIntFieldUpdateOperationsInput | bigint | number
    filePath?: StringFieldUpdateOperationsInput | string
    uploadDate?: DateTimeFieldUpdateOperationsInput | Date | string
    courseId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type FileUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    originalName?: StringFieldUpdateOperationsInput | string
    storedName?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
    fileSize?: BigIntFieldUpdateOperationsInput | bigint | number
    filePath?: StringFieldUpdateOperationsInput | string
    uploadDate?: DateTimeFieldUpdateOperationsInput | Date | string
    courseId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type CourseUpdateWithoutCreatorInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    pdfUrl?: NullableStringFieldUpdateOperationsInput | string | null
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    typeId?: IntFieldUpdateOperationsInput | number
    template?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    department?: DepartmentUpdateOneWithoutCourseNestedInput
    process?: ProcessUpdateOneWithoutCoursesNestedInput
    enrollments?: EnrollmentUpdateManyWithoutCourseNestedInput
    files?: FileUpdateManyWithoutCourseNestedInput
    exams?: ExamUpdateManyWithoutCourseNestedInput
    completions?: UserCourseCompletionUpdateManyWithoutCourseNestedInput
    deleter?: UserUpdateOneWithoutDeletedCoursesNestedInput
  }

  export type CourseUncheckedUpdateWithoutCreatorInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    pdfUrl?: NullableStringFieldUpdateOperationsInput | string | null
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    typeId?: IntFieldUpdateOperationsInput | number
    template?: BoolFieldUpdateOperationsInput | boolean
    departmentId?: NullableIntFieldUpdateOperationsInput | number | null
    processId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedBy?: NullableIntFieldUpdateOperationsInput | number | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    enrollments?: EnrollmentUncheckedUpdateManyWithoutCourseNestedInput
    files?: FileUncheckedUpdateManyWithoutCourseNestedInput
    exams?: ExamUncheckedUpdateManyWithoutCourseNestedInput
    completions?: UserCourseCompletionUncheckedUpdateManyWithoutCourseNestedInput
  }

  export type CourseUncheckedUpdateManyWithoutCreatorInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    pdfUrl?: NullableStringFieldUpdateOperationsInput | string | null
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    typeId?: IntFieldUpdateOperationsInput | number
    template?: BoolFieldUpdateOperationsInput | boolean
    departmentId?: NullableIntFieldUpdateOperationsInput | number | null
    processId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedBy?: NullableIntFieldUpdateOperationsInput | number | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type CourseUpdateWithoutDeleterInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    pdfUrl?: NullableStringFieldUpdateOperationsInput | string | null
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    typeId?: IntFieldUpdateOperationsInput | number
    template?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    department?: DepartmentUpdateOneWithoutCourseNestedInput
    process?: ProcessUpdateOneWithoutCoursesNestedInput
    enrollments?: EnrollmentUpdateManyWithoutCourseNestedInput
    files?: FileUpdateManyWithoutCourseNestedInput
    exams?: ExamUpdateManyWithoutCourseNestedInput
    completions?: UserCourseCompletionUpdateManyWithoutCourseNestedInput
    creator?: UserUpdateOneRequiredWithoutCreatedCoursesNestedInput
  }

  export type CourseUncheckedUpdateWithoutDeleterInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    pdfUrl?: NullableStringFieldUpdateOperationsInput | string | null
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    typeId?: IntFieldUpdateOperationsInput | number
    template?: BoolFieldUpdateOperationsInput | boolean
    departmentId?: NullableIntFieldUpdateOperationsInput | number | null
    processId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: IntFieldUpdateOperationsInput | number
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    enrollments?: EnrollmentUncheckedUpdateManyWithoutCourseNestedInput
    files?: FileUncheckedUpdateManyWithoutCourseNestedInput
    exams?: ExamUncheckedUpdateManyWithoutCourseNestedInput
    completions?: UserCourseCompletionUncheckedUpdateManyWithoutCourseNestedInput
  }

  export type CourseUncheckedUpdateManyWithoutDeleterInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    pdfUrl?: NullableStringFieldUpdateOperationsInput | string | null
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    typeId?: IntFieldUpdateOperationsInput | number
    template?: BoolFieldUpdateOperationsInput | boolean
    departmentId?: NullableIntFieldUpdateOperationsInput | number | null
    processId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: IntFieldUpdateOperationsInput | number
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type UserCourseCompletionUpdateWithoutUserInput = {
    completedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    course?: CourseUpdateOneRequiredWithoutCompletionsNestedInput
    exam?: ExamUpdateOneRequiredWithoutCompletionsNestedInput
    process?: ProcessUpdateOneRequiredWithoutCompletionsNestedInput
  }

  export type UserCourseCompletionUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    courseId?: IntFieldUpdateOperationsInput | number
    examId?: IntFieldUpdateOperationsInput | number
    processId?: IntFieldUpdateOperationsInput | number
    completedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCourseCompletionUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    courseId?: IntFieldUpdateOperationsInput | number
    examId?: IntFieldUpdateOperationsInput | number
    processId?: IntFieldUpdateOperationsInput | number
    completedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectUpdateWithoutUserInput = {
    pj_bluePrintNo?: StringFieldUpdateOperationsInput | string
    pj_serialNumber?: StringFieldUpdateOperationsInput | string
    pj_projectName?: StringFieldUpdateOperationsInput | string
    pj_startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    pj_endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    pj_amountProduct?: IntFieldUpdateOperationsInput | number
    pj_totalDay?: IntFieldUpdateOperationsInput | number
    pj_imageProduct?: StringFieldUpdateOperationsInput | string
    pj_remark?: StringFieldUpdateOperationsInput | string
    pj_status?: StringFieldUpdateOperationsInput | string
    pj_type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    projectDetail?: ProjectDetailUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    pj_bluePrintNo?: StringFieldUpdateOperationsInput | string
    pj_serialNumber?: StringFieldUpdateOperationsInput | string
    pj_projectName?: StringFieldUpdateOperationsInput | string
    pj_startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    pj_endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    pj_amountProduct?: IntFieldUpdateOperationsInput | number
    pj_totalDay?: IntFieldUpdateOperationsInput | number
    pj_imageProduct?: StringFieldUpdateOperationsInput | string
    pj_remark?: StringFieldUpdateOperationsInput | string
    pj_status?: StringFieldUpdateOperationsInput | string
    pj_type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    projectDetail?: ProjectDetailUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    pj_bluePrintNo?: StringFieldUpdateOperationsInput | string
    pj_serialNumber?: StringFieldUpdateOperationsInput | string
    pj_projectName?: StringFieldUpdateOperationsInput | string
    pj_startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    pj_endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    pj_amountProduct?: IntFieldUpdateOperationsInput | number
    pj_totalDay?: IntFieldUpdateOperationsInput | number
    pj_imageProduct?: StringFieldUpdateOperationsInput | string
    pj_remark?: StringFieldUpdateOperationsInput | string
    pj_status?: StringFieldUpdateOperationsInput | string
    pj_type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CompanyBranchCreateManyCompanyInput = {
    id?: number
    companyBranchName: string
  }

  export type CompanyBranchUpdateWithoutCompanyInput = {
    companyBranchName?: StringFieldUpdateOperationsInput | string
  }

  export type CompanyBranchUncheckedUpdateWithoutCompanyInput = {
    id?: IntFieldUpdateOperationsInput | number
    companyBranchName?: StringFieldUpdateOperationsInput | string
  }

  export type CompanyBranchUncheckedUpdateManyWithoutCompanyInput = {
    id?: IntFieldUpdateOperationsInput | number
    companyBranchName?: StringFieldUpdateOperationsInput | string
  }

  export type UserCreateManyDepartmentInput = {
    id?: number
    userId: string
    firstName: string
    lastName: string
    password: string
    companyId?: number | null
    companyBranchId?: number | null
    role: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type CourseCreateManyDepartmentInput = {
    id?: number
    title: string
    description?: string | null
    pdfUrl?: string | null
    videoUrl?: string | null
    typeId: number
    template?: boolean
    processId?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: number
    deletedBy?: number | null
    isDeleted?: boolean
  }

  export type UserUpdateWithoutDepartmentInput = {
    userId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    companyId?: NullableIntFieldUpdateOperationsInput | number | null
    companyBranchId?: NullableIntFieldUpdateOperationsInput | number | null
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    processes?: ProcessUpdateManyWithoutUserNestedInput
    exams?: ExamAttemptUpdateManyWithoutUserNestedInput
    enrollments?: EnrollmentUpdateManyWithoutUserNestedInput
    oplDocuments?: OplDocumentUpdateManyWithoutUserNestedInput
    files?: FileUpdateManyWithoutUserNestedInput
    createdCourses?: CourseUpdateManyWithoutCreatorNestedInput
    deletedCourses?: CourseUpdateManyWithoutDeleterNestedInput
    courseCompletions?: UserCourseCompletionUpdateManyWithoutUserNestedInput
    project?: ProjectUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutDepartmentInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    companyId?: NullableIntFieldUpdateOperationsInput | number | null
    companyBranchId?: NullableIntFieldUpdateOperationsInput | number | null
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    processes?: ProcessUncheckedUpdateManyWithoutUserNestedInput
    exams?: ExamAttemptUncheckedUpdateManyWithoutUserNestedInput
    enrollments?: EnrollmentUncheckedUpdateManyWithoutUserNestedInput
    oplDocuments?: OplDocumentUncheckedUpdateManyWithoutUserNestedInput
    files?: FileUncheckedUpdateManyWithoutUserNestedInput
    createdCourses?: CourseUncheckedUpdateManyWithoutCreatorNestedInput
    deletedCourses?: CourseUncheckedUpdateManyWithoutDeleterNestedInput
    courseCompletions?: UserCourseCompletionUncheckedUpdateManyWithoutUserNestedInput
    project?: ProjectUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateManyWithoutDepartmentInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    companyId?: NullableIntFieldUpdateOperationsInput | number | null
    companyBranchId?: NullableIntFieldUpdateOperationsInput | number | null
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CourseUpdateWithoutDepartmentInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    pdfUrl?: NullableStringFieldUpdateOperationsInput | string | null
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    typeId?: IntFieldUpdateOperationsInput | number
    template?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    process?: ProcessUpdateOneWithoutCoursesNestedInput
    enrollments?: EnrollmentUpdateManyWithoutCourseNestedInput
    files?: FileUpdateManyWithoutCourseNestedInput
    exams?: ExamUpdateManyWithoutCourseNestedInput
    completions?: UserCourseCompletionUpdateManyWithoutCourseNestedInput
    creator?: UserUpdateOneRequiredWithoutCreatedCoursesNestedInput
    deleter?: UserUpdateOneWithoutDeletedCoursesNestedInput
  }

  export type CourseUncheckedUpdateWithoutDepartmentInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    pdfUrl?: NullableStringFieldUpdateOperationsInput | string | null
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    typeId?: IntFieldUpdateOperationsInput | number
    template?: BoolFieldUpdateOperationsInput | boolean
    processId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: IntFieldUpdateOperationsInput | number
    deletedBy?: NullableIntFieldUpdateOperationsInput | number | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    enrollments?: EnrollmentUncheckedUpdateManyWithoutCourseNestedInput
    files?: FileUncheckedUpdateManyWithoutCourseNestedInput
    exams?: ExamUncheckedUpdateManyWithoutCourseNestedInput
    completions?: UserCourseCompletionUncheckedUpdateManyWithoutCourseNestedInput
  }

  export type CourseUncheckedUpdateManyWithoutDepartmentInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    pdfUrl?: NullableStringFieldUpdateOperationsInput | string | null
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    typeId?: IntFieldUpdateOperationsInput | number
    template?: BoolFieldUpdateOperationsInput | boolean
    processId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: IntFieldUpdateOperationsInput | number
    deletedBy?: NullableIntFieldUpdateOperationsInput | number | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type EnrollmentCreateManyCourseInput = {
    id?: number
    userId: number
    progress: number
    completed?: boolean
    isDownloaded?: number
  }

  export type FileCreateManyCourseInput = {
    id?: number
    originalName: string
    storedName: string
    fileType: string
    fileSize: bigint | number
    filePath: string
    uploadDate?: Date | string
    userId?: number | null
  }

  export type ExamCreateManyCourseInput = {
    id?: number
    title: string
    departmentId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    description?: string | null
    deleted?: boolean
  }

  export type UserCourseCompletionCreateManyCourseInput = {
    id?: number
    userId: number
    username: string
    examId: number
    processId: number
    completedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EnrollmentUpdateWithoutCourseInput = {
    progress?: FloatFieldUpdateOperationsInput | number
    completed?: BoolFieldUpdateOperationsInput | boolean
    isDownloaded?: FloatFieldUpdateOperationsInput | number
    user?: UserUpdateOneRequiredWithoutEnrollmentsNestedInput
  }

  export type EnrollmentUncheckedUpdateWithoutCourseInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    progress?: FloatFieldUpdateOperationsInput | number
    completed?: BoolFieldUpdateOperationsInput | boolean
    isDownloaded?: FloatFieldUpdateOperationsInput | number
  }

  export type EnrollmentUncheckedUpdateManyWithoutCourseInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    progress?: FloatFieldUpdateOperationsInput | number
    completed?: BoolFieldUpdateOperationsInput | boolean
    isDownloaded?: FloatFieldUpdateOperationsInput | number
  }

  export type FileUpdateWithoutCourseInput = {
    originalName?: StringFieldUpdateOperationsInput | string
    storedName?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
    fileSize?: BigIntFieldUpdateOperationsInput | bigint | number
    filePath?: StringFieldUpdateOperationsInput | string
    uploadDate?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutFilesNestedInput
  }

  export type FileUncheckedUpdateWithoutCourseInput = {
    id?: IntFieldUpdateOperationsInput | number
    originalName?: StringFieldUpdateOperationsInput | string
    storedName?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
    fileSize?: BigIntFieldUpdateOperationsInput | bigint | number
    filePath?: StringFieldUpdateOperationsInput | string
    uploadDate?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type FileUncheckedUpdateManyWithoutCourseInput = {
    id?: IntFieldUpdateOperationsInput | number
    originalName?: StringFieldUpdateOperationsInput | string
    storedName?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
    fileSize?: BigIntFieldUpdateOperationsInput | bigint | number
    filePath?: StringFieldUpdateOperationsInput | string
    uploadDate?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ExamUpdateWithoutCourseInput = {
    title?: StringFieldUpdateOperationsInput | string
    departmentId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    questions?: QuestionUpdateManyWithoutExamNestedInput
    attempts?: ExamAttemptUpdateManyWithoutExamNestedInput
    completions?: UserCourseCompletionUpdateManyWithoutExamNestedInput
  }

  export type ExamUncheckedUpdateWithoutCourseInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    departmentId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    questions?: QuestionUncheckedUpdateManyWithoutExamNestedInput
    attempts?: ExamAttemptUncheckedUpdateManyWithoutExamNestedInput
    completions?: UserCourseCompletionUncheckedUpdateManyWithoutExamNestedInput
  }

  export type ExamUncheckedUpdateManyWithoutCourseInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    departmentId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type UserCourseCompletionUpdateWithoutCourseInput = {
    completedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutCourseCompletionsNestedInput
    exam?: ExamUpdateOneRequiredWithoutCompletionsNestedInput
    process?: ProcessUpdateOneRequiredWithoutCompletionsNestedInput
  }

  export type UserCourseCompletionUncheckedUpdateWithoutCourseInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    examId?: IntFieldUpdateOperationsInput | number
    processId?: IntFieldUpdateOperationsInput | number
    completedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCourseCompletionUncheckedUpdateManyWithoutCourseInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    examId?: IntFieldUpdateOperationsInput | number
    processId?: IntFieldUpdateOperationsInput | number
    completedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuestionCreateManyExamInput = {
    id?: number
    text: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deleted?: boolean
  }

  export type ExamAttemptCreateManyExamInput = {
    id?: number
    userId: number
    startedAt?: Date | string
    endedAt?: Date | string | null
    grade?: number | null
    isPassed?: boolean | null
  }

  export type UserCourseCompletionCreateManyExamInput = {
    id?: number
    userId: number
    username: string
    courseId: number
    processId: number
    completedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuestionUpdateWithoutExamInput = {
    text?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
    choices?: ChoiceUpdateManyWithoutQuestionNestedInput
    userAnswers?: UserAnswerUpdateManyWithoutQuestionNestedInput
  }

  export type QuestionUncheckedUpdateWithoutExamInput = {
    id?: IntFieldUpdateOperationsInput | number
    text?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
    choices?: ChoiceUncheckedUpdateManyWithoutQuestionNestedInput
    userAnswers?: UserAnswerUncheckedUpdateManyWithoutQuestionNestedInput
  }

  export type QuestionUncheckedUpdateManyWithoutExamInput = {
    id?: IntFieldUpdateOperationsInput | number
    text?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ExamAttemptUpdateWithoutExamInput = {
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    grade?: NullableFloatFieldUpdateOperationsInput | number | null
    isPassed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    user?: UserUpdateOneRequiredWithoutExamsNestedInput
    answers?: UserAnswerUpdateManyWithoutExamAttemptNestedInput
  }

  export type ExamAttemptUncheckedUpdateWithoutExamInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    grade?: NullableFloatFieldUpdateOperationsInput | number | null
    isPassed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    answers?: UserAnswerUncheckedUpdateManyWithoutExamAttemptNestedInput
  }

  export type ExamAttemptUncheckedUpdateManyWithoutExamInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    grade?: NullableFloatFieldUpdateOperationsInput | number | null
    isPassed?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type UserCourseCompletionUpdateWithoutExamInput = {
    completedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutCourseCompletionsNestedInput
    course?: CourseUpdateOneRequiredWithoutCompletionsNestedInput
    process?: ProcessUpdateOneRequiredWithoutCompletionsNestedInput
  }

  export type UserCourseCompletionUncheckedUpdateWithoutExamInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    courseId?: IntFieldUpdateOperationsInput | number
    processId?: IntFieldUpdateOperationsInput | number
    completedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCourseCompletionUncheckedUpdateManyWithoutExamInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    courseId?: IntFieldUpdateOperationsInput | number
    processId?: IntFieldUpdateOperationsInput | number
    completedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChoiceCreateManyQuestionInput = {
    id?: number
    text: string
    correct: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deleted?: boolean
  }

  export type UserAnswerCreateManyQuestionInput = {
    id?: number
    examAttemptId: number
    selectedChoiceId: number
    isCorrect: boolean
    createdAt?: Date | string
  }

  export type ChoiceUpdateWithoutQuestionInput = {
    text?: StringFieldUpdateOperationsInput | string
    correct?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
    UserAnswer?: UserAnswerUpdateManyWithoutSelectedChoiceNestedInput
  }

  export type ChoiceUncheckedUpdateWithoutQuestionInput = {
    id?: IntFieldUpdateOperationsInput | number
    text?: StringFieldUpdateOperationsInput | string
    correct?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
    UserAnswer?: UserAnswerUncheckedUpdateManyWithoutSelectedChoiceNestedInput
  }

  export type ChoiceUncheckedUpdateManyWithoutQuestionInput = {
    id?: IntFieldUpdateOperationsInput | number
    text?: StringFieldUpdateOperationsInput | string
    correct?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type UserAnswerUpdateWithoutQuestionInput = {
    isCorrect?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    examAttempt?: ExamAttemptUpdateOneRequiredWithoutAnswersNestedInput
    selectedChoice?: ChoiceUpdateOneRequiredWithoutUserAnswerNestedInput
  }

  export type UserAnswerUncheckedUpdateWithoutQuestionInput = {
    id?: IntFieldUpdateOperationsInput | number
    examAttemptId?: IntFieldUpdateOperationsInput | number
    selectedChoiceId?: IntFieldUpdateOperationsInput | number
    isCorrect?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserAnswerUncheckedUpdateManyWithoutQuestionInput = {
    id?: IntFieldUpdateOperationsInput | number
    examAttemptId?: IntFieldUpdateOperationsInput | number
    selectedChoiceId?: IntFieldUpdateOperationsInput | number
    isCorrect?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserAnswerCreateManySelectedChoiceInput = {
    id?: number
    examAttemptId: number
    questionId: number
    isCorrect: boolean
    createdAt?: Date | string
  }

  export type UserAnswerUpdateWithoutSelectedChoiceInput = {
    isCorrect?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    examAttempt?: ExamAttemptUpdateOneRequiredWithoutAnswersNestedInput
    question?: QuestionUpdateOneRequiredWithoutUserAnswersNestedInput
  }

  export type UserAnswerUncheckedUpdateWithoutSelectedChoiceInput = {
    id?: IntFieldUpdateOperationsInput | number
    examAttemptId?: IntFieldUpdateOperationsInput | number
    questionId?: IntFieldUpdateOperationsInput | number
    isCorrect?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserAnswerUncheckedUpdateManyWithoutSelectedChoiceInput = {
    id?: IntFieldUpdateOperationsInput | number
    examAttemptId?: IntFieldUpdateOperationsInput | number
    questionId?: IntFieldUpdateOperationsInput | number
    isCorrect?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserAnswerCreateManyExamAttemptInput = {
    id?: number
    questionId: number
    selectedChoiceId: number
    isCorrect: boolean
    createdAt?: Date | string
  }

  export type UserAnswerUpdateWithoutExamAttemptInput = {
    isCorrect?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    question?: QuestionUpdateOneRequiredWithoutUserAnswersNestedInput
    selectedChoice?: ChoiceUpdateOneRequiredWithoutUserAnswerNestedInput
  }

  export type UserAnswerUncheckedUpdateWithoutExamAttemptInput = {
    id?: IntFieldUpdateOperationsInput | number
    questionId?: IntFieldUpdateOperationsInput | number
    selectedChoiceId?: IntFieldUpdateOperationsInput | number
    isCorrect?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserAnswerUncheckedUpdateManyWithoutExamAttemptInput = {
    id?: IntFieldUpdateOperationsInput | number
    questionId?: IntFieldUpdateOperationsInput | number
    selectedChoiceId?: IntFieldUpdateOperationsInput | number
    isCorrect?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CourseCreateManyProcessInput = {
    id?: number
    title: string
    description?: string | null
    pdfUrl?: string | null
    videoUrl?: string | null
    typeId: number
    template?: boolean
    departmentId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: number
    deletedBy?: number | null
    isDeleted?: boolean
  }

  export type UserCourseCompletionCreateManyProcessInput = {
    id?: number
    userId: number
    username: string
    courseId: number
    examId: number
    completedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProcessDetailCreateManyProcessInput = {
    id?: number
    pc_processTitle: string
    pc_amountDay: number
    pc_reasonType: string
  }

  export type CourseUpdateWithoutProcessInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    pdfUrl?: NullableStringFieldUpdateOperationsInput | string | null
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    typeId?: IntFieldUpdateOperationsInput | number
    template?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    department?: DepartmentUpdateOneWithoutCourseNestedInput
    enrollments?: EnrollmentUpdateManyWithoutCourseNestedInput
    files?: FileUpdateManyWithoutCourseNestedInput
    exams?: ExamUpdateManyWithoutCourseNestedInput
    completions?: UserCourseCompletionUpdateManyWithoutCourseNestedInput
    creator?: UserUpdateOneRequiredWithoutCreatedCoursesNestedInput
    deleter?: UserUpdateOneWithoutDeletedCoursesNestedInput
  }

  export type CourseUncheckedUpdateWithoutProcessInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    pdfUrl?: NullableStringFieldUpdateOperationsInput | string | null
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    typeId?: IntFieldUpdateOperationsInput | number
    template?: BoolFieldUpdateOperationsInput | boolean
    departmentId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: IntFieldUpdateOperationsInput | number
    deletedBy?: NullableIntFieldUpdateOperationsInput | number | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    enrollments?: EnrollmentUncheckedUpdateManyWithoutCourseNestedInput
    files?: FileUncheckedUpdateManyWithoutCourseNestedInput
    exams?: ExamUncheckedUpdateManyWithoutCourseNestedInput
    completions?: UserCourseCompletionUncheckedUpdateManyWithoutCourseNestedInput
  }

  export type CourseUncheckedUpdateManyWithoutProcessInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    pdfUrl?: NullableStringFieldUpdateOperationsInput | string | null
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    typeId?: IntFieldUpdateOperationsInput | number
    template?: BoolFieldUpdateOperationsInput | boolean
    departmentId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: IntFieldUpdateOperationsInput | number
    deletedBy?: NullableIntFieldUpdateOperationsInput | number | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type UserCourseCompletionUpdateWithoutProcessInput = {
    completedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutCourseCompletionsNestedInput
    course?: CourseUpdateOneRequiredWithoutCompletionsNestedInput
    exam?: ExamUpdateOneRequiredWithoutCompletionsNestedInput
  }

  export type UserCourseCompletionUncheckedUpdateWithoutProcessInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    courseId?: IntFieldUpdateOperationsInput | number
    examId?: IntFieldUpdateOperationsInput | number
    completedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCourseCompletionUncheckedUpdateManyWithoutProcessInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    courseId?: IntFieldUpdateOperationsInput | number
    examId?: IntFieldUpdateOperationsInput | number
    completedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProcessDetailUpdateWithoutProcessInput = {
    pc_processTitle?: StringFieldUpdateOperationsInput | string
    pc_amountDay?: IntFieldUpdateOperationsInput | number
    pc_reasonType?: StringFieldUpdateOperationsInput | string
    processBranch?: ProcessBranchUpdateManyWithoutProcessDetailNestedInput
    processMat?: ProcessMatUpdateManyWithoutProcessDetailNestedInput
    processBom?: ProcessBomUpdateManyWithoutProcessDetailNestedInput
  }

  export type ProcessDetailUncheckedUpdateWithoutProcessInput = {
    id?: IntFieldUpdateOperationsInput | number
    pc_processTitle?: StringFieldUpdateOperationsInput | string
    pc_amountDay?: IntFieldUpdateOperationsInput | number
    pc_reasonType?: StringFieldUpdateOperationsInput | string
    processBranch?: ProcessBranchUncheckedUpdateManyWithoutProcessDetailNestedInput
    processMat?: ProcessMatUncheckedUpdateManyWithoutProcessDetailNestedInput
    processBom?: ProcessBomUncheckedUpdateManyWithoutProcessDetailNestedInput
  }

  export type ProcessDetailUncheckedUpdateManyWithoutProcessInput = {
    id?: IntFieldUpdateOperationsInput | number
    pc_processTitle?: StringFieldUpdateOperationsInput | string
    pc_amountDay?: IntFieldUpdateOperationsInput | number
    pc_reasonType?: StringFieldUpdateOperationsInput | string
  }

  export type ProcessBranchCreateManyProcessDetailInput = {
    id?: number
    pc_remark: string
  }

  export type ProcessMatCreateManyProcessDetailInput = {
    id?: number
    pc_matId: string
    pc_matamount: number
  }

  export type ProcessBomCreateManyProcessDetailInput = {
    id?: number
    pc_bomId: string
    pc_bomamount: number
  }

  export type ProcessBranchUpdateWithoutProcessDetailInput = {
    pc_remark?: StringFieldUpdateOperationsInput | string
  }

  export type ProcessBranchUncheckedUpdateWithoutProcessDetailInput = {
    id?: IntFieldUpdateOperationsInput | number
    pc_remark?: StringFieldUpdateOperationsInput | string
  }

  export type ProcessBranchUncheckedUpdateManyWithoutProcessDetailInput = {
    id?: IntFieldUpdateOperationsInput | number
    pc_remark?: StringFieldUpdateOperationsInput | string
  }

  export type ProcessMatUpdateWithoutProcessDetailInput = {
    pc_matamount?: IntFieldUpdateOperationsInput | number
    stock?: StockUpdateOneRequiredWithoutProcessMatNestedInput
  }

  export type ProcessMatUncheckedUpdateWithoutProcessDetailInput = {
    id?: IntFieldUpdateOperationsInput | number
    pc_matId?: StringFieldUpdateOperationsInput | string
    pc_matamount?: IntFieldUpdateOperationsInput | number
  }

  export type ProcessMatUncheckedUpdateManyWithoutProcessDetailInput = {
    id?: IntFieldUpdateOperationsInput | number
    pc_matId?: StringFieldUpdateOperationsInput | string
    pc_matamount?: IntFieldUpdateOperationsInput | number
  }

  export type ProcessBomUpdateWithoutProcessDetailInput = {
    pc_bomamount?: IntFieldUpdateOperationsInput | number
    stock?: StockUpdateOneRequiredWithoutProcessBomNestedInput
  }

  export type ProcessBomUncheckedUpdateWithoutProcessDetailInput = {
    id?: IntFieldUpdateOperationsInput | number
    pc_bomId?: StringFieldUpdateOperationsInput | string
    pc_bomamount?: IntFieldUpdateOperationsInput | number
  }

  export type ProcessBomUncheckedUpdateManyWithoutProcessDetailInput = {
    id?: IntFieldUpdateOperationsInput | number
    pc_bomId?: StringFieldUpdateOperationsInput | string
    pc_bomamount?: IntFieldUpdateOperationsInput | number
  }

  export type ProjectDetailCreateManyProjectInput = {
    id?: number
    pj_bluePrintNo: string
    pj_serialNumber: string
    pj_processTitle: string
    pj_amountDay: number
    pj_reasonType: string
    pj_statusPc: string
  }

  export type ProjectDetailUpdateWithoutProjectInput = {
    pj_bluePrintNo?: StringFieldUpdateOperationsInput | string
    pj_serialNumber?: StringFieldUpdateOperationsInput | string
    pj_processTitle?: StringFieldUpdateOperationsInput | string
    pj_amountDay?: IntFieldUpdateOperationsInput | number
    pj_reasonType?: StringFieldUpdateOperationsInput | string
    pj_statusPc?: StringFieldUpdateOperationsInput | string
    projectBranch?: ProjectBranchUpdateManyWithoutProjectDetailNestedInput
    projectMat?: ProjectMatUpdateManyWithoutProjectDetailNestedInput
    projectBom?: ProjectBomUpdateManyWithoutProjectDetailNestedInput
    ProjectResUser?: ProjectResUserUpdateManyWithoutProjectDetailNestedInput
  }

  export type ProjectDetailUncheckedUpdateWithoutProjectInput = {
    id?: IntFieldUpdateOperationsInput | number
    pj_bluePrintNo?: StringFieldUpdateOperationsInput | string
    pj_serialNumber?: StringFieldUpdateOperationsInput | string
    pj_processTitle?: StringFieldUpdateOperationsInput | string
    pj_amountDay?: IntFieldUpdateOperationsInput | number
    pj_reasonType?: StringFieldUpdateOperationsInput | string
    pj_statusPc?: StringFieldUpdateOperationsInput | string
    projectBranch?: ProjectBranchUncheckedUpdateManyWithoutProjectDetailNestedInput
    projectMat?: ProjectMatUncheckedUpdateManyWithoutProjectDetailNestedInput
    projectBom?: ProjectBomUncheckedUpdateManyWithoutProjectDetailNestedInput
    ProjectResUser?: ProjectResUserUncheckedUpdateManyWithoutProjectDetailNestedInput
  }

  export type ProjectDetailUncheckedUpdateManyWithoutProjectInput = {
    id?: IntFieldUpdateOperationsInput | number
    pj_bluePrintNo?: StringFieldUpdateOperationsInput | string
    pj_serialNumber?: StringFieldUpdateOperationsInput | string
    pj_processTitle?: StringFieldUpdateOperationsInput | string
    pj_amountDay?: IntFieldUpdateOperationsInput | number
    pj_reasonType?: StringFieldUpdateOperationsInput | string
    pj_statusPc?: StringFieldUpdateOperationsInput | string
  }

  export type ProjectBranchCreateManyProjectDetailInput = {
    id?: number
    pj_remark: string
  }

  export type ProjectMatCreateManyProjectDetailInput = {
    id?: number
    pj_matId: string
    pj_matamount: number
    pj_matTatal: number
  }

  export type ProjectBomCreateManyProjectDetailInput = {
    id?: number
    pj_bomId: string
    pj_bomamount: number
    pj_bomTatal: number
  }

  export type ProjectResUserCreateManyProjectDetailInput = {
    id?: number
    pj_userId: string
  }

  export type ProjectBranchUpdateWithoutProjectDetailInput = {
    pj_remark?: StringFieldUpdateOperationsInput | string
  }

  export type ProjectBranchUncheckedUpdateWithoutProjectDetailInput = {
    id?: IntFieldUpdateOperationsInput | number
    pj_remark?: StringFieldUpdateOperationsInput | string
  }

  export type ProjectBranchUncheckedUpdateManyWithoutProjectDetailInput = {
    id?: IntFieldUpdateOperationsInput | number
    pj_remark?: StringFieldUpdateOperationsInput | string
  }

  export type ProjectMatUpdateWithoutProjectDetailInput = {
    pj_matamount?: IntFieldUpdateOperationsInput | number
    pj_matTatal?: IntFieldUpdateOperationsInput | number
    stock?: StockUpdateOneRequiredWithoutProjectMatNestedInput
  }

  export type ProjectMatUncheckedUpdateWithoutProjectDetailInput = {
    id?: IntFieldUpdateOperationsInput | number
    pj_matId?: StringFieldUpdateOperationsInput | string
    pj_matamount?: IntFieldUpdateOperationsInput | number
    pj_matTatal?: IntFieldUpdateOperationsInput | number
  }

  export type ProjectMatUncheckedUpdateManyWithoutProjectDetailInput = {
    id?: IntFieldUpdateOperationsInput | number
    pj_matId?: StringFieldUpdateOperationsInput | string
    pj_matamount?: IntFieldUpdateOperationsInput | number
    pj_matTatal?: IntFieldUpdateOperationsInput | number
  }

  export type ProjectBomUpdateWithoutProjectDetailInput = {
    pj_bomamount?: IntFieldUpdateOperationsInput | number
    pj_bomTatal?: IntFieldUpdateOperationsInput | number
    stock?: StockUpdateOneRequiredWithoutProjectBomNestedInput
  }

  export type ProjectBomUncheckedUpdateWithoutProjectDetailInput = {
    id?: IntFieldUpdateOperationsInput | number
    pj_bomId?: StringFieldUpdateOperationsInput | string
    pj_bomamount?: IntFieldUpdateOperationsInput | number
    pj_bomTatal?: IntFieldUpdateOperationsInput | number
  }

  export type ProjectBomUncheckedUpdateManyWithoutProjectDetailInput = {
    id?: IntFieldUpdateOperationsInput | number
    pj_bomId?: StringFieldUpdateOperationsInput | string
    pj_bomamount?: IntFieldUpdateOperationsInput | number
    pj_bomTatal?: IntFieldUpdateOperationsInput | number
  }

  export type ProjectResUserUpdateWithoutProjectDetailInput = {
    pj_userId?: StringFieldUpdateOperationsInput | string
  }

  export type ProjectResUserUncheckedUpdateWithoutProjectDetailInput = {
    id?: IntFieldUpdateOperationsInput | number
    pj_userId?: StringFieldUpdateOperationsInput | string
  }

  export type ProjectResUserUncheckedUpdateManyWithoutProjectDetailInput = {
    id?: IntFieldUpdateOperationsInput | number
    pj_userId?: StringFieldUpdateOperationsInput | string
  }

  export type ProcessMatCreateManyStockInput = {
    id?: number
    pc_processDetailId: number
    pc_matamount: number
  }

  export type ProcessBomCreateManyStockInput = {
    id?: number
    pc_processDetailId: number
    pc_bomamount: number
  }

  export type ProjectMatCreateManyStockInput = {
    id?: number
    pj_projectDetailId: number
    pj_matamount: number
    pj_matTatal: number
  }

  export type ProjectBomCreateManyStockInput = {
    id?: number
    pj_projectDetailId: number
    pj_bomamount: number
    pj_bomTatal: number
  }

  export type ProcessMatUpdateWithoutStockInput = {
    pc_matamount?: IntFieldUpdateOperationsInput | number
    processDetail?: ProcessDetailUpdateOneRequiredWithoutProcessMatNestedInput
  }

  export type ProcessMatUncheckedUpdateWithoutStockInput = {
    id?: IntFieldUpdateOperationsInput | number
    pc_processDetailId?: IntFieldUpdateOperationsInput | number
    pc_matamount?: IntFieldUpdateOperationsInput | number
  }

  export type ProcessMatUncheckedUpdateManyWithoutStockInput = {
    id?: IntFieldUpdateOperationsInput | number
    pc_processDetailId?: IntFieldUpdateOperationsInput | number
    pc_matamount?: IntFieldUpdateOperationsInput | number
  }

  export type ProcessBomUpdateWithoutStockInput = {
    pc_bomamount?: IntFieldUpdateOperationsInput | number
    processDetail?: ProcessDetailUpdateOneRequiredWithoutProcessBomNestedInput
  }

  export type ProcessBomUncheckedUpdateWithoutStockInput = {
    id?: IntFieldUpdateOperationsInput | number
    pc_processDetailId?: IntFieldUpdateOperationsInput | number
    pc_bomamount?: IntFieldUpdateOperationsInput | number
  }

  export type ProcessBomUncheckedUpdateManyWithoutStockInput = {
    id?: IntFieldUpdateOperationsInput | number
    pc_processDetailId?: IntFieldUpdateOperationsInput | number
    pc_bomamount?: IntFieldUpdateOperationsInput | number
  }

  export type ProjectMatUpdateWithoutStockInput = {
    pj_matamount?: IntFieldUpdateOperationsInput | number
    pj_matTatal?: IntFieldUpdateOperationsInput | number
    projectDetail?: ProjectDetailUpdateOneRequiredWithoutProjectMatNestedInput
  }

  export type ProjectMatUncheckedUpdateWithoutStockInput = {
    id?: IntFieldUpdateOperationsInput | number
    pj_projectDetailId?: IntFieldUpdateOperationsInput | number
    pj_matamount?: IntFieldUpdateOperationsInput | number
    pj_matTatal?: IntFieldUpdateOperationsInput | number
  }

  export type ProjectMatUncheckedUpdateManyWithoutStockInput = {
    id?: IntFieldUpdateOperationsInput | number
    pj_projectDetailId?: IntFieldUpdateOperationsInput | number
    pj_matamount?: IntFieldUpdateOperationsInput | number
    pj_matTatal?: IntFieldUpdateOperationsInput | number
  }

  export type ProjectBomUpdateWithoutStockInput = {
    pj_bomamount?: IntFieldUpdateOperationsInput | number
    pj_bomTatal?: IntFieldUpdateOperationsInput | number
    projectDetail?: ProjectDetailUpdateOneRequiredWithoutProjectBomNestedInput
  }

  export type ProjectBomUncheckedUpdateWithoutStockInput = {
    id?: IntFieldUpdateOperationsInput | number
    pj_projectDetailId?: IntFieldUpdateOperationsInput | number
    pj_bomamount?: IntFieldUpdateOperationsInput | number
    pj_bomTatal?: IntFieldUpdateOperationsInput | number
  }

  export type ProjectBomUncheckedUpdateManyWithoutStockInput = {
    id?: IntFieldUpdateOperationsInput | number
    pj_projectDetailId?: IntFieldUpdateOperationsInput | number
    pj_bomamount?: IntFieldUpdateOperationsInput | number
    pj_bomTatal?: IntFieldUpdateOperationsInput | number
  }

  export type ReasonDetailCreateManyReasonTypeNGInput = {
    id?: number
    reasondetailName: string
  }

  export type ReasonDetailUpdateWithoutReasonTypeNGInput = {
    reasondetailName?: StringFieldUpdateOperationsInput | string
  }

  export type ReasonDetailUncheckedUpdateWithoutReasonTypeNGInput = {
    id?: IntFieldUpdateOperationsInput | number
    reasondetailName?: StringFieldUpdateOperationsInput | string
  }

  export type ReasonDetailUncheckedUpdateManyWithoutReasonTypeNGInput = {
    id?: IntFieldUpdateOperationsInput | number
    reasondetailName?: StringFieldUpdateOperationsInput | string
  }

  export type ReportProcessCreateManyReportInput = {
    id?: number
    processNo: string
    amountday: number
  }

  export type ReportProcessUpdateWithoutReportInput = {
    processNo?: StringFieldUpdateOperationsInput | string
    amountday?: IntFieldUpdateOperationsInput | number
    reportStock?: ReportStockUpdateManyWithoutReportProcessNestedInput
  }

  export type ReportProcessUncheckedUpdateWithoutReportInput = {
    id?: IntFieldUpdateOperationsInput | number
    processNo?: StringFieldUpdateOperationsInput | string
    amountday?: IntFieldUpdateOperationsInput | number
    reportStock?: ReportStockUncheckedUpdateManyWithoutReportProcessNestedInput
  }

  export type ReportProcessUncheckedUpdateManyWithoutReportInput = {
    id?: IntFieldUpdateOperationsInput | number
    processNo?: StringFieldUpdateOperationsInput | string
    amountday?: IntFieldUpdateOperationsInput | number
  }

  export type ReportStockCreateManyReportProcessInput = {
    id?: number
    stockId: string
    stockamount: number
    stocktype: number
  }

  export type ReportStockUpdateWithoutReportProcessInput = {
    stockId?: StringFieldUpdateOperationsInput | string
    stockamount?: IntFieldUpdateOperationsInput | number
    stocktype?: IntFieldUpdateOperationsInput | number
  }

  export type ReportStockUncheckedUpdateWithoutReportProcessInput = {
    id?: IntFieldUpdateOperationsInput | number
    stockId?: StringFieldUpdateOperationsInput | string
    stockamount?: IntFieldUpdateOperationsInput | number
    stocktype?: IntFieldUpdateOperationsInput | number
  }

  export type ReportStockUncheckedUpdateManyWithoutReportProcessInput = {
    id?: IntFieldUpdateOperationsInput | number
    stockId?: StringFieldUpdateOperationsInput | string
    stockamount?: IntFieldUpdateOperationsInput | number
    stocktype?: IntFieldUpdateOperationsInput | number
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use UserCountOutputTypeDefaultArgs instead
     */
    export type UserCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CompanyCountOutputTypeDefaultArgs instead
     */
    export type CompanyCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CompanyCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DepartmentCountOutputTypeDefaultArgs instead
     */
    export type DepartmentCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DepartmentCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CourseCountOutputTypeDefaultArgs instead
     */
    export type CourseCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CourseCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ExamCountOutputTypeDefaultArgs instead
     */
    export type ExamCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ExamCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use QuestionCountOutputTypeDefaultArgs instead
     */
    export type QuestionCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = QuestionCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ChoiceCountOutputTypeDefaultArgs instead
     */
    export type ChoiceCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ChoiceCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ExamAttemptCountOutputTypeDefaultArgs instead
     */
    export type ExamAttemptCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ExamAttemptCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProcessCountOutputTypeDefaultArgs instead
     */
    export type ProcessCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProcessCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProcessDetailCountOutputTypeDefaultArgs instead
     */
    export type ProcessDetailCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProcessDetailCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProjectCountOutputTypeDefaultArgs instead
     */
    export type ProjectCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProjectCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProjectDetailCountOutputTypeDefaultArgs instead
     */
    export type ProjectDetailCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProjectDetailCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use StockCountOutputTypeDefaultArgs instead
     */
    export type StockCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = StockCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ReasonTypeNGCountOutputTypeDefaultArgs instead
     */
    export type ReasonTypeNGCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ReasonTypeNGCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ReportCountOutputTypeDefaultArgs instead
     */
    export type ReportCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ReportCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ReportProcessCountOutputTypeDefaultArgs instead
     */
    export type ReportProcessCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ReportProcessCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserDefaultArgs instead
     */
    export type UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CompanyDefaultArgs instead
     */
    export type CompanyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CompanyDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CompanyBranchDefaultArgs instead
     */
    export type CompanyBranchArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CompanyBranchDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DepartmentDefaultArgs instead
     */
    export type DepartmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DepartmentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CourseDefaultArgs instead
     */
    export type CourseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CourseDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserCourseCompletionDefaultArgs instead
     */
    export type UserCourseCompletionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserCourseCompletionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use courseTypeDefaultArgs instead
     */
    export type courseTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = courseTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EnrollmentDefaultArgs instead
     */
    export type EnrollmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EnrollmentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ExamDefaultArgs instead
     */
    export type ExamArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ExamDefaultArgs<ExtArgs>
    /**
     * @deprecated Use QuestionDefaultArgs instead
     */
    export type QuestionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = QuestionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ChoiceDefaultArgs instead
     */
    export type ChoiceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ChoiceDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ExamAttemptDefaultArgs instead
     */
    export type ExamAttemptArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ExamAttemptDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserAnswerDefaultArgs instead
     */
    export type UserAnswerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserAnswerDefaultArgs<ExtArgs>
    /**
     * @deprecated Use OplDocumentDefaultArgs instead
     */
    export type OplDocumentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = OplDocumentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use FileDefaultArgs instead
     */
    export type FileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = FileDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProcessDefaultArgs instead
     */
    export type ProcessArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProcessDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProcessDetailDefaultArgs instead
     */
    export type ProcessDetailArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProcessDetailDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProcessBranchDefaultArgs instead
     */
    export type ProcessBranchArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProcessBranchDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProcessMatDefaultArgs instead
     */
    export type ProcessMatArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProcessMatDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProcessBomDefaultArgs instead
     */
    export type ProcessBomArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProcessBomDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProjectDefaultArgs instead
     */
    export type ProjectArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProjectDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProjectDetailDefaultArgs instead
     */
    export type ProjectDetailArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProjectDetailDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProjectBranchDefaultArgs instead
     */
    export type ProjectBranchArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProjectBranchDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProjectMatDefaultArgs instead
     */
    export type ProjectMatArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProjectMatDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProjectBomDefaultArgs instead
     */
    export type ProjectBomArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProjectBomDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProjectResUserDefaultArgs instead
     */
    export type ProjectResUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProjectResUserDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CompanyHourDefaultArgs instead
     */
    export type CompanyHourArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CompanyHourDefaultArgs<ExtArgs>
    /**
     * @deprecated Use StockDefaultArgs instead
     */
    export type StockArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = StockDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ReasonStockNGDefaultArgs instead
     */
    export type ReasonStockNGArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ReasonStockNGDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ReasonTypeNGDefaultArgs instead
     */
    export type ReasonTypeNGArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ReasonTypeNGDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ReasonDetailDefaultArgs instead
     */
    export type ReasonDetailArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ReasonDetailDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ReportDefaultArgs instead
     */
    export type ReportArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ReportDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ReportProcessDefaultArgs instead
     */
    export type ReportProcessArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ReportProcessDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ReportStockDefaultArgs instead
     */
    export type ReportStockArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ReportStockDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}